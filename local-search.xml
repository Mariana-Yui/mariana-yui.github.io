<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>webpack源码分析</title>
    <link href="/2023/09/12/2023-09-12/"/>
    <url>/2023/09/12/2023-09-12/</url>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/Mariana-Yui/images/master/blog-imgs/202309121127705.png" alt="" /></p>]]></content>
    
    
    <categories>
      
      <category>webpack</category>
      
    </categories>
    
    
    <tags>
      
      <tag>webpack</tag>
      
      <tag>工程化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《JavaScript设计模式与开发实践》读书笔记</title>
    <link href="/2023/09/10/2023-09-10-javascript-design-mode-and-practice-record/"/>
    <url>/2023/09/10/2023-09-10-javascript-design-mode-and-practice-record/</url>
    
    <content type="html"><![CDATA[<blockquote><p>之前一直对设计模式方面的知识没有系统的学习, 私以为对常见设计模式和编程范型的掌握对提升架构思维和代码重构能力是很有帮助的. 本文为阅读《JavaScript 设计模式与开发实践》过程中的随笔, 包括 JavaScript 遗漏的基础知识的完善以及常见设计模式记录.</p></blockquote><p><em>不定期更新 平常上班摸鱼的时候也是在看 webpack 源码…毕竟不能明目张胆的掏本书出来(随笔完结后该段删除)</em></p><h1 id="第一部分"><a class="markdownIt-Anchor" href="#第一部分"></a> 第一部分</h1><p><strong>JavaScript 部分基础知识难点</strong></p><h3 id="工厂函数"><a class="markdownIt-Anchor" href="#工厂函数"></a> 工厂函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> objectFactory = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>  <span class="hljs-title class_">Constructor</span> = [].<span class="hljs-property">shift</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>);<br>  obj.<span class="hljs-property">__proto__</span> = <span class="hljs-title class_">Constructor</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>;<br>  <span class="hljs-keyword">const</span> ret = <span class="hljs-title class_">Constructor</span>.<span class="hljs-title function_">apply</span>(obj, <span class="hljs-variable language_">arguments</span>);<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> ret === <span class="hljs-string">&quot;object&quot;</span> ? ret : obj;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="原型链"><a class="markdownIt-Anchor" href="#原型链"></a> 原型链</h3><p>底层对象层层向上查找委托给当前对象的<strong>构造器</strong>的原型下的对应属性/方法.<br />例如 C -&gt; B -&gt; A, 查找顺序为:</p><p><img src="https://dev.azure.com/HealMSlin/8544be09-1224-4eb0-824b-90c4ec9d49ee/_apis/git/repositories/7a27a721-4c93-4ecf-8258-d5422217b60a/items?path=%2F1694348789862_8851.png&amp;versionDescriptor%5BversionOptions%5D=0&amp;versionDescriptor%5BversionType%5D=0&amp;versionDescriptor%5Bversion%5D=master&amp;resolveLfs=true&amp;%24format=octetStream&amp;api-version=5.0" alt="" /></p><h3 id="bind-函数"><a class="markdownIt-Anchor" href="#bind-函数"></a> bind 函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">bind</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">context</span>) &#123;<br>  <span class="hljs-keyword">const</span> self = <span class="hljs-variable language_">this</span>;<br>  context = [].<span class="hljs-property">shift</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>);<br>  <span class="hljs-keyword">const</span> args = [].<span class="hljs-property">slice</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> self.<span class="hljs-title function_">apply</span>(context, [].<span class="hljs-property">concat</span>.<span class="hljs-title function_">call</span>(args, [].<span class="hljs-property">slice</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>)));<br>  &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="引用原文"><a class="markdownIt-Anchor" href="#引用原文"></a> 引用原文</h3><blockquote><p>如果在一个大函数中有一些代码块能够独立出来，我们常常把这些代码块封装在独立的小函数里面。独立出来的小函数有助于代码复用，如果这些小函数有一个良好的命名，它们本身也起到了注释的作用。如果这些小函数不需要在程序的其他地方使用，最好是把它们用闭包封闭起来。</p></blockquote><p>笔者完全认同后半句: <strong>如果这些小函数不需要在程序的其他地方使用, 最好是把它们用闭包封闭起来</strong> ; 前半句在大多数业务场景中其实所谓的复用更多的只是对于自身来说, 对于其他同事多半是无关痛痒的, 需要避免 <strong>过渡封装</strong>.</p><h3 id="aop"><a class="markdownIt-Anchor" href="#aop"></a> AOP</h3><p>AOP (面向切面编程)的主要作用是把一些跟核心业务逻辑模块无关的功能抽离出来, 这些跟业务逻辑无关的功能通常包括日志统计、安全控制、异常处理等.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">before</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">beforefn</span>) &#123;<br>  <span class="hljs-keyword">const</span> _self = <span class="hljs-variable language_">this</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    beforefn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-variable language_">arguments</span>);<br>    <span class="hljs-keyword">return</span> _self.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-variable language_">arguments</span>);<br>  &#125;;<br>&#125;;<br><br><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">after</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">afterfn</span>) &#123;<br>  <span class="hljs-keyword">const</span> _self = <span class="hljs-variable language_">this</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> ret = _self.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-variable language_">arguments</span>);<br>    afterfn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-variable language_">arguments</span>);<br>    <span class="hljs-keyword">return</span> ret;<br>  &#125;;<br>&#125;;<br><br><span class="hljs-keyword">let</span> func = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>);<br>&#125;;<br><br>func = func<br>  .<span class="hljs-title function_">before</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);<br>  &#125;)<br>  .<span class="hljs-title function_">after</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>);<br>  &#125;);<br><br><span class="hljs-title function_">func</span>();<br></code></pre></td></tr></table></figure><h3 id="currying-柯里化"><a class="markdownIt-Anchor" href="#currying-柯里化"></a> Currying 柯里化</h3><p><code>currying</code> 又称为部分求值, 一个<code>currying</code>的函数首先会接受一些参数, 接受了这些参数之后, 该函数并不会立即求值, 而是继续返回另外一个函数, 刚才传入的参数在函数形成的闭包中被保存起来. 待到函数被真正需要求值的时候, 之前传入的所有参数都会被一次性用于求值.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 抽象的柯里化函数</span><br><span class="hljs-keyword">var</span> currying = <span class="hljs-keyword">function</span>(<span class="hljs-params">fn</span>) &#123;<br><span class="hljs-keyword">var</span> args = [];<br><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">return</span> fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>[].<span class="hljs-property">push</span>.<span class="hljs-title function_">apply</span>(args, <span class="hljs-variable language_">arguments</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-variable language_">arguments</span>.<span class="hljs-property">callee</span>;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> cost = (<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">var</span> money = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>, l=<span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span>; i&lt;l; i++) &#123;<br>money +=<span class="hljs-variable language_">arguments</span>[i];<br>&#125;<br><span class="hljs-keyword">return</span> money;<br>&#125;<br>&#125;)();<br><br><span class="hljs-keyword">var</span> cost = <span class="hljs-title function_">currying</span>(cost);<br><br><span class="hljs-title function_">cost</span>(<span class="hljs-number">100</span>);<br><span class="hljs-title function_">cost</span>(<span class="hljs-number">200</span>);<br><span class="hljs-title function_">cost</span>(<span class="hljs-number">300</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">cost</span>()); <span class="hljs-comment">// 计算</span><br></code></pre></td></tr></table></figure><p><strong>arguments.callee</strong></p><blockquote><p>The <strong><code>arguments.callee</code></strong> data property contains the currently executing function that the arguments belong to.</p></blockquote><p>对于上面的例子, <code>arguments.callee</code>即柯里化后的函数 <strong>cost()</strong> , 所以闭包部分亦可以写成:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">cost</span>(<span class="hljs-number">100</span>)(<span class="hljs-number">200</span>)(<span class="hljs-number">300</span>);<br></code></pre></td></tr></table></figure><h3 id="鸭子类型"><a class="markdownIt-Anchor" href="#鸭子类型"></a> 鸭子类型</h3><p>鸭子类型思想即只要一只动物长得像鸭子, 声音像鸭子, 那它就是 🦆. 类比到 JavaScript 中, 当我们调用对象的某个方法时, 不用关心该对象原本是否被设计成拥有这个方法, 这是动态语言的特性.<br />JavaScript 中的 <strong>call()</strong>、 <strong>apply()</strong> 都可以满足这样的需求.</p><h3 id="uncurrying"><a class="markdownIt-Anchor" href="#uncurrying"></a> uncurrying</h3><p>以 Array 方法为例, 通过<code>uncurrying</code>的方式, <code>Array.prototype.push</code>变成通用的<strong>push</strong>函数.<br /><code>uncurrying</code>的两种实现:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 1.</span><br><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">uncurrying</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">var</span> self = <span class="hljs-variable language_">this</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">var</span> obj = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">shift</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>);<br><span class="hljs-keyword">return</span> self.<span class="hljs-title function_">apply</span>(obj, <span class="hljs-variable language_">arguments</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 2.</span><br><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">uncurrying</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">var</span> self = thisl<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">call</span>.<span class="hljs-title function_">apply</span>(self, <span class="hljs-variable language_">arguments</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>第二种不太好理解一点, 以 <strong>push(obj, 1)</strong> 函数为例, 2.最后可以理解成:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">call</span>.<span class="hljs-title function_">apply</span>(push, [obj, <span class="hljs-number">1</span>]);<br><span class="hljs-comment">// 即</span><br>push.<span class="hljs-title function_">call</span>(obj, <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><h3 id="惰性加载函数"><a class="markdownIt-Anchor" href="#惰性加载函数"></a> 惰性加载函数</h3><p>用图表画出来更直观一点…<br /><img src="https://dev.azure.com/HealMSlin/8544be09-1224-4eb0-824b-90c4ec9d49ee/_apis/git/repositories/7a27a721-4c93-4ecf-8258-d5422217b60a/items?path=%2F1694368984825_2012.png&amp;versionDescriptor%5BversionOptions%5D=0&amp;versionDescriptor%5BversionType%5D=0&amp;versionDescriptor%5Bversion%5D=master&amp;resolveLfs=true&amp;%24format=octetStream&amp;api-version=5.0" alt="" /></p><h1 id="第二部分"><a class="markdownIt-Anchor" href="#第二部分"></a> 第二部分</h1><p><strong>设计模式</strong></p>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>standard-version源码分析</title>
    <link href="/2023/05/08/2023-05-08-standard-version-source-code-analysis/"/>
    <url>/2023/05/08/2023-05-08-standard-version-source-code-analysis/</url>
    
    <content type="html"><![CDATA[<h1 id="背景"><a class="markdownIt-Anchor" href="#背景"></a> 背景</h1><p>最近又要搞个系统平台, 后续大小迭代通过版本号标识, 很自然地想到<strong><a href="http://CHANGELOG.md">CHANGELOG.md</a></strong>, 调研后发现</p><h1 id="使用教程"><a class="markdownIt-Anchor" href="#使用教程"></a> 使用教程</h1><p>完整的配置参考<a href="https://segmentfault.com/a/1190000039813329">自动产出 changelog-第二节：自动产出</a></p><p>简单说下在自己项目中用到的配置:</p><h2 id="versionrc"><a class="markdownIt-Anchor" href="#versionrc"></a> .versionrc</h2><p>配置 CHANGELOG 的展示 format</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;header&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;# 更新历史 \n\n&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;types&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;feat&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;section&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;✨ Features | 新功能&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;hidden&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;fix&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;section&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;🐛 Bug Fixes | Bug 修复&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;hidden&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;perf&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;section&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;⚡ Performance Improvements | 性能优化&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;hidden&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;revert&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;section&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;⏪ Reverts | 回退&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;hidden&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;chore&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;section&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;📦 Chores | 其他更新&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;hidden&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;docs&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;section&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;📝 Documentation | 文档&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;hidden&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;style&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;section&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;💄 Styles | 风格&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;hidden&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;refactor&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;section&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;♻ Code Refactoring | 代码重构&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;hidden&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;test&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;section&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;✅ Tests | 测试&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;hidden&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;build&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;section&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;👷‍ Build System | 构建&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;hidden&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ci&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;section&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;🔧 Continuous Integration | CI 配置&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;hidden&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span>```<br><br>## package.json<br>配置skip<span class="hljs-punctuation">,</span> bump<span class="hljs-punctuation">:</span> 升级版本号<span class="hljs-punctuation">,</span> commit<span class="hljs-punctuation">:</span> 提交代码<span class="hljs-punctuation">,</span> tag<span class="hljs-punctuation">:</span> 打tag<br>```json<br><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;standard-version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;skip&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;bump&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;commit&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;tag&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="命令"><a class="markdownIt-Anchor" href="#命令"></a> 命令</h2><p>指定<code>--release-as</code>为 patch, 每次升级递增小版本号(1.2.3 依次为大中小版本号); <code>--tag-prefix</code>为 wework-bot@ 指定 tag 的前缀, 不加前缀默认为 v, 因为该项目会打包为 docker 镜像, tag 会作为镜像版本, 所以这里需要加上前缀, 一般情况不需要加.</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">standard-version <span class="hljs-params">--release-as</span> <span class="hljs-keyword">patch</span> <span class="hljs-params">--tag-prefix</span> wework-bot@<br></code></pre></td></tr></table></figure><h2 id="输出内容"><a class="markdownIt-Anchor" href="#输出内容"></a> 输出内容</h2><p>按照以上配置执行命令后根据终端输出可以发现发生了以下行为:</p><ol><li>升级 package.json 版本号(如果没有指定<code>--first-release</code>第一次执行)</li><li>生成 <a href="http://CHANGELOG.md">CHANGELOG.md</a>(如果没有), 在开头加上距离上个 tag 之后的所有提交记录(符合提交规范的提交信息)</li><li>提交本地上面涉及到的所有改动文件到远端</li><li>打 tag 并提交远端</li></ol><h1 id="源码分析"><a class="markdownIt-Anchor" href="#源码分析"></a> 源码分析</h1><p>明确了上述的配置以及命令输出内容, 就可以到源码中查看具体实现了, 我的建议是有目的性的去看源码, 因为<strong>standard-version</strong>这个工具中很多的功能例如项目中实际上根本没用到, 也就没有立刻理解的必要, 看源码的时候直接跳过就好.</p><p>首先在 package.json 中查看入口文件逻辑: <strong>bin/cli.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> standardVersion = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;../index&quot;</span>);<br><span class="hljs-keyword">const</span> cmdParser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;../command&quot;</span>);<br><span class="hljs-title function_">standardVersion</span>(cmdParser.<span class="hljs-property">argv</span>);<br></code></pre></td></tr></table></figure><p><strong>./command.js</strong></p><p>yargs 指定的一系列参数, 会结合<a href="https://github.com/conventional-changelog/conventional-changelog-config-spec/blob/master/versions/2.2.0/README.md#conventional-changelog-configuration-spec-v210">conventional-changelog-config-spec</a>预置的参数同意作为<strong>standard-version</strong>的可选参数.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> spec = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;conventional-changelog-config-spec&quot;</span>);<br><span class="hljs-keyword">const</span> yargs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;yargs&quot;</span>)<br>  .<span class="hljs-title function_">option</span>(<span class="hljs-string">&quot;release-as&quot;</span>, &#123;<br>    <span class="hljs-attr">alias</span>: <span class="hljs-string">&quot;r&quot;</span>,<br>    <span class="hljs-attr">describe</span>:<br>      <span class="hljs-string">&quot;Specify the release type manually (like npm version &lt;major|minor|patch&gt;)&quot;</span>,<br>    <span class="hljs-attr">requiresArg</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">string</span>: <span class="hljs-literal">true</span>,<br>  &#125;)<br>  <span class="hljs-comment">//...</span><br>  .<span class="hljs-title function_">config</span>(<span class="hljs-title function_">getConfiguration</span>())<br>  .<span class="hljs-title function_">pkgConf</span>(<span class="hljs-string">&quot;standard-version&quot;</span>);<br><span class="hljs-comment">//...</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(spec.<span class="hljs-property">properties</span>).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">propertyKey</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> property = spec.<span class="hljs-property">properties</span>[propertyKey];<br>  yargs.<span class="hljs-title function_">option</span>(propertyKey, &#123;<br>    <span class="hljs-comment">//...</span><br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p><code>--release-as</code>, <code>--tag-prefix</code>等参数就是这里注册的.<br />yargs.config(getConfiguration())注入了 <strong>./lib/configuration.js</strong> 的配置, 文件中指定了默认的配置文件名, 表明 yargs 初始化时会在项目根目录下查找这些文件, 注册给 yargs.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">CONFIGURATION_FILES</span> = [<br>  <span class="hljs-string">&quot;.versionrc&quot;</span>,<br>  <span class="hljs-string">&quot;.versionrc.cjs&quot;</span>,<br>  <span class="hljs-string">&quot;.versionrc.json&quot;</span>,<br>  <span class="hljs-string">&quot;.versionrc.js&quot;</span>,<br>];<br></code></pre></td></tr></table></figure><p><strong>.config()</strong></p><blockquote><p>Tells the parser that if the option specified by <code>key</code> is passed in, it should be interpreted as a path to a JSON config file. The file is loaded and parsed, and its properties are set as arguments. Because the file is loaded using Node’s require(), the filename MUST end in <code>.json</code> to be interpreted correctly.</p></blockquote><p>根据 yargs 官网对<strong>config(object)</strong> api 的描述, 参数是 json 对象, 且对象 key 都会作为 yargs 的 key; 上述 <strong>.versionrc</strong> 中配置的<strong>header</strong>, <strong>type</strong> 等都可以通过 <code>yargs.header</code>, <code>yargs.type</code> 获取.</p><p>同时 yargs.pkgConf(‘standard-version’)作用和.config()类似会在<strong>package.json</strong>中查询键名为 standard-version 的配置, 上述<strong>package,json</strong>中配置的 skip 也可以通过<code>yargs.skip.bump</code>, <code>yargs.skip.commit</code>, <code>yargs.skip.tag</code>获取.</p><p><strong>.pkg(key, [cwd])</strong></p><blockquote><p>Similar to <a href="https://github.com/yargs/yargs/blob/main/docs/api.md#config"><code>config()</code></a>, indicates that yargs should interpret the object from the specified key in package.json as a configuration object.<br /><code>cwd</code> can optionally be provided, the package.json will be read from this location.</p></blockquote><p><strong>./index.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">standardVersion</span>(<span class="hljs-params">argv</span>) &#123;<br>  <span class="hljs-comment">//...</span><br>  <span class="hljs-comment">// 1. step1</span><br>  <span class="hljs-keyword">const</span> args = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(&#123;&#125;, defaults, argv);<br>  <span class="hljs-keyword">let</span> pkg;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> packageFile <span class="hljs-keyword">of</span> args.<span class="hljs-property">packageFiles</span>) &#123;<br>    <span class="hljs-keyword">const</span> updater = <span class="hljs-title function_">resolveUpdaterObjectFromArgument</span>(packageFile);<br>    <span class="hljs-keyword">if</span> (!updater) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">const</span> pkgPath = path.<span class="hljs-title function_">resolve</span>(process.<span class="hljs-title function_">cwd</span>(), updater.<span class="hljs-property">filename</span>);<br>    <span class="hljs-keyword">const</span> contents = fs.<span class="hljs-title function_">readFileSync</span>(pkgPath, <span class="hljs-string">&quot;utf8&quot;</span>);<br>    pkg = &#123;<br>      <span class="hljs-attr">version</span>: updater.<span class="hljs-property">updater</span>.<span class="hljs-title function_">readVersion</span>(contents),<br>      <span class="hljs-attr">private</span>:<br>        <span class="hljs-keyword">typeof</span> updater.<span class="hljs-property">updater</span>.<span class="hljs-property">isPrivate</span> === <span class="hljs-string">&quot;function&quot;</span><br>          ? updater.<span class="hljs-property">updater</span>.<span class="hljs-title function_">isPrivate</span>(contents)<br>          : <span class="hljs-literal">false</span>,<br>    &#125;;<br>    <span class="hljs-keyword">break</span>;<br>  &#125;<br>  <span class="hljs-comment">// 2. step2</span><br>  <span class="hljs-keyword">let</span> version;<br>  <span class="hljs-keyword">if</span> (pkg) &#123;<br>    version = pkg.<span class="hljs-property">version</span>;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (args.<span class="hljs-property">gitTagFallback</span>) &#123;<br>    version = <span class="hljs-keyword">await</span> <span class="hljs-title function_">latestSemverTag</span>(args.<span class="hljs-property">tagPrefix</span>);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;no package file found&quot;</span>);<br>  &#125;<br>  <span class="hljs-comment">// 核心逻辑</span><br>  <span class="hljs-keyword">const</span> newVersion = <span class="hljs-keyword">await</span> <span class="hljs-title function_">bump</span>(args, version);<br>  <span class="hljs-keyword">await</span> <span class="hljs-title function_">changelog</span>(args, newVersion);<br>  <span class="hljs-keyword">await</span> <span class="hljs-title function_">commit</span>(args, newVersion);<br>  <span class="hljs-keyword">await</span> <span class="hljs-title function_">tag</span>(newVersion, pkg ? pkg.<span class="hljs-property">private</span> : <span class="hljs-literal">false</span>, args);<br>&#125;;<br></code></pre></td></tr></table></figure><p>运行命令时附带的参数以及 <strong>.config()</strong>. <strong>.pkgConf()</strong> 配置的参数都会作为函数的参数.<br /><strong>./index.js</strong> 函数除去一些校验逻辑, 主要做了两件事:</p><ol><li><p>结合 argv 和默认配置(位于 <strong>./default.js</strong>), 然后检索默认配置的<strong>packageFiles</strong>, 这里主要就是获取<strong>package.json</strong>中的 version 作为当前版本号. 可以看到遍历中存在 break, 找到文件就不会继续查询了.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">defaults.<span class="hljs-property">packageFiles</span> = [<span class="hljs-string">&quot;package.json&quot;</span>, <span class="hljs-string">&quot;bower.json&quot;</span>, <span class="hljs-string">&quot;manifest.json&quot;</span>];<br></code></pre></td></tr></table></figure></li><li><p>核心逻辑</p></li></ol><h2 id="核心逻辑"><a class="markdownIt-Anchor" href="#核心逻辑"></a> 核心逻辑</h2><h3 id="21-更新版本号"><a class="markdownIt-Anchor" href="#21-更新版本号"></a> 2.1 更新版本号</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> newVersion = <span class="hljs-keyword">await</span> <span class="hljs-title function_">bump</span>(args, version);<br></code></pre></td></tr></table></figure><p><strong>./lifecycles/bump.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (!args.<span class="hljs-property">firstRelease</span>) &#123;<br>  <span class="hljs-keyword">const</span> releaseType = <span class="hljs-title function_">getReleaseType</span>(<br>    args.<span class="hljs-property">prerelease</span>,<br>    release.<span class="hljs-property">releaseType</span>,<br>    version<br>  );<br>  newVersion =<br>    semver.<span class="hljs-title function_">valid</span>(releaseType) ||<br>    semver.<span class="hljs-title function_">inc</span>(version, releaseType, args.<span class="hljs-property">prerelease</span>);<br>  <span class="hljs-title function_">updateConfigs</span>(args, newVersion);<br>&#125;<br></code></pre></td></tr></table></figure><p>最关键的就上面这段逻辑, 如果是第一次发布(<code>--first-release</code>), 就不更新版本号, 否则根据<code>--release-as</code>更新, 这里用到了<strong>semver</strong>第三方库, 可以判断<code>--release-as</code>是否合法(<strong>.valid()</strong>), 根据<code>--release-as</code>自动判断生成新的版本号(<strong>.inc()</strong>), 完整使用参考<a href="https://www.npmjs.com/package/semver">npm semver</a>. 最后返回新的版本号.</p><h3 id="22-生成-changelog"><a class="markdownIt-Anchor" href="#22-生成-changelog"></a> 2.2 生成 CHANGELOG</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">await</span> <span class="hljs-title function_">changelog</span>(args, newVersion);<br></code></pre></td></tr></table></figure><p><strong>./lifecycles/changelog.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">START_OF_LAST_RELEASE_PATTERN</span> = <span class="hljs-regexp">/(^#+ \[?[0-9]+\.[0-9]+\.[0-9]+|&lt;a name=)/m</span><br><br><span class="hljs-title function_">createIfMissing</span>(args)<br>    <span class="hljs-keyword">const</span> header = args.<span class="hljs-property">header</span><br><br>    <span class="hljs-keyword">let</span> oldContent = args.<span class="hljs-property">dryRun</span> ? <span class="hljs-string">&#x27;&#x27;</span> : fs.<span class="hljs-title function_">readFileSync</span>(args.<span class="hljs-property">infile</span>, <span class="hljs-string">&#x27;utf-8&#x27;</span>)<br>    <span class="hljs-keyword">const</span> oldContentStart = oldContent.<span class="hljs-title function_">search</span>(<span class="hljs-variable constant_">START_OF_LAST_RELEASE_PATTERN</span>)<br>    <span class="hljs-keyword">if</span> (oldContentStart !== -<span class="hljs-number">1</span>) &#123;<br>      oldContent = oldContent.<span class="hljs-title function_">substring</span>(oldContentStart)<br>    &#125;<br>    <span class="hljs-keyword">let</span> content = <span class="hljs-string">&#x27;&#x27;</span><br>    <span class="hljs-keyword">const</span> context = &#123; <span class="hljs-attr">version</span>: newVersion &#125;<br>    <span class="hljs-keyword">const</span> changelogStream = <span class="hljs-title function_">conventionalChangelog</span>(&#123;<br>      <span class="hljs-attr">debug</span>: args.<span class="hljs-property">verbose</span> &amp;&amp; <span class="hljs-variable language_">console</span>.<span class="hljs-property">info</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">console</span>, <span class="hljs-string">&#x27;conventional-changelog&#x27;</span>),<br>      <span class="hljs-attr">preset</span>: <span class="hljs-title function_">presetLoader</span>(args),<br>      <span class="hljs-attr">tagPrefix</span>: args.<span class="hljs-property">tagPrefix</span><br>    &#125;, context, &#123; <span class="hljs-attr">merges</span>: <span class="hljs-literal">null</span>, <span class="hljs-attr">path</span>: args.<span class="hljs-property">path</span> &#125;)<br>      .<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">reject</span>(err)<br>      &#125;)<br><br>    changelogStream.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">buffer</span>) &#123;<br>      content += buffer.<span class="hljs-title function_">toString</span>()<br>    &#125;)<br><br>    changelogStream.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;end&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-title function_">checkpoint</span>(args, <span class="hljs-string">&#x27;outputting changes to %s&#x27;</span>, [args.<span class="hljs-property">infile</span>])<br>      <span class="hljs-title function_">writeFile</span>(args, args.<span class="hljs-property">infile</span>, header + <span class="hljs-string">&#x27;\n&#x27;</span> + (content + oldContent).<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\n+$/</span>, <span class="hljs-string">&#x27;\n&#x27;</span>))<br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">resolve</span>()<br>    &#125;)<br>  &#125;)<br></code></pre></td></tr></table></figure><p>上述关键逻辑, 如果<strong><a href="http://CHANGELOG.md">CHANGELOG.md</a></strong>不存在则创建, 读取<strong><a href="http://CHANGELOG.md">CHANGELOG.md</a></strong>, 根据<strong>START_OF_LAST_RELEASE_PATTERN</strong>正则匹配 log 内容的开头的<code>### [x.x.x]</code>, 从而获取旧的历史提交内容; 然后使用<strong>conventional-changelog</strong>第三方库获取上一次 tag 之后的所有提交, 并按照 <strong>.versionrc</strong> 中配置的 type 分类返回新的 CHANGELOG 内容, 这个库提供的函数返回 stream, 需要监听数据流事件, 参考<a href="https://www.npmjs.com/package/conventional-changelog">npm conventional-changelog</a>. 在<code>end</code>事件回调中将 yargs.header, 新内容, 正则匹配到的就内容拼接重新写入<strong><a href="http://CHANGELOG.md">CHANGELOG.md</a></strong><br /><img src="https://dev.azure.com/HealMSlin/8544be09-1224-4eb0-824b-90c4ec9d49ee/_apis/git/repositories/7a27a721-4c93-4ecf-8258-d5422217b60a/items?path=%2F1683808772259_563.png&amp;versionDescriptor%5BversionOptions%5D=0&amp;versionDescriptor%5BversionType%5D=0&amp;versionDescriptor%5Bversion%5D=master&amp;resolveLfs=true&amp;%24format=octetStream&amp;api-version=5.0" alt="" /><br />图: <a href="http://CHANGELOG.md">CHANGELOG.md</a> 的内容格式</p><h3 id="23-提交代码"><a class="markdownIt-Anchor" href="#23-提交代码"></a> 2.3 提交代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">await</span> <span class="hljs-title function_">commit</span>(args, newVersion);<br></code></pre></td></tr></table></figure><p><strong>./commit</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (!args.<span class="hljs-property">skip</span>.<span class="hljs-property">changelog</span>) &#123;<br>  toAdd.<span class="hljs-title function_">push</span>(args.<span class="hljs-property">infile</span>);<br>&#125;<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(bump.<span class="hljs-title function_">getUpdatedConfigs</span>()).<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">p</span>) &#123;<br>  toAdd.<span class="hljs-title function_">push</span>(path.<span class="hljs-title function_">relative</span>(process.<span class="hljs-title function_">cwd</span>(), p));<br>&#125;);<br><span class="hljs-keyword">await</span> <span class="hljs-title function_">runExecFile</span>(args, <span class="hljs-string">&quot;git&quot;</span>, [<span class="hljs-string">&quot;add&quot;</span>].<span class="hljs-title function_">concat</span>(toAdd));<br><span class="hljs-keyword">await</span> <span class="hljs-title function_">runExecFile</span>(<br>  args,<br>  <span class="hljs-string">&quot;git&quot;</span>,<br>  [<span class="hljs-string">&quot;commit&quot;</span>].<span class="hljs-title function_">concat</span>(verify, sign, args.<span class="hljs-property">commitAll</span> ? [] : toAdd, [<br>    <span class="hljs-string">&quot;-m&quot;</span>,<br>    <span class="hljs-string">`<span class="hljs-subst">$&#123;formatCommitMessage(args.releaseCommitMessageFormat, newVersion)&#125;</span>`</span>,<br>  ])<br>);<br></code></pre></td></tr></table></figure><p>上述关键逻辑, 先获取上面两步修改的<strong>package.json</strong>(<code>bump.getUploadedConfigs()</code>), <strong><a href="http://CHANGELOG.md">CHANGELOG.md</a>*</strong>(<code>args.infile</code>), 然后就是执行<strong>git add</strong>和<strong>git commit -m --no-verify</strong>基本操作.<br />当时比较困惑的是 formatCommitMessage 哪来的, 你会发现查找源码并没有找到这个函数创建的地方, 这就要回到之前说的 <strong>./command.js</strong>最后将<strong>conventional-changelog-config-spec</strong>预置的属性合并到 args,<br />官方 api 中就能找到这个属性</p><h4 id="releasecommitmessageformat-string"><a class="markdownIt-Anchor" href="#releasecommitmessageformat-string"></a> releaseCommitMessageFormat (<code>string</code>)</h4><blockquote><p>A string to be used to format the auto-generated release commit message.</p></blockquote><p>默认值就是:</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml">chore(release): </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">currentTag</span>&#125;&#125;</span><br></code></pre></td></tr></table></figure><p><strong>./lib/format-commit-message.js</strong>中会将<code>&#123;&#123;currentTag&#125;&#125;</code>替换为新的版本号</p><p>在 git log 中也能够看到这条 commit message:<br /><img src="https://dev.azure.com/HealMSlin/8544be09-1224-4eb0-824b-90c4ec9d49ee/_apis/git/repositories/7a27a721-4c93-4ecf-8258-d5422217b60a/items?path=%2F1683877044866_1759.png&amp;versionDescriptor%5BversionOptions%5D=0&amp;versionDescriptor%5BversionType%5D=0&amp;versionDescriptor%5Bversion%5D=master&amp;resolveLfs=true&amp;%24format=octetStream&amp;api-version=5.0" alt="" /></p><h3 id="标记-tag"><a class="markdownIt-Anchor" href="#标记-tag"></a> 标记 tag</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">await</span> <span class="hljs-title function_">tag</span>(newVersion, pkg ? pkg.<span class="hljs-property">private</span> : <span class="hljs-literal">false</span>, args);<br></code></pre></td></tr></table></figure><p><strong>./lib/lifecycles/tag.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">await</span> <span class="hljs-title function_">runExecFile</span>(args, <span class="hljs-string">&quot;git&quot;</span>, [<br>  <span class="hljs-string">&quot;tag&quot;</span>,<br>  tagOption,<br>  args.<span class="hljs-property">tagPrefix</span> + newVersion,<br>  <span class="hljs-string">&quot;-m&quot;</span>,<br>  <span class="hljs-string">`<span class="hljs-subst">$&#123;formatCommitMessage(args.releaseCommitMessageFormat, newVersion)&#125;</span>`</span>,<br>]);<br><span class="hljs-keyword">const</span> currentBranch = <span class="hljs-keyword">await</span> <span class="hljs-title function_">runExecFile</span>(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;git&quot;</span>, [<br>  <span class="hljs-string">&quot;rev-parse&quot;</span>,<br>  <span class="hljs-string">&quot;--abbrev-ref&quot;</span>,<br>  <span class="hljs-string">&quot;HEAD&quot;</span>,<br>]);<br><span class="hljs-keyword">let</span> message = <span class="hljs-string">&quot;git push --follow-tags origin &quot;</span> + currentBranch.<span class="hljs-title function_">trim</span>();<br></code></pre></td></tr></table></figure><p>上述关键逻辑, 可以看到<code>--tag-prefix</code>配置此时就会作为<strong>git tag</strong>的前缀, 然后<strong>git push --follow-tags origin branch</strong>提交远端.<br />这里也收获一个小 tips: <strong>git rev-parse --abbrev-ref HEAD</strong> 获取当前分支名</p><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1><p><strong>standard-version</strong> 源码总体不复杂, 但是还是能学习到<strong>yargs</strong>, <strong>semver</strong>, <strong>conventional-changelog</strong>库的使用以及工程化的操作, 🐮 的不行.</p><h1 id="reference"><a class="markdownIt-Anchor" href="#reference"></a> reference</h1><ol><li><a href="https://segmentfault.com/a/1190000039813329">自动产出 changelog-第二节：自动产出</a></li><li><a href="https://github.com/conventional-changelog/conventional-changelog-config-spec/blob/master/versions/2.2.0/README.md#releasecommitmessageformat-string">Conventional Changelog Configuration Spec (v2.1.0)</a></li><li><a href="https://github.com/yargs/yargs/blob/main/docs/api.md">yargs api</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>工程化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>源码分析</tag>
      
      <tag>standard-version</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nestjs开发及流水线相关问题记录</title>
    <link href="/2023/04/20/2023-04-20-server-via-nestjs-summary/"/>
    <url>/2023/04/20/2023-04-20-server-via-nestjs-summary/</url>
    
    <content type="html"><![CDATA[<h1 id="背景"><a class="markdownIt-Anchor" href="#背景"></a> 背景</h1><p>前段时间负责将组内项目接入自动化流水线, 磕磕绊绊最后也算把全流程走通并且在线上稳定运行了, 把过程中遇到到的问题和知识点作用做个记录总结.</p><h1 id="nestjs"><a class="markdownIt-Anchor" href="#nestjs"></a> nestjs</h1><p>这里不会介绍 controller, provider 是啥, 应该怎么使用, 这些直接看官方文档就能理解了, 只会记录使用 nestjs 中的问题的解决过程, 官方文档模棱两可的描述以及底层原理的思考.</p><h2 id="1-eslint-wrong-error-is-defined-but-never-used"><a class="markdownIt-Anchor" href="#1-eslint-wrong-error-is-defined-but-never-used"></a> 1. eslint wrong error “is defined but never used”</h2><p>初始化项目时遇到 import 所有装饰器例如<code>@Injectable()</code>, <code>@Get()</code>, 并且在对应文件中使用了, eslint 还是会提示**“is defined but never used”**.<br />需要把<code>@typescript-eslint/*</code>包升级到 5.35.1 以上</p><h2 id="2-及时更新nestjscli-脚手架"><a class="markdownIt-Anchor" href="#2-及时更新nestjscli-脚手架"></a> 2. 及时更新@nestjs/cli 脚手架</h2><p>使用脚手架初始化项目时, 当引入第三方 Module 时出现了各种各样的问题, 最后发现脚手架<code>@nestjs/cli</code>之前安装的版本是 v7, 而现在最新大版本已经迭代到 v9 了, 很多第三方库版本都已经不兼容旧的脚手架新建的项目, 升级到 v9 后重新初始化项目第三方 Module 引入问题消失.</p><h2 id="3-cachemodule"><a class="markdownIt-Anchor" href="#3-cachemodule"></a> 3. CacheModule</h2><p>这里项目中使用的是 redis, 以此为例:<br />在不同模块中引入 CacheModule 的方式:</p><ol><li>app.module.ts 中设置<code>isGlobal: true</code></li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-title class_">CacheModule</span>.<span class="hljs-property">register</span>&lt;<span class="hljs-title class_">RedisClientOptions</span>&gt;(&#123;<br>  <span class="hljs-attr">isGlobal</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">store</span>: redisStore,<br>  ...config.<span class="hljs-property">redis</span>,<br>&#125;);<br></code></pre></td></tr></table></figure><ol start="2"><li>在每个 module 中单独引入, 参数都要带上, 否则会使用默认的内存缓存.</li></ol><h2 id="4-forroutes"><a class="markdownIt-Anchor" href="#4-forroutes"></a> 4. forRoutes</h2><p>指定中间件作用路由时, 不需要加上设置的 prefixPath, 如果想作用路由下所有接口使用<code>/*</code></p><h1 id="linux"><a class="markdownIt-Anchor" href="#linux"></a> linux</h1><p>流水线中难免会有频繁的 linux 操作, 记录用到的命令</p><h2 id="rsync"><a class="markdownIt-Anchor" href="#rsync"></a> rsync</h2><p>同步文件, 和<code>cp</code>类似, 但是可以通过参数过滤不复制的文件.<br />常用的参数:</p><p><code>-a, --archive</code>: 归档模式，表示以递归方式传输文件，并保持所有文件属性<br /><code>--exclude-from</code>: 这是选择<code>rsync</code>而不是<code>cp</code>的最大原因, 该配置能够在复制文件时指定过滤的文件.<br /><code>--exclude</code>: 指定排除不需要传输的文件模式, 例如<code>--exclude=exclude.list</code>, 就可以在目录下创建 exclude.list, 内容为过滤的文件模式, 例如:</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">log/<br>Dockerfile<br><span class="hljs-string">.eslintrc.js</span><br><span class="hljs-string">.gitignore</span><br><span class="hljs-string">.prettierrc</span><br>*<span class="hljs-string">.log</span><br></code></pre></td></tr></table></figure><h1 id="redis"><a class="markdownIt-Anchor" href="#redis"></a> redis</h1><p>常用命令:</p><ol><li><code>flushdb</code>: 删除 db 中所有数据</li><li><code>ttl key</code>: 剩余过期时间</li><li><code>get key</code>: 查询 key 值</li><li>redis 的值如果是 number, 会显示类似&quot;1234&quot;; 如果是 string, 会显示&quot;\“1234\”&quot;</li><li>redis connect refuse 解决方法:<br />redis.conf 中将 protect mode yes 改为 no<br />bind 127.0.0.1 注释#</li></ol><h1 id="docker"><a class="markdownIt-Anchor" href="#docker"></a> docker</h1><p>常用命令:</p><ol><li><code>docker run -dit --rm imageId bash</code>: 创建容器并在容器启动 bash 交互, 退出后自动删除容器</li><li><code>docker run -dit imageId</code>: 创建容器</li><li><code>docker exec -it id bash</code>: 在运行的容器中启动 bash 与其交互</li><li><code>docker history imageId</code>: 通过镜像 id 查看上层 layer 的 Dockerfile</li><li><code>docker logs containerId</code>: 输出容器日志</li><li><code>docker run -d -p 127.0.0.1:80:80 nginx:alpine</code> 运行时指定端口映射, 需要注意的是 Dockerfile 中的<strong>EXPOSE</strong>关键字只是描述端口号, 没有实际作用</li><li><code>docker build -t v0.0.1 --ulimit nofile=100002:100002 packages/wework-bot</code>: 可以指定上下文, 如果在 Dockerfile 中配置<strong>COPY . .</strong> 会将 packages/wework-bot 内容全部复制到容器的<strong>WORKSPACE</strong>下</li></ol><h1 id="git"><a class="markdownIt-Anchor" href="#git"></a> git</h1><ol><li><code>git rev-parse HEAD</code>: 最近的一次 commit id</li><li><code>git merge --no-edit</code>: 不触发交互修改信息, 用于代码中调用</li><li><code>git revert commitId</code>: 回退指定 commit, 新增一条 commit 记录, 比如想回退 HEAD 最新提交, 则<code>git revert HEAD</code>, 操作是可逆的.</li><li><code>git reset commitId</code>: 回退指定 commit, 清除 commit 之后所有记录, 比如想回退 HEAD 最新提交, 则<code>git reset --hard HEAD^</code>, 操作不可逆.</li><li><code>git pull --rebase</code>: pull 默认会生成一条 merge 记录, --rebase 指定不生成 merge 记录</li></ol><h1 id="其他"><a class="markdownIt-Anchor" href="#其他"></a> 其他</h1><h2 id="pm2"><a class="markdownIt-Anchor" href="#pm2"></a> pm2</h2><p>由于服务部署在线上环境的 docker 中, <code>pm2 start</code>不支持容器中启动, 这就导致 Dockerfile 中逻辑执行完容器直接 Exit. 官方提供<code>pm2-runtime</code>用于 docker 场景, 运行服务命令<code>pm2-runtime start ecosystem.config.js</code>, 和 pm2 不同, pm2-runtime 不支持 restart.</p><h2 id="多环境-git"><a class="markdownIt-Anchor" href="#多环境-git"></a> 多环境 git</h2><p>由于日常都是在内网的 linux 开发机上办公(通过 vscode ssh-remote), ssh 的内容就涉及到了多环境, 包括本地与开发机连接, 内网 git 操作, github 操作, 参考这篇文章: <a href="https://www.zhihu.com/question/21402411">多环境 git 配置</a></p><h2 id="xml-请求体"><a class="markdownIt-Anchor" href="#xml-请求体"></a> xml 请求体</h2><p>body-parser 只支持处理 Content-Type 为 <code>application/x-www-form-urlencoded</code>, <code>multiple/form-data</code>, <code>application/json</code>的请求体; 微信客服号这种请求体是 xml 格式的 body-parser 处理不了, req.body 输出也是{}.<br />需要结合<strong>body-parser-xml</strong>库对 body-parser 做封装:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> bodyParser <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;body-parser&quot;</span>;<br><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> bodyParserXml <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;body-parser-xml&quot;</span>;<br><br><span class="hljs-title function_">bodyParserXml</span>(bodyParser);<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">XmlMiddleware</span> = bodyParser.<span class="hljs-title function_">xml</span>(&#123;<br>  <span class="hljs-attr">xmlParseOptions</span>: &#123;<br>    <span class="hljs-attr">explicitArray</span>: <span class="hljs-literal">false</span>,<br>  &#125;,<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="formdata"><a class="markdownIt-Anchor" href="#formdata"></a> formData</h2><p>在 node 中 formData 的使用和浏览器中一致, 当 formData append 的值是文件可读流时, 文件的基本属性就会丢失, MIME 变成<strong>oct-stream</strong>, filename 变成一串 MD5 码, 可以通过 options 中配置指定文件基础信息</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript">formData.<span class="hljs-title function_">append</span>(<span class="hljs-string">&#x27;file&#x27;</span>, &lt;可读流&gt;, &#123; <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;dist.zip&#x27;</span> &#125;);<br></code></pre></td></tr></table></figure><h2 id="centos7"><a class="markdownIt-Anchor" href="#centos7"></a> centos7</h2><ol><li><a href="https://ximouzhao.com/index.php/2022/06/17/centos7%e5%ae%89%e8%a3%85%e6%9c%80%e6%96%b0%e7%89%88%e6%9c%acgit/">centos7 安装最新版本的 git(不用手动编译)</a></li><li>yum 源的目录: /etc/yum.repos.d/</li><li>Transaction check error: 安装包冲突 <code>rpm -e 冲突包名 --nodeps</code></li></ol><h1 id="reference"><a class="markdownIt-Anchor" href="#reference"></a> reference</h1><ol><li><a href="https://stackoverflow.com/questions/73591752/eslint-error-is-defined-but-never-used-warning-in-nestjs-for-all-decorators">Eslint error <code>is defined but never used</code> warning in NestJs for all decorators</a></li><li><a href="https://stackoverflow.com/questions/53862615/how-to-merge-into-branch-without-commit">how to merge into branch without commit</a></li><li><a href="https://stackoverflow.com/questions/53962776/whats-the-difference-between-pm2-and-pm2-runtime">https://stackoverflow.com/questions/53962776/whats-the-difference-between-pm2-and-pm2-runtime</a></li><li><a href="https://pm2.keymetrics.io/docs/usage/docker-pm2-nodejs/">https://pm2.keymetrics.io/docs/usage/docker-pm2-nodejs/</a></li><li><a href="https://www.zhihu.com/question/21402411">多环境 git 配置</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>nestjs</tag>
      
      <tag>nodejs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端工作日常问题和易忘点记录</title>
    <link href="/2022/11/24/2022-11-24-daily-record-from-oct-to-dec/"/>
    <url>/2022/11/24/2022-11-24-daily-record-from-oct-to-dec/</url>
    
    <content type="html"><![CDATA[<h1 id="背景"><a class="markdownIt-Anchor" href="#背景"></a> 背景</h1><p>记录下日常遇到的问题和简便操作</p><h1 id="学到了"><a class="markdownIt-Anchor" href="#学到了"></a> 学到了</h1><h2 id="1-ant-design-中的图标应用"><a class="markdownIt-Anchor" href="#1-ant-design-中的图标应用"></a> 1. ant-design 中的图标应用</h2><p><strong>@ant-design/icons-vue</strong>提供了很多<a href="https://2x.antdv.com/components/icon/#Icon">图标组件</a><br />在 vue 组件中使用可以直接通过:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">StepBackwardOutlined</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@ant-design/icons-vue&quot;</span>;<br><br><span class="hljs-comment">// 使用</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">StepBackwardOutlined</span> /&gt;</span></span>;<br></code></pre></td></tr></table></figure><p>但在某些情况下, 比如菜单组件, 侧边栏组件, 想要直接通过<code>className</code>来获取图标就可以参考文档中<strong>Custom Font Icon</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; createFromIconfontCN &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@ant-design/icons-vue&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; defineComponent &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">MyIcon</span> = <span class="hljs-title function_">createFromIconfontCN</span>(&#123;<br><span class="hljs-attr">scriptUrl</span>: <span class="hljs-string">&#x27;//at.alicdn.com/t/font_8d5l8fzk5b87iudi.js&#x27;</span>, <span class="hljs-comment">// generated by iconfont.cn</span><br>&#125;);<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineComponent</span>(&#123;<br><span class="hljs-attr">props</span>: &#123;<br><span class="hljs-attr">className</span>: <span class="hljs-title class_">String</span>,<br>&#125;;<br><span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">MyIcon</span> <span class="hljs-attr">:type</span>=<span class="hljs-string">&quot;className&quot;</span> /&gt;</span></span>;<br>&#125;,<br>&#125;);<br></code></pre></td></tr></table></figure><p>官方提供了这样的组件, 其中<code>type</code>属性即类名. <strong>createFromIconfontCN</strong>的<code>scriptUrl</code>参数可以在<a href="https://www.iconfont.cn/">iconfont.cn</a>sh 获取自定义的 js 链接.<br />也可以不传入<code>scriptUrl</code>, 直接在入口 html 文件中全局引入, 在博主项目中便是这样设置的.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> <span class="hljs-title class_">MyIcon</span> = <span class="hljs-title function_">createFromIconfontCN</span>(&#123;<br>  <span class="hljs-attr">scriptUrl</span>: <span class="hljs-string">&quot;&quot;</span>,<br>&#125;);<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;&lt;%= BASE_URL %&gt;iconfont.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>根据路由生成简单菜单栏的简单路由示例, 其中通过设置<strong>meta</strong>的<code>icon</code>属性作为图标的<code>className</code>:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">RouteRecordRaw</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue-router&quot;</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-attr">ROUTES</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">RouteRecordRaw</span>&gt; = [<br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/content/management&quot;</span>,<br>    <span class="hljs-attr">name</span>: routeName,<br>    <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span><br>      <span class="hljs-title function_">import</span>(<br>        <span class="hljs-comment">/* webpackMode: &quot;lazy&quot; */</span> <span class="hljs-comment">/* webpackPrefetch: true */</span> <span class="hljs-comment">/* webpackChunkName: &quot;prom-material&quot; */</span> <span class="hljs-string">&quot;@/views/list.vue&quot;</span><br>      ),<br>    <span class="hljs-attr">meta</span>: &#123;<br>      <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;标题&quot;</span>,<br>      <span class="hljs-attr">icon</span>: <span class="hljs-string">&quot;icon-folder-fill&quot;</span>,<br>    &#125;,<br>  &#125;,<br>];<br></code></pre></td></tr></table></figure><h2 id="2-部署-vue-项目后对-nginx-的进一步了解"><a class="markdownIt-Anchor" href="#2-部署-vue-项目后对-nginx-的进一步了解"></a> 2. 部署 vue 项目后对 nginx 的进一步了解</h2><p>首先需要搞清楚<strong>nginx</strong>中的<code>root</code>和<code>alias</code>, 区别在于:</p><ol><li>对于<strong>location</strong>后面的 uri 的解析<br /><code>root</code>的处理结果为 root 路径+请求的 uri 路径<br /><code>alias</code>的处理结果为 alias 路径覆盖 location 路径+请求 uri 剩余的路径</li><li><code>alias</code>结尾必须要带上<code>/</code>, <code>root</code>结尾则可有可无.</li></ol><p>对于以下 nginx 配置:</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">location</span> /editor/ &#123;<br><span class="hljs-attribute">root</span> /www/data/dist/;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果请求 URI 为<code>/editor/abc</code>, 最终 nginx 查找的路径为<code>/www/data/dist/editor/abc</code>.</p><p>对于以下 nginx 配置:</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">location</span> /editor/ &#123;<br><span class="hljs-attribute">alias</span> /www/data/dist/;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果请求 URI 为<code>/editor/abc</code>, 最终 nginx 查找的路径为<code>/www/data/dist/abc</code>.</p><p>nginx 中的<code>index</code>, nginx 在上述的种种路径中没找到对应的文件, 默认情况下会在后面加上个<code>/index</code>继续找<code>/www/data/dist/abc/index</code>, 可以通过配置<code>index</code>告诉 nginx index 的含义.</p><p>对于以下 nginx 配置:</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">location</span> /editor/ &#123;<br><span class="hljs-attribute">alias</span> /www/data/dist/;<br><span class="hljs-attribute">index</span> index.html index.shtml;<br>&#125;<br></code></pre></td></tr></table></figure><p>请求 uri 为<code>/editor/abc</code>, nginx 在<code>/www/data/dist/abc</code>路径找不到文件时, 会继续找<code>/www/data/dist/abc/index.html</code>及<code>/www/data/dist/abc/index.shtml</code>, 还是找不到则返回<strong>404</strong>.</p><p>nginx 中的<code>autoindex</code>, 是否允许查看文件夹, 默认是<code>off</code>.</p><p>对于以下 nginx 配置:</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">location</span> /editor/ &#123;<br><span class="hljs-attribute">alias</span> /www/data/dist/;<br><span class="hljs-attribute">autoindex</span> <span class="hljs-literal">on</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>请求 uri 为<code>/editor/abc</code>, nginx 如果发现<code>/www/data/dist/abc</code>是个文件夹, 浏览器会返回目录结构类似下图:</p><p><img src="https://dev.azure.com/HealMSlin/8544be09-1224-4eb0-824b-90c4ec9d49ee/_apis/git/repositories/7a27a721-4c93-4ecf-8258-d5422217b60a/items?path=%2F1669723364169_608.png&amp;versionDescriptor%5BversionOptions%5D=0&amp;versionDescriptor%5BversionType%5D=0&amp;versionDescriptor%5Bversion%5D=master&amp;resolveLfs=true&amp;%24format=octetStream&amp;api-version=5.0" alt="" /></p><p>最后就是记录使用<strong>history</strong>模式 vue-router 的 vue 项目<code>npm run build</code>后的构建产物发布到线上机器后的 nginx 配置.<br />首先我们知道默认情况下 vue 是 SPA 单页面应用, 其中的路由跳转都是通过 H5 提供的<code>history.pushState()</code>进行跳转. 假设构建产物现在发布在<code>/www/data/dist</code>目录, 目录结构:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus">dist<br>├── css<br>├── favicon<span class="hljs-selector-class">.ico</span><br>├── iconfont<span class="hljs-selector-class">.js</span><br>├── <span class="hljs-selector-tag">img</span><br>├── index<span class="hljs-selector-class">.html</span><br>└── js<br></code></pre></td></tr></table></figure><p>对于以下路由:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> <span class="hljs-attr">ROUTES</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">RouteRecordRaw</span>&gt; = [<br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/dashboard/list&quot;</span>,<br>    <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">import</span>(<span class="hljs-string">&quot;&quot;</span>),<br>  &#125;,<br>];<br><br><span class="hljs-keyword">const</span> router = <span class="hljs-title function_">createRouter</span>(&#123;<br>  <span class="hljs-attr">history</span>: <span class="hljs-title function_">createWebHistory</span>(),<br>  <span class="hljs-attr">routes</span>: <span class="hljs-variable constant_">ROUTES</span>,<br>&#125;);<br></code></pre></td></tr></table></figure><p>如果是根路径下的 nginx 配置, 网上都是教你这么配的:</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">location</span> / &#123;<br><span class="hljs-attribute">alias</span> /www/data/dist/;<br><span class="hljs-attribute">try_files</span> <span class="hljs-variable">$uri</span>/ /index.html;<br>&#125;<br></code></pre></td></tr></table></figure><p>请求 uri 为<code>/dashboard/list</code>, 我曾经以为的 nginx 解析逻辑是:</p><ol><li>匹配到<code>/</code>, 查找<code>/www/data/dist/dashboard/list</code></li><li>没找到对应文件, 后面加上<code>/index</code>找, 还是没找着</li><li>通过<strong>try_file</strong>一次查找<code>/www/data/dist/</code>, <code>/www/data/dist/index.html</code></li><li>找到对应文件返回给浏览器</li><li>浏览器通过 html 引入的 js 中的路由规则跳转到<code>/dashboard/list</code></li></ol><p>于是在新项目以下路由也使用用了对应 nginx 配置:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> router = <span class="hljs-title function_">createRouter</span>(&#123;<br>  <span class="hljs-attr">history</span>: <span class="hljs-title function_">createWebHistory</span>(<span class="hljs-string">&quot;/editor&quot;</span>),<br>  <span class="hljs-attr">routes</span>: <span class="hljs-variable constant_">ROUTES</span>,<br>&#125;);<br></code></pre></td></tr></table></figure><p>非跟路径的 nginx 配置:</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">location</span> /editor/ &#123;<br><span class="hljs-attribute">alias</span> /www/data/dist/;<br><span class="hljs-attribute">try_files</span> <span class="hljs-variable">$uri</span>/ /index.html;<br>&#125;<br></code></pre></td></tr></table></figure><p>事实是这样配置直接访问 uri 为<code>/editor/dashboard/list</code>时会返回<strong>404</strong>, 原因是 nginx 的<code>try_file</code>属性的 N 个值中, 前面 N-1 个值的搜索逻辑和上述第 3 点一致, 但是对于第 N 个值, nginx 会进行<strong>内部重定向</strong>, 例子中即会对<code>/index.html</code>重新进行匹配, 但是并没有对<strong>location / {}</strong> 的配置, 所以得到 404 结果.</p><p>正确的 nginx 配置类似:</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs diff">location /editor/ &#123;<br>alias /www/data/dist/;<br><span class="hljs-deletion">-   try_files $uri/ /index.html;</span><br><span class="hljs-addition">+   try_files $uri/ /editor/index.html;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>根据上面的分析, 我们知道 nginx 的<code>try_files</code>对<code>/editor/index.html</code>内部重定向, 重新匹配<strong>location /editor/ {}</strong> 拿到<strong>index.html</strong>, 返回给浏览器, 通过 vue-router 正常路由跳转.</p><p>查找 StackOverflow 时发现一种写法, 也是好使的, 不清楚内部原因, 希望有了解的同学能解释一下</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">location</span> /editor/ &#123;<br><span class="hljs-attribute">alias</span> /www/data/dist/;<br><span class="hljs-attribute">try_files</span> <span class="hljs-variable">$uri</span>/ /index.html <span class="hljs-literal">last</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-tar-命令"><a class="markdownIt-Anchor" href="#3-tar-命令"></a> 3. tar 命令</h2><ul><li>项目发布上线需要编写打包的 shell 脚本给容器执行, 发现了个 tar 的参数<code>--remove-files</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar --zcvf node_modules.tar.gz node_modules --remove-files<br></code></pre></td></tr></table></figure><p>会在压缩成 tar.gz 包后将源文件夹删除, 就不用使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar --zcvf node_modules.tar.gz node_modules<br><span class="hljs-built_in">rm</span> -rf xxx<br></code></pre></td></tr></table></figure><ul><li>运行以下解压命令时报错 tar: write err</li><li></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tar -zxvf node_module.tar.gz node_modules<br></code></pre></td></tr></table></figure><p>tar 中<code>-v</code>是输出打包内容, 如果内容过长, 在某些机器上会报 tar: write err, 所以建议不加上这个参数</p><h2 id="4-du-sh"><a class="markdownIt-Anchor" href="#4-du-sh"></a> 4. du -sh</h2><p><code>ls -lh</code> 可以显示当前文件夹下各文件大小, 但是显示文件夹大小并没有包含文件夹内部文件大小<br /><code>du -sh</code>用于显示文件夹及内部文件的总大小<br /><code>-s</code>只显示当前文件夹大小, 不显示文件夹内部文件夹大小;<br /><code>-h</code>以 <strong>K</strong>, <strong>M</strong>, <strong>G</strong> 这类容易理解的单位显示大小</p><h2 id="5-multiple-commit-message-in-windows"><a class="markdownIt-Anchor" href="#5-multiple-commit-message-in-windows"></a> 5. multiple commit message in windows</h2><p>windows 系统下默认不支持以下方式 commit 多行信息:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs node">execSync(`git commit -m &quot;$&#123;commitMessage&#125;&quot;`);<br></code></pre></td></tr></table></figure><p><code>commitMessage</code>如果为多行, linux/macos 下能够正常执行, windows 下会将除第一行外内容截断.</p><p>但是经过测试所有系统下都支持一下方式 commit 多行信息, <code>commitMessage</code>为单行信息:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs node">execSync(`git commit -m &quot;$&#123;commitMessage&#125;&quot; -m &quot;$&#123;commitMessage&#125;&quot;`);<br></code></pre></td></tr></table></figure><p>上述的<code>&quot;$&#123;commitMessage&#125;&quot;</code>两边必须加上 quote.</p><h2 id="6-env"><a class="markdownIt-Anchor" href="#6-env"></a> 6. .env</h2><p>npm 库<strong>dot-env</strong>支持在本地配置<code>.env</code>文件, 并将键值挂载到<code>process.env</code>上, 但是对于某些符号字符, 默认会被截断导致读取配置时出错.<br />例如以下配置:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">NODE_CONFIG_DIR</span>=./env<br><span class="hljs-attr">NODE_ENV</span>=development<br><span class="hljs-attr">SIGN</span>=P2E<span class="hljs-comment">#xWehFZc</span><br></code></pre></td></tr></table></figure><p>读取<strong>SIGN</strong>时会将#后面的阶段, 导致<strong>SIGN</strong>的值变为<code>P2</code>, 这种情况在两边加上 quote 即可解决:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">SIGN</span>=<span class="hljs-string">&#x27;P2E#xWehFZc&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="iframe"><a class="markdownIt-Anchor" href="#iframe"></a> iframe</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 父页面 -&gt; 子页面, iframe为iframe DOM节点</span><br>iframe.<span class="hljs-property">contentWindow</span>.<span class="hljs-title function_">postMessage</span>(data, &#123;&#125;);<br><span class="hljs-comment">// 子页面 -&gt; 父页面</span><br><span class="hljs-variable language_">window</span>.<span class="hljs-property">parent</span>.<span class="hljs-title function_">postMessage</span>(data, &#123;&#125;);<br></code></pre></td></tr></table></figure><h1 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h1><h2 id="1-cannot-find-module-pm2libprocesscontainerforkjs"><a class="markdownIt-Anchor" href="#1-cannot-find-module-pm2libprocesscontainerforkjs"></a> 1. cannot find module pm2/lib/ProcessContainerFork.js</h2><p><code>rm -rf ~/.pm2</code></p><h2 id="2-浏览器-img-请求图片时-403"><a class="markdownIt-Anchor" href="#2-浏览器-img-请求图片时-403"></a> 2. 浏览器 img 请求图片时 403</h2><p>html 文件<code>&lt;head&gt;</code>加上<code>&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;</code>, 因为某些服务器会检测请求头的<strong>referer</strong>, 所以需要设置请求时不带上<strong>referer</strong>.</p><h2 id="3-less-不支持-additionaldata"><a class="markdownIt-Anchor" href="#3-less-不支持-additionaldata"></a> 3. <strong>less</strong> 不支持 <code>additionalData</code></h2><p><strong>less</strong> v4, <strong>less-loader</strong> v11 不支持<code>additionalData</code>, <strong>less</strong> v5, <strong>less-loader</strong> v12 之后新增 breaking change, 才支持<code>additionalData</code>, 才可以像<strong>sass-loader</strong>一样在 css 文件开头插入字符串.<br />vue.config.js 中配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-attr">css</span>: &#123;<br>    <span class="hljs-attr">loaderOptions</span>: &#123;<br>      <span class="hljs-attr">less</span>: &#123;<br>        <span class="hljs-attr">addtionalData</span>: <span class="hljs-string">`@import &#x27;@/style/global.less&#x27;`</span>,<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="reference"><a class="markdownIt-Anchor" href="#reference"></a> reference</h1><ol><li><a href="https://www.cnblogs.com/fengff/p/12015858.html">nginx 的 location、root、alias 指令用法和区别</a></li><li><a href="https://stackoverflow.com/questions/49072584/vue-router-nginx-and-direct-link">vue-router, nginx and direct link</a></li><li><a href="https://blog.51cto.com/u_10546390/1754757">Nginx 的 try_files 参数保证能懂的讲解</a></li><li><a href="https://github.com/Unitech/pm2/issues/1943">cannot find module pm2/lib/ProcessContainerFork.js</a></li><li><a href="https://stackoverflow.com/questions/15075783/add-line-break-to-git-commit-m-from-command-line-on-windows">Add line break to git commit -m from command line on Windows</a></li><li><a href="https://stackoverflow.com/questions/55703950/export-env-with-special-characters">Export .env with special characters</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>工作</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工作</tag>
      
      <tag>问题记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webpack学习笔记(10)</title>
    <link href="/2022/10/23/2022-10-23-study-webpack-day10/"/>
    <url>/2022/10/23/2022-10-23-study-webpack-day10/</url>
    
    <content type="html"><![CDATA[<h1 id="学习笔记"><a class="markdownIt-Anchor" href="#学习笔记"></a> 学习笔记</h1><h2 id="tree-shaking"><a class="markdownIt-Anchor" href="#tree-shaking"></a> Tree shaking</h2><p>tree shaking 在计算机中表示消除死代码(dead code).<br />JavaScript 的 Tree shaking 源自于 rollup, 依赖 ES Module 的静态语法分析.<br />webpack4 正式扩展了这个能力, 分为<code>usedExports</code>和<code>sideEffects</code>两种:</p><h3 id="usedexports"><a class="markdownIt-Anchor" href="#usedexports"></a> usedExports</h3><p><code>optimization.usedExports</code>, <strong>production</strong>模式下默认为 true. 该配置会配合<strong>TerserPlugin</strong>使用, 方便演示, 以下默认<code>mode</code>为<strong>development</strong>.</p><p>示例入口文件:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; sum &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./math&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sum);<br></code></pre></td></tr></table></figure><p>模块文件:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">num1, num2</span>) &#123;<br>  <span class="hljs-keyword">return</span> num1 + num2;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">mul</span>(<span class="hljs-params">num1, num2</span>) &#123;<br>  <span class="hljs-keyword">return</span> num1 * num2;<br>&#125;<br></code></pre></td></tr></table></figure><p>先开启<code>optimization.usedExports</code>, 关闭<strong>TerserPlugin</strong>插件, 查看打包产物:</p><p><img src="https://dev.azure.com/HealMSlin/8544be09-1224-4eb0-824b-90c4ec9d49ee/_apis/git/repositories/7a27a721-4c93-4ecf-8258-d5422217b60a/items?path=%2F1665914627139_3858.png&amp;versionDescriptor%5BversionOptions%5D=0&amp;versionDescriptor%5BversionType%5D=0&amp;versionDescriptor%5Bversion%5D=master&amp;resolveLfs=true&amp;%24format=octetStream&amp;api-version=5.0" alt="" /></p><p>可以看到对于没有引用的函数, <code>usedExports</code>会在上方标明注释, 提供给<strong>TerserPlugin</strong>进行加工删除.</p><p>现在开启<strong>TerserPlugin</strong>插件, 查看打包产物:</p><p><img src="https://dev.azure.com/HealMSlin/8544be09-1224-4eb0-824b-90c4ec9d49ee/_apis/git/repositories/7a27a721-4c93-4ecf-8258-d5422217b60a/items?path=%2F1665914691599_6111.png&amp;versionDescriptor%5BversionOptions%5D=0&amp;versionDescriptor%5BversionType%5D=0&amp;versionDescriptor%5Bversion%5D=master&amp;resolveLfs=true&amp;%24format=octetStream&amp;api-version=5.0" alt="" /></p><p>会发现打包产物中<strong>mul</strong>函数没有被打包进去.</p><p>此时如果再将作用域提升<strong>webpack.optimize.ModuleConcatenationPlugin</strong>插件打开, 打包产物就会只显示 sum 函数, 连引入标识, IIFE 等信息一并删除, 就想上一篇末尾提到的那样.</p><p><img src="https://dev.azure.com/HealMSlin/8544be09-1224-4eb0-824b-90c4ec9d49ee/_apis/git/repositories/7a27a721-4c93-4ecf-8258-d5422217b60a/items?path=%2F1665914791948_4934.png&amp;versionDescriptor%5BversionOptions%5D=0&amp;versionDescriptor%5BversionType%5D=0&amp;versionDescriptor%5Bversion%5D=master&amp;resolveLfs=true&amp;%24format=octetStream&amp;api-version=5.0" alt="" /></p><h3 id="sideeffects"><a class="markdownIt-Anchor" href="#sideeffects"></a> sideEffects</h3><p><code>sideEffects</code>主要用于第三方库文件, 在 npm 包的<strong>package.json</strong>中配置<strong>sideEffects</strong>, 用于告知 webpack compiler 哪些模块是有副作用的.</p><p>什么是<strong>副作用</strong>? 即模块内可能存在影响到全局环境的逻辑; 比如说某个模块并不是只含有纯函数, 而是存在</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">window</span>.<span class="hljs-property">app</span> = <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure><p>这样的逻辑, 这就表示该模块是有副作用的, 随意删除模块代码可能会影响运行.<br />所以<code>sideEffects</code>默认为 true. 也就是默认情况下, 直接使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;./math&quot;</span>;<br></code></pre></td></tr></table></figure><p>webpack 是不会将 math 模块的代码删除的.<br />可以配置数组, 指定模块中那些文件是含有副作用的; 当然推荐编写不含有副作用的模块, 但是对于 css 文件而言, 一定是有副作用的, 所以如果项目中引入了模块中的 css 文件, 有以下两种解决方式:</p><ol><li><code>sideEffects</code>中添加 css 文件, 如<code>&quot;sideEffects&quot;: [&quot;**/*.css&quot;]</code></li><li>在<code>module.rules</code>对处理 css 文件时配置<code>sideEffects</code></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.css$/i</span>,<br>  <span class="hljs-attr">use</span>: [<span class="hljs-string">&#x27;style-loader&#x27;</span>, <span class="hljs-string">&#x27;css-loader&#x27;</span>],<br>  <span class="hljs-attr">sideEffects</span>: <span class="hljs-literal">true</span>,<br>&#125;<br></code></pre></td></tr></table></figure><p>下面也举个简单例子, 本地创建个 npm 包, 包含两个文件:</p><p><strong>index.js</strong>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">window</span>.<span class="hljs-property">app</span> = <span class="hljs-string">&quot;abc&quot;</span>;<br></code></pre></td></tr></table></figure><p><strong>style.css</strong>:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;<br>  <span class="hljs-attribute">color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过<code>yarn link</code>在 demo 中引入, demo 入口文件添加以下代码:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;webpack-npm/lib/style.css&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;webpack-npm/lib/index.js&quot;</span>;<br><br><span class="hljs-keyword">const</span> element = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;div&quot;</span>);<br>element.<span class="hljs-property">innerHTML</span> = <span class="hljs-variable language_">window</span>.<span class="hljs-property">app</span>;<br><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">append</span>(element);<br></code></pre></td></tr></table></figure><p>现将 npm 包中<code>sideEffects</code>置为 false, 打包页面浏览器打开:</p><p><img src="https://dev.azure.com/HealMSlin/8544be09-1224-4eb0-824b-90c4ec9d49ee/_apis/git/repositories/7a27a721-4c93-4ecf-8258-d5422217b60a/items?path=%2F1666540416154_2096.png&amp;versionDescriptor%5BversionOptions%5D=0&amp;versionDescriptor%5BversionType%5D=0&amp;versionDescriptor%5Bversion%5D=master&amp;resolveLfs=true&amp;%24format=octetStream&amp;api-version=5.0" alt="" /></p><p>可以看到<strong>color</strong>样式没有生效, <strong>window.app</strong>也没有赋值.</p><p>然后将<code>sideEffects</code>配置为**[“**/*.css”]**或者配置<code>rules.sideEffects</code> 都可以; 打包页面打开浏览器:</p><p><img src="https://dev.azure.com/HealMSlin/8544be09-1224-4eb0-824b-90c4ec9d49ee/_apis/git/repositories/7a27a721-4c93-4ecf-8258-d5422217b60a/items?path=%2F1666540559057_9057.png&amp;versionDescriptor%5BversionOptions%5D=0&amp;versionDescriptor%5BversionType%5D=0&amp;versionDescriptor%5Bversion%5D=master&amp;resolveLfs=true&amp;%24format=octetStream&amp;api-version=5.0" alt="" /></p><p>说明 css 文件参与打包, js 文件被删除了.<br />最后将<code>sideEffects</code>置为 true, 可以看到有副作用的文件都参与打包.</p><p><img src="https://dev.azure.com/HealMSlin/8544be09-1224-4eb0-824b-90c4ec9d49ee/_apis/git/repositories/7a27a721-4c93-4ecf-8258-d5422217b60a/items?path=%2F1666540638739_5879.png&amp;versionDescriptor%5BversionOptions%5D=0&amp;versionDescriptor%5BversionType%5D=0&amp;versionDescriptor%5Bversion%5D=master&amp;resolveLfs=true&amp;%24format=octetStream&amp;api-version=5.0" alt="" /></p><p><strong>总结一下</strong><br />如何在生产环境对 JavaScript 代码进行 tree shaking 呢?</p><ol><li>设置<code>optimization.usedExports</code>为 true, 帮助<strong>TerserPlugin</strong>进行优化</li><li><strong>package.json</strong>中配置<code>sideEffects</code>, 直接对模块进行优化.</li></ol><h3 id="tree-shaking-in-css"><a class="markdownIt-Anchor" href="#tree-shaking-in-css"></a> Tree-shaking in Css</h3><p>早期 webpack 使用<strong>purifyCss</strong>插件对 css 文件进行 tree shaking, 但是该库已不再维护, 最新的提交也是 4 年前, 目前使用<strong>purgeCss</strong>来完成 css 的 tree shaking.</p><p>安装: <code>yarn add -D purgecss-webpack-plugin</code></p><p>如果想要正常使用<strong>purgeCss</strong>还需要安装<strong>mini-css-extract-plugin</strong>生成单独 css 文件插件, 如果之前没安装过也需要安装.</p><p>使用示例, <strong>purgeCss</strong>版本更新后需要解构引入:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;path&quot;</span>);<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">MiniCssExtractPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;mini-css-extract-plugin&quot;</span>);<br><span class="hljs-keyword">const</span> &#123; <span class="hljs-title class_">PurgeCSSPlugin</span> &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;purgecss-webpack-plugin&quot;</span>);<br><span class="hljs-keyword">const</span> glob = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;glob&quot;</span>);<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">HtmlWebpackPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;html-webpack-plugin&quot;</span>);<br><span class="hljs-keyword">const</span> &#123; <span class="hljs-title class_">CleanWebpackPlugin</span> &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;clean-webpack-plugin&quot;</span>);<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-comment">// mode: &#x27;production&#x27;,</span><br>  <span class="hljs-attr">entry</span>: <span class="hljs-string">&quot;./index.js&quot;</span>,<br>  <span class="hljs-attr">output</span>: &#123;<br>    <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&quot;./build&quot;</span>),<br>    <span class="hljs-attr">filename</span>: <span class="hljs-string">&quot;bundle.js&quot;</span>,<br>  &#125;,<br>  <span class="hljs-attr">module</span>: &#123;<br>    <span class="hljs-attr">rules</span>: [<br>      &#123;<br>        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.css$/i</span>,<br>        <span class="hljs-attr">use</span>: [<span class="hljs-title class_">MiniCssExtractPlugin</span>.<span class="hljs-property">loader</span>, <span class="hljs-string">&quot;css-loader&quot;</span>],<br>      &#125;,<br>    ],<br>  &#125;,<br>  <span class="hljs-attr">plugins</span>: [<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">CleanWebpackPlugin</span>(),<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>(&#123;<br>      <span class="hljs-attr">template</span>: <span class="hljs-string">&quot;./index.html&quot;</span>,<br>    &#125;),<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">MiniCssExtractPlugin</span>(&#123;<br>      <span class="hljs-attr">filename</span>: <span class="hljs-string">&quot;[name].css&quot;</span>,<br>    &#125;),<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">PurgeCSSPlugin</span>(&#123;<br>      <span class="hljs-attr">paths</span>: glob.<span class="hljs-title function_">sync</span>(<span class="hljs-string">&quot;./**/*&quot;</span>, &#123; <span class="hljs-attr">nodir</span>: <span class="hljs-literal">true</span> &#125;),<br>    &#125;),<br>  ],<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>purgeCss</strong>会识别 html 和 js 中用到的 class 或 className 等, 经测试:</p><ol><li>即使 js 中注释 className 逻辑, 打包产物仍然会存在对应类名</li><li>不会去除对 body, html 标签设置的 css</li><li>有可能会额外删除 代码中实际会用到的 css, 导致样式错乱(在博主 Vue 项目中有出现过)</li></ol><p>抛开上述问题, <strong>purgeCss</strong>打包效果是非常优秀的. 第三点可以通过配置<strong>safeList</strong>解决</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">collectSafelist</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">standard</span>: [<span class="hljs-string">&quot;safelisted&quot;</span>, <span class="hljs-regexp">/^safelisted-/</span>],<br>    <span class="hljs-attr">deep</span>: [<span class="hljs-regexp">/^safelisted-deep-/</span>],<br>    <span class="hljs-attr">greedy</span>: [<span class="hljs-regexp">/^safelisted-greedy/</span>],<br>  &#125;;<br>&#125;<br><br><span class="hljs-comment">// In the webpack configuration</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">PurgeCSSPlugin</span>(&#123;<br>  <span class="hljs-attr">safelist</span>: collectSafelist,<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="compress"><a class="markdownIt-Anchor" href="#compress"></a> Compress</h3><p>这个属于了解知识. 一般性能优化也不会到这种地步(笑)</p><h4 id="http-压缩"><a class="markdownIt-Anchor" href="#http-压缩"></a> Http 压缩</h4><p>如今绝大部分浏览器都已经支持 Http 压缩, 支持的浏览器在向服务器发送请求时, 会告知服务器自己支持哪些压缩格式, 例如<code>Accept: Encoding: gzip, deflate</code>, 服务器中如果存在浏览器支持压缩格式的压缩文件就会, 就会直接返回对应的压缩后文件, 并在响应头重告知浏览器, 例如<code>Content-Encoding: gzip</code>, 浏览器会完成解压操作, 无需我们关注.</p><p>webpack 中依赖<code>compression-webpack-plugin</code>插件来指定打包产物生成对应的压缩文件.</p><p>webpack 配置:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">CompressionPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;compression-webpack-plugin&quot;</span>);<br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-comment">//...</span><br>  <span class="hljs-attr">plugins</span>: [<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">CompressionPlugin</span>(&#123;<br>      <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.(css|js)$/i</span>, <span class="hljs-comment">// 指定需要压缩的文件类型</span><br>      <span class="hljs-attr">threshold</span>: <span class="hljs-number">0</span>, <span class="hljs-comment">// 需要压缩的文件大小阈值</span><br>      <span class="hljs-attr">algorithm</span>: <span class="hljs-string">&quot;gzip&quot;</span>, <span class="hljs-comment">// 压缩算法, 和Conten-Encoding对应</span><br>    &#125;),<br>  ],<br>&#125;;<br></code></pre></td></tr></table></figure><p>需要注意的是, threshold 即使设置的很小或 0, <strong>CompressionPlugin</strong>也不是会对所有匹配到的文件都进行压缩的, 插件内部设置了最小的阈值.<br />所以这里实例代码中引入了<strong>lodash</strong>包, 可以看到打包产物存在 js 和压缩后的 gz 文件</p><p><img src="https://dev.azure.com/HealMSlin/8544be09-1224-4eb0-824b-90c4ec9d49ee/_apis/git/repositories/7a27a721-4c93-4ecf-8258-d5422217b60a/items?path=%2F1668618792046_8806.png&amp;versionDescriptor%5BversionOptions%5D=0&amp;versionDescriptor%5BversionType%5D=0&amp;versionDescriptor%5Bversion%5D=master&amp;resolveLfs=true&amp;%24format=octetStream&amp;api-version=5.0" alt="" /></p><h4 id="html-压缩"><a class="markdownIt-Anchor" href="#html-压缩"></a> Html 压缩</h4><p><strong>html-webpack-plugin</strong>除了设置 html 模板同时默认也压缩了 html 代码, <code>minify: 'auto'</code>表示默认配置, 也可以自己配置.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>(&#123;<br>  <span class="hljs-attr">template</span>: <span class="hljs-string">&quot;./index.html&quot;</span>,<br>  <span class="hljs-attr">inject</span>: <span class="hljs-string">&quot;head&quot;</span>, <span class="hljs-comment">// 默认为head, 可设置boolean, head, body, true和head含义相同</span><br>  <span class="hljs-attr">cache</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">minify</span>: isProduction<br>    ? &#123;<br>        <span class="hljs-attr">removeComments</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 移除注释</span><br>        <span class="hljs-attr">resolveRedundantAttributes</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 移除多余属性</span><br>        <span class="hljs-attr">removeEmptyAttributes</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 移除空属性</span><br>        <span class="hljs-attr">collapseWhitespace</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 移除换行和空格</span><br>        <span class="hljs-attr">minifyCss</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 压缩内联样式表css</span><br>        <span class="hljs-attr">minifyJS</span>: &#123;<br>          <span class="hljs-comment">// 压缩内联js</span><br>          <span class="hljs-attr">mangle</span>: <span class="hljs-literal">true</span>,<br>        &#125;,<br>      &#125;<br>    : <span class="hljs-string">&quot;auto&quot;</span>,<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="inlinechunkhtmlplugin"><a class="markdownIt-Anchor" href="#inlinechunkhtmlplugin"></a> InlineChunkHtmlPlugin</h3><p>这是<strong>react-dev-utils</strong>提供的一个插件用于关联<strong>HtmlWebpackPlugin</strong>, 将匹配到的文件插入 html 文件内联 js 形式执行, 减少打包产物的文件数量.达到<strong>文件体积</strong>和<strong>Http 请求数</strong>的平衡.</p><p>安装: <code>yarn add -D react-dev-utils</code></p><p>配置, 这里以动态导入生成的 runtime 文件举例子, 将 runtime 逻辑 inline 到 html 中:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">HtmlWebpackPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;html-webpack-plugin&quot;</span>);<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">InlineChunkHtmlPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;react-dev-utils/InlineChunkHtmlPlugin&quot;</span>);<br><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;path&quot;</span>);<br><span class="hljs-keyword">const</span> &#123; <span class="hljs-title class_">CleanWebpackPlugin</span> &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;clean-webpack-plugin&quot;</span>);<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">entry</span>: <span class="hljs-string">&quot;./index.js&quot;</span>,<br>  <span class="hljs-attr">output</span>: &#123;<br>    <span class="hljs-attr">publicPath</span>: <span class="hljs-string">&quot;./&quot;</span>,<br>    <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&quot;./build&quot;</span>),<br>    <span class="hljs-attr">filename</span>: <span class="hljs-string">&quot;[name].[hash:6].bundle.js&quot;</span>,<br>  &#125;,<br>  <span class="hljs-attr">plugins</span>: [<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">CleanWebpackPlugin</span>(),<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>(),<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">InlineChunkHtmlPlugin</span>(<span class="hljs-title class_">HtmlWebpackPlugin</span>, [<span class="hljs-regexp">/runtime.*\.js/</span>]),<br>  ],<br>  <span class="hljs-attr">optimization</span>: &#123;<br>    <span class="hljs-attr">runtimeChunk</span>: <span class="hljs-literal">true</span>,<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p>可以看到 runtime 文件的代码被 inline 到 html 中了, 截取了部分代码, 完整例子可以查看示例代码 p4.</p><p><img src="https://dev.azure.com/HealMSlin/8544be09-1224-4eb0-824b-90c4ec9d49ee/_apis/git/repositories/7a27a721-4c93-4ecf-8258-d5422217b60a/items?path=%2F1668701277710_2858.png&amp;versionDescriptor%5BversionOptions%5D=0&amp;versionDescriptor%5BversionType%5D=0&amp;versionDescriptor%5Bversion%5D=master&amp;resolveLfs=true&amp;%24format=octetStream&amp;api-version=5.0" alt="" /></p><p>这里可能会有一个问题:</p><ol><li><strong>InlineChunkHtmlPlugin</strong>不会删除 inline 后的文件, 需要手动删除</li></ol><h3 id="npm-package-using-webpack"><a class="markdownIt-Anchor" href="#npm-package-using-webpack"></a> npm package using webpack</h3><p>webpack 同样可以用于打包代码作为第三方库文件, 只需要对添加少量配置. <s>虽然一般都是使用 rollup 打包</s></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">HtmlWebpackPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;html-webpack-plugin&quot;</span>);<br><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;path&quot;</span>);<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">entry</span>: <span class="hljs-string">&quot;./lib/index.js&quot;</span>,<br>  <span class="hljs-attr">output</span>: &#123;<br>    <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&quot;./dist&quot;</span>),<br>    <span class="hljs-attr">filename</span>: <span class="hljs-string">&quot;bundle.js&quot;</span>,<br>    <span class="hljs-attr">libraryTarget</span>: <span class="hljs-string">&quot;umd&quot;</span>,<br>    <span class="hljs-attr">library</span>: <span class="hljs-string">&quot;math&quot;</span>,<br>    <span class="hljs-attr">globalObject</span>: <span class="hljs-string">&quot;this&quot;</span>,<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p>可以看到只是对<strong>output</strong>增加了三个属性:</p><ul><li><strong>libraryTarget</strong>: 打包产物遵守哪种模块导入规则, 一般都是<code>umd</code>, 即<strong>universal module defination</strong>支持<code>esm | amd | cmd | commonjs</code>所有规则导入.</li><li><strong>library</strong>: 挂载在全局对象的对象名, 这里举例 math, 浏览器中就可通过<code>window.math</code>访问.</li><li><code>globalObject</code>: 一般都用<code>this</code>, this 默认根据不同环境表示不同的全局变量 window 或 global, 也可以设置成 document.</li></ul><p>这里简单将两个函数打包为 npm 包:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">num1, num2</span>) &#123;<br>  <span class="hljs-keyword">return</span> num1 + num2;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">minus</span>(<span class="hljs-params">num1, num2</span>) &#123;<br>  <span class="hljs-keyword">return</span> num1 - num2;<br>&#125;<br></code></pre></td></tr></table></figure><p>打包为 umd 文件后, 各种环境下不同规则引用的允许情况:</p><p>浏览器:<br /><img src="https://dev.azure.com/HealMSlin/8544be09-1224-4eb0-824b-90c4ec9d49ee/_apis/git/repositories/7a27a721-4c93-4ecf-8258-d5422217b60a/items?path=%2F1668872875364_7197.png&amp;versionDescriptor%5BversionOptions%5D=0&amp;versionDescriptor%5BversionType%5D=0&amp;versionDescriptor%5Bversion%5D=master&amp;resolveLfs=true&amp;%24format=octetStream&amp;api-version=5.0" alt="" /></p><p>commonjs:<br /><img src="https://dev.azure.com/HealMSlin/8544be09-1224-4eb0-824b-90c4ec9d49ee/_apis/git/repositories/7a27a721-4c93-4ecf-8258-d5422217b60a/items?path=%2F1668872961970_6136.png&amp;versionDescriptor%5BversionOptions%5D=0&amp;versionDescriptor%5BversionType%5D=0&amp;versionDescriptor%5Bversion%5D=master&amp;resolveLfs=true&amp;%24format=octetStream&amp;api-version=5.0" alt="" /></p><p>esm:<br /><img src="https://dev.azure.com/HealMSlin/8544be09-1224-4eb0-824b-90c4ec9d49ee/_apis/git/repositories/7a27a721-4c93-4ecf-8258-d5422217b60a/items?path=%2F1668873018807_3447.png&amp;versionDescriptor%5BversionOptions%5D=0&amp;versionDescriptor%5BversionType%5D=0&amp;versionDescriptor%5Bversion%5D=master&amp;resolveLfs=true&amp;%24format=octetStream&amp;api-version=5.0" alt="" /></p><p>可以看到都能够正常执行.</p><p>最后看下 umd 形式打包产物是如何适配不同模块导入规则的; 文件开头就能看到会通过判断不同模块规则中特有的标量如<code>module</code>, <code>define</code>等来判断是哪种导入规则, 从而将入口文件挂载到对应的对象上.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-keyword">function</span> (<span class="hljs-params">e, t</span>) &#123;<br>  <span class="hljs-string">&quot;object&quot;</span> == <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">exports</span> &amp;&amp; <span class="hljs-string">&quot;object&quot;</span> == <span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">module</span><br>    ? (<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title function_">t</span>())<br>    : <span class="hljs-string">&quot;function&quot;</span> == <span class="hljs-keyword">typeof</span> define &amp;&amp; define.<span class="hljs-property">amd</span><br>    ? <span class="hljs-title function_">define</span>([], t)<br>    : <span class="hljs-string">&quot;object&quot;</span> == <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">exports</span><br>    ? (<span class="hljs-built_in">exports</span>.<span class="hljs-property">math</span> = <span class="hljs-title function_">t</span>())<br>    : (e.<span class="hljs-property">math</span> = <span class="hljs-title function_">t</span>());<br>&#125;);<br></code></pre></td></tr></table></figure><h1 id="示例代码"><a class="markdownIt-Anchor" href="#示例代码"></a> 示例代码</h1><p><a href="https://github.com/Mariana-Yui/fe-learn-code/tree/main/learn-webpack/day10">https://github.com/Mariana-Yui/fe-learn-code/tree/main/learn-webpack/day10</a></p><h1 id="reference"><a class="markdownIt-Anchor" href="#reference"></a> reference</h1><ol><li><a href="https://purgecss.com/plugins/webpack.html">purgecss in webpack</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>webpack</category>
      
    </categories>
    
    
    <tags>
      
      <tag>webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webpack学习笔记(9)</title>
    <link href="/2022/10/09/2022-10-09-study-webpack-day9/"/>
    <url>/2022/10/09/2022-10-09-study-webpack-day9/</url>
    
    <content type="html"><![CDATA[<h1 id="学习笔记"><a class="markdownIt-Anchor" href="#学习笔记"></a> 学习笔记</h1><h2 id="prefetch-preload"><a class="markdownIt-Anchor" href="#prefetch-preload"></a> prefetch &amp; preload</h2><p>预获取(prefetch)的含义是在当前路由下加载将来其他路由可能需要的资源, 在<strong>vue-router</strong>中就经常见到, 正常情况下我们并不需要加载所有的路由资源, 只需要加载当前路由需要的资源; 配置<strong>prefetch</strong>可以在加载完当前路由所需资源后, 由浏览器决定何时加载设置 prefetch 的资源, 从而实现路由懒加载.</p><p>webpack 中对动态 import 的资源添加 prefetch:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">import</span>(<br>  <span class="hljs-comment">/* webpackPrefetch: true */</span> <span class="hljs-comment">/* webpackChunkName: &#x27;foo&#x27; */</span> <span class="hljs-string">&quot;./foo.js&quot;</span><br>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">v</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(v);<br>&#125;);<br></code></pre></td></tr></table></figure><p>资源加载顺序:</p><p><img src="https://dev.azure.com/HealMSlin/8544be09-1224-4eb0-824b-90c4ec9d49ee/_apis/git/repositories/7a27a721-4c93-4ecf-8258-d5422217b60a/items?path=%2F1665386744854_4322.png&amp;versionDescriptor%5BversionOptions%5D=0&amp;versionDescriptor%5BversionType%5D=0&amp;versionDescriptor%5Bversion%5D=master&amp;resolveLfs=true&amp;%24format=octetStream&amp;api-version=5.0" alt="" /></p><p>通过通过浏览器 network 可以看到在加载完当前所需资源后才会去加载<strong>foo.js</strong>.</p><p>预加载(preload)会在当前路由下加载<strong>当前路由</strong>可能需要的资源, 这点可能不好理解, 可以参考<a href="http://www.alloyteam.com/2016/05/preload-what-is-it-good-for-part1/">这篇文章</a>中举出的案例, 主要用于性能优化, 将当前路由要加载的资源设置<strong>preload</strong>提前加载.</p><p>webpack 也是通过 magic comment 的方式配置 preload:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">import</span>(<br>  <span class="hljs-comment">/* webpackPreload: true */</span> <span class="hljs-comment">/* webpackChunkName: &#x27;foo&#x27; */</span> <span class="hljs-string">&quot;./foo.js&quot;</span><br>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">v</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(v);<br>&#125;);<br></code></pre></td></tr></table></figure><p>preload 和 prefetch 长得很像, 含义却完全不一样, webpack 对两者做出以下总结:</p><ul><li>preload chunk 会在父 chunk 架子啊时, 以并行方式开始加载; prefetch chunk 会在父 chunk 加载结束后开始加载.</li><li>preload chunk 具有中等优先级, 并立即下载; prefetch chunk 在浏览器闲置时下载.</li><li>preload chunk 用于当下时刻; prefetch chunk 用于未来某个时刻.</li><li>浏览器支持程度不同.</li></ul><h2 id="runtimechunk"><a class="markdownIt-Anchor" href="#runtimechunk"></a> runtimeChunk</h2><p>type: <code>boolean | string | object</code><br />默认情况下 webpack 会将 runtime 相关的代码打包到主模块中, 可以通过配置<code>optimization.runtimeChunk</code>将 runtime 相关代码抽离到单独的 chunk 中.</p><p>什么是 runtime 代码?<br />runtime 相关的代码值的是在运行环境中对模块进行解析, 加载模块信息相关的代码; 不如<code>import()</code>函数异步加载模块代码就是通过 runtime 代码完成的.</p><p>webpack 配置:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">optimization</span>: &#123;<br>    <span class="hljs-attr">runtimeChunk</span>: <span class="hljs-literal">true</span>,<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p>webpack 中配置 runtimeChunk 为<code>true</code>和<code>'multiple'</code>是一样的, 都会根据入口文件生成对应个数的 runtime 文件.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">build<br>├── foo.07cb3e.<span class="hljs-property">bundle</span>.<span class="hljs-property">js</span><br>├── index.07cb3e.<span class="hljs-property">bundle</span>.<span class="hljs-property">js</span><br>├── index.<span class="hljs-property">html</span><br>├── main.07cb3e.<span class="hljs-property">bundle</span>.<span class="hljs-property">js</span><br>├── runtime~index.07cb3e.<span class="hljs-property">bundle</span>.<span class="hljs-property">js</span><br>└── runtime~main.07cb3e.<span class="hljs-property">bundle</span>.<span class="hljs-property">js</span><br></code></pre></td></tr></table></figure><p>可以看到生成两个 runtime 文件.<br />如果只想生成一个文件, 配置 runtimeChunk 为<code>'single'</code>即可.<br />runtimeChunk 的值还能够配置为对象, 具体参考官网.</p><h2 id="externals"><a class="markdownIt-Anchor" href="#externals"></a> externals</h2><p>真实开发中, 会引用非常多的第三方库, 在打包时这些库代码也会打包成产物, 最后将打包产物上传到服务器中; 为了优化性能, 我们可以通过在 webpack 中配置<code>externals</code>指定某些 npm 包不参与打包, 而是通过 cdn 链接的方式引入, 从而加快打包效率以及访问页面速率.</p><p>随便引入两个第三方库:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> _ <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;lodash&quot;</span>;<br><span class="hljs-keyword">import</span> moment <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;moment&quot;</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;lodash:&quot;</span>, _.<span class="hljs-title function_">join</span>([<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>], <span class="hljs-string">&quot; &quot;</span>));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;moment:&quot;</span>, <span class="hljs-title function_">moment</span>().<span class="hljs-title function_">format</span>());<br></code></pre></td></tr></table></figure><p>先看下没有配置没有配置 externals, 配置<code>optimization.splitChunks</code>的默认情况下打包结果:</p><p><img src="https://dev.azure.com/HealMSlin/8544be09-1224-4eb0-824b-90c4ec9d49ee/_apis/git/repositories/7a27a721-4c93-4ecf-8258-d5422217b60a/items?path=%2F1665390968154_8441.png&amp;versionDescriptor%5BversionOptions%5D=0&amp;versionDescriptor%5BversionType%5D=0&amp;versionDescriptor%5Bversion%5D=master&amp;resolveLfs=true&amp;%24format=octetStream&amp;api-version=5.0" alt="" /></p><p>可以看到库源码打包成 bundle, 总用时<strong>webpack 5.74.0 compiled with 3 warnings in 4301 ms</strong></p><p>配置 externals:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">externals</span>: &#123;<br>    <span class="hljs-attr">lodash</span>: <span class="hljs-string">&quot;_&quot;</span>,<br>    <span class="hljs-attr">moment</span>: <span class="hljs-string">&quot;moment&quot;</span>,<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p>需要注意的是这里的 key 为包名不难理解, <strong>值需要是 CDN 链接中暴露给 window 的变量名</strong>, 这意味着项目项目代码中不能随意定义 import 的变量名.</p><p>入口文件, 这里解构引入也是可以的, 打包之后的代码实际上和是否解构引入关系不大:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> _ <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;lodash&quot;</span>;<br><span class="hljs-keyword">import</span> moment <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;moment&quot;</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;lodash:&quot;</span>, _.<span class="hljs-title function_">join</span>([<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>], <span class="hljs-string">&quot; &quot;</span>));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;moment:&quot;</span>, <span class="hljs-title function_">moment</span>().<span class="hljs-title function_">format</span>());<br></code></pre></td></tr></table></figure><p>配置 externals 的打包结果:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">build<br>├── index.<span class="hljs-property">html</span><br>└── main.<span class="hljs-property">af547e</span>.<span class="hljs-property">bundle</span>.<span class="hljs-property">js</span><br></code></pre></td></tr></table></figure><p>可以看到库源码没有再进行打包了, 总用时<strong>webpack 5.74.0 compiled successfully in 334 ms</strong>.</p><p>由于库代码没有被打包, 此时页面肯定是不能正常运行的, 需要在 html 文件中插入对应的 cdn 链接, 可以在<a href="https://www.jsdelivr.com/">jsdelivr</a>sh 上搜索, 关于暴露给 window 的变量, 通过对应官网查询或查询未压缩的源码.</p><p>配置 cdn 链接:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Webpack App<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width,initial-scale=1&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">defer</span>=<span class="hljs-string">&quot;defer&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;main.af547e.bundle.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/moment@2.29.4/moment.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>页面可以正常访问:</p><p><img src="https://dev.azure.com/HealMSlin/8544be09-1224-4eb0-824b-90c4ec9d49ee/_apis/git/repositories/7a27a721-4c93-4ecf-8258-d5422217b60a/items?path=%2F1665401524177_2227.png&amp;versionDescriptor%5BversionOptions%5D=0&amp;versionDescriptor%5BversionType%5D=0&amp;versionDescriptor%5Bversion%5D=master&amp;resolveLfs=true&amp;%24format=octetStream&amp;api-version=5.0" alt="" /></p><h2 id="shimming"><a class="markdownIt-Anchor" href="#shimming"></a> shimming</h2><p>垫片, 比如现在依赖一个库, 可以不通过 import 或 require 引入, 直接通过<code>ProvidePlugin</code>配置 shimming 来直接使用, 具体参考<a href="https://www.webpackjs.com/plugins/provide-plugin/">官网</a><br />当然 webpack 并不推荐随意使用 shimming, webpack 理念是使前端更加模块化, 也就是编写具有封闭性的, 不存在隐含依赖(比如全局变量的)的彼此隔离的模块.</p><p>webpack 内置<strong>ProvidePlugin</strong>插件, 无需额外安装. 使用<strong>ProvidePlugin</strong>就不需要到处<code>import</code>相同模块.</p><p>配置, 还可以直接单独配置函数:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-comment">//...</span><br>  <span class="hljs-attr">plugins</span>: [<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProvidePlugin</span>(&#123;<br>      <span class="hljs-attr">_</span>: <span class="hljs-string">&quot;lodash&quot;</span>,<br>      <span class="hljs-attr">moment</span>: <span class="hljs-string">&quot;moment&quot;</span>,<br>      <span class="hljs-attr">_map</span>: [<span class="hljs-string">&quot;lodash&quot;</span>, <span class="hljs-string">&quot;map&quot;</span>],<br>    &#125;),<br>  ],<br>&#125;;<br></code></pre></td></tr></table></figure><p>入口文件, 没有<code>import</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;lodash:&quot;</span>, _.<span class="hljs-title function_">join</span>([<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>], <span class="hljs-string">&quot; &quot;</span>));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;moment:&quot;</span>, <span class="hljs-title function_">moment</span>().<span class="hljs-title function_">format</span>());<br><span class="hljs-title function_">_map</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], <span class="hljs-function">(<span class="hljs-params">v</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(v);<br>&#125;);<br></code></pre></td></tr></table></figure><p>打包产物会包含<strong>ProvidePlugin</strong>中配置的库文件, 查看控制台打印正常:</p><p><img src="https://dev.azure.com/HealMSlin/8544be09-1224-4eb0-824b-90c4ec9d49ee/_apis/git/repositories/7a27a721-4c93-4ecf-8258-d5422217b60a/items?path=%2F1665420147423_5358.png&amp;versionDescriptor%5BversionOptions%5D=0&amp;versionDescriptor%5BversionType%5D=0&amp;versionDescriptor%5Bversion%5D=master&amp;resolveLfs=true&amp;%24format=octetStream&amp;api-version=5.0" alt="" /></p><h2 id="minicssextractplugin"><a class="markdownIt-Anchor" href="#minicssextractplugin"></a> MiniCssExtractPlugin</h2><p>将 css 单独打包文件.<br />之前我们解析 css 文件最后都是使用 <strong>style-loader</strong> 通过<code>&lt;style&gt;</code>标签插入 header, 生产环境下更趋向于单独打包 css 资源; 需要依赖<strong>MiniCssExtractPlugin</strong>插件</p><p>安装:</p><p><code>yarn add -D mini-css-extract-plugin</code></p><p>在 webpack 中配置:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-function">(<span class="hljs-params">env</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-attr">module</span>: &#123;<br>      <span class="hljs-attr">rules</span>: [<br>        &#123;<br>          <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.css$/</span>,<br>          <span class="hljs-attr">use</span>: [<span class="hljs-title class_">MiniCssExtractPlugin</span>.<span class="hljs-property">loader</span>, <span class="hljs-string">&quot;css-loader&quot;</span>],<br>        &#125;,<br>      ],<br>    &#125;,<br>    <span class="hljs-attr">plugins</span>: [<br>      <span class="hljs-comment">//...</span><br>      <span class="hljs-keyword">new</span> <span class="hljs-title class_">MiniCssExtractPlugin</span>(&#123;<br>        <span class="hljs-attr">filename</span>: <span class="hljs-string">&quot;[name].[contenthash:6].css&quot;</span>,<br>      &#125;),<br>    ],<br>  &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><p>更多的我们希望在开发环境使用<strong>style-loader</strong>, 生产环境使用<strong>MiniCssExtractPlugin.loader</strong>, 可以通过 env 区分:</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs diff">module.exports = (env) =&gt; &#123;<br><span class="hljs-addition">+ const isDevelopment = !env.production;</span><br>  return &#123;<br>    //...<br>    module: &#123;<br>      rules: [<br>        &#123;<br>          test: /\.css$/,<br>          use: [<br><span class="hljs-deletion">-           MiniCssExtractPlugin.loader,</span><br><span class="hljs-addition">+           isDevelopment ? &#x27;style-loader&#x27; : MiniCssExtractPlugin.loader,</span><br>            &#x27;css-loader&#x27;,<br>          ],<br>        &#125;<br>      ]<br>    &#125;,<br>    plugins: [<br>  //...<br>      new MiniCssExtractPlugin(&#123;<br>        filename: &#x27;[name].[contenthash:6].css&#x27;<br>      &#125;),<br>    ],<br>  &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="hash"><a class="markdownIt-Anchor" href="#hash"></a> hash</h2><p>设置 filename 时, webpack 提供了<strong>hash</strong>, <strong>chunkhash</strong>, <strong>contenthash</strong>三种哈希值, 具体含义参考<a href="https://www.cnblogs.com/skychx/p/webpack-hash-chunkhash-contenthash.html">webpack 中，hash、chunkhash、contenthash 的区别是什么？</a> 这篇文章已经写的很详细了, 总结来说: 入口文件名用<strong>chunkhash</strong>, 模块文件名用<strong>contenthash</strong>.</p><h2 id="dll-自带-cache"><a class="markdownIt-Anchor" href="#dll-自带-cache"></a> DLL -&gt; 自带 cache</h2><p>Dynamic Link Library, 动态链接库, 这是 wiki 上的含义. 在 webpack 中指将不常用的代码打包成库文件, 可共享用于别的项目代码中. <strong>webpack4 之后 React/Vue 都不再使用 DLL, 因为 webpack 的性能足够优秀, 不需要再使用 DLL 文件</strong>, 这里做了解即可. 如果实际开发中真的要用到也建议使用<code>autodll-webpack-plugin</code>.</p><p>实际上 webpack4 中存在<code>hard-source-webpack-plugin</code>库做缓存, 第一次运行构建时间慢, 后续构建就很快了.<br />webpack5 内置了<strong>cache</strong>配置做缓存优化构建时间, 同样也是第一次构建时间较慢, 后续快.<br />缓存<strong>module</strong>和<strong>chunk</strong>目录默认为<code>node_modules/.cache/webpack/default-production**</code>, 可以通过修改<strong>name</strong>更换目录名</p><p>配置:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-comment">//...</span><br>  <span class="hljs-attr">cache</span>: &#123;<br>    <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;filesystem&quot;</span>,<br>    <span class="hljs-attr">allowCollectingMemory</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;&quot;</span>,<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="terser"><a class="markdownIt-Anchor" href="#terser"></a> Terser</h2><p>webpack4 使用<code>uglify-js</code>(<strong>uglifyjs-webpack-plugin</strong>)来压缩, 丑化代码, 目前该库已不再维护.<br />webpack5 使用<code>terser</code>(<strong>terser-webpack-plugin</strong>)来对代码进行压缩丑化; <code>terser</code>本就是由<code>uglify-js</code>fork 而来, 所以保留了<code>uglify-js</code>大部分的 API 用法.</p><p><code>terser</code>可以在终端单独使用, 首先安装:</p><p><code>yarn add -D terser</code></p><p>执行</p><p><code>npx terser input.js -o output.js -c -m</code></p><p>默认<code>terser</code>的输出文件只会将多余空格即换行去除, 如果需要进行压缩, 丑化, 保留函数名, 保留类名, 去除僵尸代码等, 可以参考<a href="https://github.com/terser/terser">官网</a>对应配置</p><p>接下来看下 webpack 中是如何使用<code>terser</code>的:<br />webpack 内置了<strong>terser-webpack-plugin</strong>插件进行上述操作.<br />事实上, 在真实开发中个, 在 production 下, 默认会开启 terser 插件处理代码;<br />如果对默认的配置不满意, 可以在<code>optimization.minimizer</code>中配置, 这里列出 webpack 官网的配置示例, 其中<strong>deprecate</strong>的挪到 compress 对象中配置:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">optimization</span>: &#123;<br>    <span class="hljs-attr">minimize</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">minimizer</span>: [<br>      <span class="hljs-keyword">new</span> <span class="hljs-title class_">TerserPlugin</span>(&#123;<br>        <span class="hljs-attr">terserOptions</span>: &#123;<br>          <span class="hljs-attr">ecma</span>: <span class="hljs-literal">undefined</span>,<br>          <span class="hljs-attr">parse</span>: &#123;&#125;,<br>          <span class="hljs-attr">compress</span>: &#123;&#125;,<br>          <span class="hljs-attr">mangle</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// Note `mangle.properties` is `false` by default.</span><br>          <span class="hljs-attr">module</span>: <span class="hljs-literal">false</span>,<br>          <span class="hljs-comment">// Deprecated</span><br>          <span class="hljs-attr">output</span>: <span class="hljs-literal">null</span>,<br>          <span class="hljs-attr">format</span>: <span class="hljs-literal">null</span>,<br>          <span class="hljs-attr">toplevel</span>: <span class="hljs-literal">false</span>,<br>          <span class="hljs-attr">nameCache</span>: <span class="hljs-literal">null</span>,<br>          <span class="hljs-attr">ie8</span>: <span class="hljs-literal">false</span>,<br>          <span class="hljs-attr">keep_classnames</span>: <span class="hljs-literal">undefined</span>,<br>          <span class="hljs-attr">keep_fnames</span>: <span class="hljs-literal">false</span>,<br>          <span class="hljs-attr">safari10</span>: <span class="hljs-literal">false</span>,<br>        &#125;,<br>      &#125;),<br>    ],<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p>具体字段含义和<code>terser</code>参数一致, 参考<a href="https://github.com/terser/terser">官网</a>.<br />这里只介绍一个对博主实际工作中很有用的配置<strong>dead_code</strong>, 该配置含义是 remove unreachable code, 即删除永远不会执行的逻辑, 默认值为<code>true</code>, 不用手动设置.<br />举个实际案例, 如果有段逻辑, 需要在正式环境执行, 不想在开发环境执行, 并且不想生成 dead_code, 可以怎么做呢?</p><p>在入口文件中引入该逻辑:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> === <span class="hljs-string">&quot;production&quot;</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;can reach here!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>webpack 中配置<strong>DefinePlugin</strong>和<strong>TerserPlugin</strong>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">mode</span>: <span class="hljs-string">&quot;production&quot;</span>,<br>  <span class="hljs-comment">//...</span><br>  <span class="hljs-attr">plugins</span>: [<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefinePlugin</span>(&#123;<br>      <span class="hljs-string">&quot;process.env.NODE_ENV&quot;</span>: <span class="hljs-string">&#x27;&quot;production&quot;&#x27;</span>,<br>    &#125;),<br>  ],<br>  <span class="hljs-attr">optimization</span>: &#123;<br>    <span class="hljs-attr">minimizer</span>: [<br>      <span class="hljs-keyword">new</span> <span class="hljs-title class_">TerserPlugin</span>(&#123;<br>        <span class="hljs-comment">//...</span><br>      &#125;),<br>    ],<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p>打包结果可以看到对应代码有参与打包:</p><p><img src="https://dev.azure.com/HealMSlin/8544be09-1224-4eb0-824b-90c4ec9d49ee/_apis/git/repositories/7a27a721-4c93-4ecf-8258-d5422217b60a/items?path=%2F1665717927158_90.png&amp;versionDescriptor%5BversionOptions%5D=0&amp;versionDescriptor%5BversionType%5D=0&amp;versionDescriptor%5Bversion%5D=master&amp;resolveLfs=true&amp;%24format=octetStream&amp;api-version=5.0" alt="" /></p><p>把环境改为开发环境:</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs diff">module.exports = &#123;<br><span class="hljs-deletion">-  mode: &#x27;production&#x27;,</span><br><span class="hljs-addition">+  mode: &#x27;development&#x27;,</span><br>  //...<br>  plugins: [<br>    //...<br>    new DefinePlugin(&#123;<br><span class="hljs-deletion">-      &#x27;process.env.NODE_ENV&#x27;: &#x27;&quot;production&quot;&#x27;,</span><br><span class="hljs-addition">+      &#x27;process.env.NODE_ENV&#x27;: &#x27;&quot;development&quot;&#x27;,</span><br>    &#125;),<br>  ],<br>  optimization: &#123;<br>    minimizer: [<br>      new TerserPlugin(&#123;<br>        //...<br>      &#125;)<br>    ]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到没有对应代码.</p><p><img src="https://dev.azure.com/HealMSlin/8544be09-1224-4eb0-824b-90c4ec9d49ee/_apis/git/repositories/7a27a721-4c93-4ecf-8258-d5422217b60a/items?path=%2F1665718100334_3984.png&amp;versionDescriptor%5BversionOptions%5D=0&amp;versionDescriptor%5BversionType%5D=0&amp;versionDescriptor%5Bversion%5D=master&amp;resolveLfs=true&amp;%24format=octetStream&amp;api-version=5.0" alt="" /></p><h2 id="css-compress"><a class="markdownIt-Anchor" href="#css-compress"></a> Css Compress</h2><p>除了 js 压缩外, 另外一种最常见的代码压缩是 css; css 压缩通常是去除无用的空格, 无法做丑化, 因为很难修改选择器, 属性名称等.<br />css 压缩使用<code>css-minimizer-webpack-plugin</code>插件, 和<code>mini-css-extract-plguin</code>单独生成 css 文件一起使用.</p><h2 id="scope-hoisting"><a class="markdownIt-Anchor" href="#scope-hoisting"></a> Scope Hoisting</h2><p>作用域提升. 最普遍的例子就是导入的模块生成打包产物会生成大量 IIFE 函数如[[2022-09-15-study-webpack-day5#CommonJS 模块化实现原理]]中的<code>__webpack_exports__</code>, 作用域提升用于删除无用的 IIFE 函数包裹, 进一步减少代码量, 提升运行速度. 生产环境下默认开启, 开发环境开启需要手动配置.</p><p>webpack 配置:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">plugins</span>: [webpack.<span class="hljs-property">optimization</span>.<span class="hljs-title class_">ModuleConcatenationPlugin</span>()];<br></code></pre></td></tr></table></figure><p>该插件内部依赖 ESM 静态分析, 所以导入模块时最好都使用 ESM import.</p><p>开启前:</p><p><img src="https://dev.azure.com/HealMSlin/8544be09-1224-4eb0-824b-90c4ec9d49ee/_apis/git/repositories/7a27a721-4c93-4ecf-8258-d5422217b60a/items?path=%2F1666526652002_3241.png&amp;versionDescriptor%5BversionOptions%5D=0&amp;versionDescriptor%5BversionType%5D=0&amp;versionDescriptor%5Bversion%5D=master&amp;resolveLfs=true&amp;%24format=octetStream&amp;api-version=5.0" alt="" /></p><p>开启后:</p><p><img src="https://dev.azure.com/HealMSlin/8544be09-1224-4eb0-824b-90c4ec9d49ee/_apis/git/repositories/7a27a721-4c93-4ecf-8258-d5422217b60a/items?path=%2F1666526769317_1254.png&amp;versionDescriptor%5BversionOptions%5D=0&amp;versionDescriptor%5BversionType%5D=0&amp;versionDescriptor%5Bversion%5D=master&amp;resolveLfs=true&amp;%24format=octetStream&amp;api-version=5.0" alt="" /></p><p>可以看到开启作用域前后的产物大小提升还是非常大的</p><h1 id="示例代码"><a class="markdownIt-Anchor" href="#示例代码"></a> 示例代码</h1><p><a href="https://github.com/Mariana-Yui/fe-learn-code/tree/main/learn-webpack/day9">https://github.com/Mariana-Yui/fe-learn-code/tree/main/learn-webpack/day9</a></p><h1 id="reference"><a class="markdownIt-Anchor" href="#reference"></a> reference</h1><ol><li><a href="https://www.cnblogs.com/skychx/p/webpack-hash-chunkhash-contenthash.html">webpack 中，hash、chunkhash、contenthash 的区别是什么？</a></li><li><a href="https://juejin.cn/post/6844903952140468232">辛辛苦苦学会的 webpack dll 配置，可能已经过时了</a></li><li><a href="https://webpack.js.org/configuration/cache/#cache">webpack5 中的 cache 配置替代 hard-source-webpack-plugin</a></li><li><a href="https://github.com/terser/terser">terser 参数配置</a></li><li><a href="https://zhuanlan.zhihu.com/p/348612482">Webpack5 新特性业务落地实战</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>webpack</category>
      
    </categories>
    
    
    <tags>
      
      <tag>webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webpack学习笔记(8)</title>
    <link href="/2022/10/05/2022-10-05-study-webpack-day8/"/>
    <url>/2022/10/05/2022-10-05-study-webpack-day8/</url>
    
    <content type="html"><![CDATA[<h1 id="学习笔记"><a class="markdownIt-Anchor" href="#学习笔记"></a> 学习笔记</h1><h2 id="配置区分环境"><a class="markdownIt-Anchor" href="#配置区分环境"></a> 配置区分环境</h2><p>针对开发环境和生产环境, 可以抽离不同环境特定的配置和公共配置, 针对传入的环境参数生成不同的配置.</p><p>首先在<strong>config</strong>目录下新建通用配置文件, 生产环境配置文件, 开发环境配置文件. 现将原先<strong>webpack.config.js</strong>的内容复制到<strong>webpack.common.js</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">config<br>├── webpack.<span class="hljs-property">common</span>.<span class="hljs-property">js</span><br>├── webpack.<span class="hljs-property">dev</span>.<span class="hljs-property">js</span><br>└── webpack.<span class="hljs-property">prod</span>.<span class="hljs-property">js</span><br></code></pre></td></tr></table></figure><p>webpack 通过<code>--config</code>指定配置文件, 通过<code>--env</code>指定环境变量.</p><p>之前的<code>webpack.config.js</code> 是导出一个对象:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-comment">//...</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>设置环境变量后导出值需要变为函数:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">env</span>) &#123;<br>  <span class="hljs-comment">//...</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>然后运行<code>webpack --config ./config/webpack.common.js --env production</code>, 可以看到终端打印<code>env</code>输出:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123; <span class="hljs-attr">WEBPACK_BUNDLE</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">WEBPACK_BUILD</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">production</span>: <span class="hljs-literal">true</span> &#125;<br></code></pre></td></tr></table></figure><p>然后将参数赋值给<code>process.env.NODE_ENV</code>, 通过这种方式区分当前环境, 这样<strong>babel.config.js</strong>, <strong>postcss.config.js</strong>等文件也能过读取环境变量.</p><p>需要注意的一点是, <code>process.env</code>设置的属性都会转换为字符串, <code>true</code>-&gt; <code>'true'</code>, <code>undefined</code> -&gt; <code>'undefined'</code>, 不能简单通过<code>!</code>关键字判断, 这是容易弄错的地方.</p><p>然后就是抽离通用配置, 开发环境使用的配置, 生产环境使用的配置, 这里以之前[[2022-09-30-study-webpack-day7#示例代码]]举例:</p><h2 id="code-splitting"><a class="markdownIt-Anchor" href="#code-splitting"></a> Code splitting</h2><p>代码拆分(code splitting)是 webpack 一个非常重要的特性.<br />主要目的是将代码分离到不同的 bundle 中, 之后我们可以按需加载, 或者并行加载这些文件; 比如默认情况下, 所有的 JavaScript 代码(业务代码, 第三方以来, 暂时没有用到的模块) 在首页全部加载就会影响首页加载速度;代码分离可以分出更小的 bundle, 以及控制资源加载优先级, 提供代码的加载性能</p><p>先看下没有做任何处理的打包结果, 随便引入几个第三方库:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> moment <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;moment&quot;</span>;<br><span class="hljs-keyword">import</span> _ <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;lodash&quot;</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;hello world&quot;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;moment:&quot;</span>, <span class="hljs-title function_">moment</span>());<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(_.<span class="hljs-title function_">join</span>([<span class="hljs-string">&quot;mariana&quot;</span>, <span class="hljs-string">&quot;yui&quot;</span>]));<br></code></pre></td></tr></table></figure><p>引入第三方库打包默认会生成 LICENSE.txt 文件, 可以先忽略.<br />可以看到打包结果, 第三方库源码也被打包进了入口文件中.</p><p><img src="https://dev.azure.com/HealMSlin/8544be09-1224-4eb0-824b-90c4ec9d49ee/_apis/git/repositories/7a27a721-4c93-4ecf-8258-d5422217b60a/items?path=%2F1665042596061_6532.png&amp;versionDescriptor%5BversionOptions%5D=0&amp;versionDescriptor%5BversionType%5D=0&amp;versionDescriptor%5Bversion%5D=master&amp;resolveLfs=true&amp;%24format=octetStream&amp;api-version=5.0" alt="" /></p><p>此时我们就需要代码分离来进行优化,<br />Webpack 常见的代码分离有三种:</p><ul><li>入口起点: 使用 entry 配置手动分离代码</li><li>防止重复: 使用 Entry Dependencies 或者 SplitChunksPlugin 去重和分离代码</li><li>动态导入: 通过模块内联函数调用来分离代码</li></ul><h3 id="入口起点"><a class="markdownIt-Anchor" href="#入口起点"></a> 入口起点</h3><p>当单入口文件中存在没有耦合关系的代码时, 可以通过配置多个入口文件来减小单个文件的体积.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// index.js</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;hello index&quot;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;hello main&quot;</span>);<br></code></pre></td></tr></table></figure><p>拆分为:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// index.js</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;hello index&quot;</span>);<br><span class="hljs-comment">// main.js</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;hello main&quot;</span>);<br></code></pre></td></tr></table></figure><p>配置 entry:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">entry</span>: &#123;<br>    <span class="hljs-attr">index</span>: <span class="hljs-string">&quot;./index.js&quot;</span>,<br>    <span class="hljs-attr">main</span>: <span class="hljs-string">&quot;./main.js&quot;</span>,<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p>当然一般情况下 React/Vue 框架的 SPA 页面都是单入口文件, 在多页面打包时才会使用这种方案.</p><h3 id="防止重复"><a class="markdownIt-Anchor" href="#防止重复"></a> 防止重复</h3><p>存在 Enty Dependencies 和 SplitChunksPlugin 两种方案来进行代码分离, 其中绝大部分情况都是使用 SplitChunksPlugin, Entry Dependencies 官方<strong>并不推荐</strong>.</p><h4 id="entry-dependuncies"><a class="markdownIt-Anchor" href="#entry-dependuncies"></a> Entry Dependuncies</h4><p>对于引入的第三方库, entry 也可以将其作为入口文件, 值可以是 string 或 Array. 引用第三方库的入口文件配置和之前有所变化.</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs diff">module.exports = &#123;<br>  entry: &#123;<br><span class="hljs-deletion">-   index: &#x27;./index.js&#x27;,</span><br><span class="hljs-addition">+   &#x27;index&#x27;: &#123; import: &#x27;./index.js&#x27;, dependOn: &#x27;shared&#x27; &#125;,</span><br>    main: &#x27;./main.js&#x27;,<br><span class="hljs-addition">+   shared: [&#x27;lodash&#x27;, &#x27;moment&#x27;],</span><br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p>打包结果可以看到第三方库代码被单独打包了.</p><p><img src="https://dev.azure.com/HealMSlin/8544be09-1224-4eb0-824b-90c4ec9d49ee/_apis/git/repositories/7a27a721-4c93-4ecf-8258-d5422217b60a/items?path=%2F1665149736641_3749.png&amp;versionDescriptor%5BversionOptions%5D=0&amp;versionDescriptor%5BversionType%5D=0&amp;versionDescriptor%5Bversion%5D=master&amp;resolveLfs=true&amp;%24format=octetStream&amp;api-version=5.0" alt="" /></p><h4 id="splitchunksplugin"><a class="markdownIt-Anchor" href="#splitchunksplugin"></a> SplitChunksPlugin</h4><p>webpack 官方推荐通过这个插件配置, 通过<strong>optimization.splitChunks</strong>配置, 官方的配置样例:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-comment">//...</span><br>  <span class="hljs-attr">optimization</span>: &#123;<br>    <span class="hljs-attr">splitChunks</span>: &#123;<br>      <span class="hljs-attr">chunks</span>: <span class="hljs-string">&quot;async&quot;</span>,<br>      <span class="hljs-attr">minSize</span>: <span class="hljs-number">20000</span>,<br>      <span class="hljs-attr">minRemainingSize</span>: <span class="hljs-number">0</span>,<br>      <span class="hljs-attr">minChunks</span>: <span class="hljs-number">1</span>,<br>      <span class="hljs-attr">maxAsyncRequests</span>: <span class="hljs-number">30</span>,<br>      <span class="hljs-attr">maxInitialRequests</span>: <span class="hljs-number">30</span>,<br>      <span class="hljs-attr">enforceSizeThreshold</span>: <span class="hljs-number">50000</span>,<br>      <span class="hljs-attr">cacheGroups</span>: &#123;<br>        <span class="hljs-attr">defaultVendors</span>: &#123;<br>          <span class="hljs-attr">test</span>: <span class="hljs-regexp">/[\\/]node_modules[\\/]/</span>,<br>          <span class="hljs-attr">priority</span>: -<span class="hljs-number">10</span>,<br>          <span class="hljs-attr">reuseExistingChunk</span>: <span class="hljs-literal">true</span>,<br>        &#125;,<br>        <span class="hljs-attr">default</span>: &#123;<br>          <span class="hljs-attr">minChunks</span>: <span class="hljs-number">2</span>,<br>          <span class="hljs-attr">priority</span>: -<span class="hljs-number">20</span>,<br>          <span class="hljs-attr">reuseExistingChunk</span>: <span class="hljs-literal">true</span>,<br>        &#125;,<br>      &#125;,<br>    &#125;,<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p>下面介绍其中常用的配置字段, 其余的使用默认配置即可.</p><ul><li><code>chunks</code>: <code>async | initial | all</code>, 默认为<strong>async</strong>, 只针对异步(<strong>import()</strong> 或 <strong>require.ensure</strong> )导入的模块进行代码分离; <strong>initial</strong>只针对同步导入模块代码分离; <strong>all</strong>对同步和异步导入的模块都会进行代码分离, 一般都设置为<strong>all</strong>.</li><li><code>minSize</code>: 文件大小(包括引入的包)达到<strong>minSize</strong>才会拆分</li><li><code>maxSize</code>: 将大于<strong>maxSize</strong>的文件拆分为不小于<strong>minSize</strong>大小的文件, 一般用于二次拆分保证每个包文件不会过大, 一般情况下<strong>minSize</strong>和<strong>maxSize</strong>使用默认值即可, 即使手动设置也最好保持两者一直. BTW, <strong>minSize</strong>优先级大于<strong>maxSize</strong>, 即使配置<strong>maxSize</strong>小于<strong>minSize</strong>, 当然这样配置是绝对错误的.</li><li><code>minChunks</code>: 默认为<strong>1</strong>, 模块被<strong>minChunks</strong>个入口文件引用时才会拆分, 一般都是单入口文件, 用默认值即可</li><li><code>cacheGroups</code>: 针对不同的文件夹下的包文件进行更细致的打包配置, <strong>chunks</strong>, <strong>minChunks</strong>也可在<strong>cacheGroup</strong>中使用<ul><li><code>test</code>: 正则匹配文件夹</li><li><code>filename</code>: 打包的文件名, 配置和<code>output.filename</code>一致</li><li><code>priority</code>: 优先级, 当多个 cacheGroup 匹配上时, 使用优先级最高的</li><li><code>reuseExistingChunk</code>: 如果当前包文件已经被打包, 直接使用打包文件</li></ul></li><li><code>chunkIds</code>: <code>natural | named | deterministic</code>, 默认为<strong>deterministic</strong>, webpack 生成的唯一 id 作为 filename 或 chunkFilename 的<code>[name]</code>, 如果文件内容不变, 生成的 id 也不会改变; <code>natural</code> 使用正整数作为<code>[name]</code>, 不利于浏览器缓存, 不推荐; <code>named</code>, 使用文件的路径+文件名作为<code>[name]</code>, 开发环境下推荐使用, 见名知意.<br />可以看到使用不同<strong>chunkIds</strong>值打包后的输出:</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// natural</span><br>build<br>├── <span class="hljs-number">2.</span>vendor.<span class="hljs-property">js</span><br>├── <span class="hljs-number">3.098650</span>.<span class="hljs-property">vendor</span>.<span class="hljs-property">js</span><br>├── <span class="hljs-number">4.098650</span>.<span class="hljs-property">vendor</span>.<span class="hljs-property">js</span><br>├── index.<span class="hljs-property">bundle</span>.<span class="hljs-property">js</span><br>├── index.<span class="hljs-property">html</span><br>└── main.<span class="hljs-property">bundle</span>.<span class="hljs-property">js</span><br><span class="hljs-comment">// named</span><br>build<br>├── bar1_js.<span class="hljs-property">b89f72</span>.<span class="hljs-property">vendor</span>.<span class="hljs-property">js</span><br>├── bar2_js.<span class="hljs-property">b89f72</span>.<span class="hljs-property">vendor</span>.<span class="hljs-property">js</span><br>├── index.<span class="hljs-property">bundle</span>.<span class="hljs-property">js</span><br>├── index.<span class="hljs-property">html</span><br>├── main.<span class="hljs-property">bundle</span>.<span class="hljs-property">js</span><br>└── vendor-node_modules_lodash_lodash_js-node_modules_moment_locale_af_js-node_modules_moment_loc-65a2e8.<span class="hljs-property">vendor</span>.<span class="hljs-property">js</span><br><span class="hljs-comment">// deterministic</span><br>build<br>├── <span class="hljs-number">351.</span>18c68f.<span class="hljs-property">vendor</span>.<span class="hljs-property">js</span><br>├── <span class="hljs-number">482.</span>vendor.<span class="hljs-property">js</span><br>├── <span class="hljs-number">611.</span>18c68f.<span class="hljs-property">vendor</span>.<span class="hljs-property">js</span><br>├── index.<span class="hljs-property">bundle</span>.<span class="hljs-property">js</span><br>├── index.<span class="hljs-property">html</span><br>└── main.<span class="hljs-property">bundle</span>.<span class="hljs-property">js</span><br></code></pre></td></tr></table></figure><p>其中, 异步导入的文件打包是特殊的. 无论<code>chunks</code>配置什么, 异步导入的包都会进行打包, 并且<code>cacheGroups</code>无法进行配置, 需要在<code>output.chunkFilename</code>配置.<br />webpack 官网对<code>output.chunkFilename</code>的定义即:</p><blockquote><p>This option determines the name of non-initial chunk files.</p></blockquote><p><s>怎么样, 你 kun 哥弔不弔, 你干嘛哎哟</s>~<br />上述输出是对<strong>chunkFilename</strong>配置<code>[name].[hash:6].vendor.js</code>的结果.</p><h5 id="magic-comment"><a class="markdownIt-Anchor" href="#magic-comment"></a> Magic Comment</h5><p>除了<strong>chunkIds</strong>配置<code>[name]</code>外, webpack 提供了魔法注释(Magic Comment)设置额异步导入文件打包后的<code>[name]</code>, 并且魔法注释的优先级是<strong>最高的</strong>.</p><p>修改入口文件内容, 添加魔法注释:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">import</span>(<span class="hljs-comment">/* webpackChunkName: &quot;foo1&quot; */</span> <span class="hljs-string">&quot;./bar1&quot;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">v</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(v);<br>&#125;);<br><br><span class="hljs-title function_">import</span>(<span class="hljs-comment">/* webpackChunkName: &quot;foo2&quot; */</span> <span class="hljs-string">&quot;./bar2&quot;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">v</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(v);<br>&#125;);<br></code></pre></td></tr></table></figure><p>查看打包结果:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">build<br>├── <span class="hljs-number">482.</span>vendor.<span class="hljs-property">js</span><br>├── foo1.<span class="hljs-property">b1a757</span>.<span class="hljs-property">vendor</span>.<span class="hljs-property">js</span><br>├── foo2.<span class="hljs-property">b1a757</span>.<span class="hljs-property">vendor</span>.<span class="hljs-property">js</span><br>├── index.<span class="hljs-property">bundle</span>.<span class="hljs-property">js</span><br>├── index.<span class="hljs-property">html</span><br>└── main.<span class="hljs-property">bundle</span>.<span class="hljs-property">js</span><br></code></pre></td></tr></table></figure><p>最后想说, 关于 code splitting, 大部分情况下使用官方默认配置即可, 即使是 React/Vue 框架椰汁对小部分进行了修改:<br /><strong>Vue</strong>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">optimization</span>: &#123;<br>  <span class="hljs-attr">splitChunks</span>: &#123;<br>    <span class="hljs-attr">vendors</span>: &#123;<br>      <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;chunk-vendors&#x27;</span>,<br>      <span class="hljs-attr">test</span>: <span class="hljs-regexp">/[\\/]node_modules[\\/]/</span>,<br>      <span class="hljs-attr">priority</span>: -<span class="hljs-number">10</span>,<br>      <span class="hljs-attr">chunks</span>: <span class="hljs-string">&#x27;initial&#x27;</span>,<br>    &#125;,<br>    <span class="hljs-attr">common</span>: &#123;<br>      <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;chunk-common&#x27;</span>,<br>      <span class="hljs-attr">minChunks</span>: <span class="hljs-number">2</span>,<br>      <span class="hljs-attr">priority</span>: -<span class="hljs-number">20</span>,<br>      <span class="hljs-attr">chunks</span>: <span class="hljs-string">&#x27;initial&#x27;</span>,<br>      <span class="hljs-attr">reuseExistingChunk</span>: <span class="hljs-literal">true</span>,<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>React</strong>更随便:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">optimization</span>: &#123;<br>  <span class="hljs-attr">splitChunks</span>: &#123;<br>    <span class="hljs-attr">chunks</span>: <span class="hljs-string">&#x27;all&#x27;</span>,<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="示例代码"><a class="markdownIt-Anchor" href="#示例代码"></a> 示例代码</h1><p><a href="https://github.com/Mariana-Yui/fe-learn-code/tree/main/learn-webpack/day8">https://github.com/Mariana-Yui/fe-learn-code/tree/main/learn-webpack/day8</a></p><h1 id="reference"><a class="markdownIt-Anchor" href="#reference"></a> reference</h1><ol><li><a href="https://webpack.js.org/configuration/output/#outputchunkfilename">webpack 官网对 chunkFilenam 解释</a></li><li><a href="https://juejin.cn/post/7074895794406424583">webpack 的 MagicComments（魔法注释）</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>webpack</category>
      
    </categories>
    
    
    <tags>
      
      <tag>webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webpack学习笔记(7)</title>
    <link href="/2022/09/30/2022-09-30-study-webpack-day7/"/>
    <url>/2022/09/30/2022-09-30-study-webpack-day7/</url>
    
    <content type="html"><![CDATA[<h1 id="学习笔记"><a class="markdownIt-Anchor" href="#学习笔记"></a> 学习笔记</h1><h2 id="watch"><a class="markdownIt-Anchor" href="#watch"></a> watch</h2><p>本节之前如果要运行打包产物, 博主都需要执行两步:</p><ol><li><code>webpack</code> 打包代码</li><li>使用 VSCode 插件 <a href="https://marketplace.visualstudio.com/items?itemName=ritwickdey.LiveServer">live-server</a> 打开 5500 端口查看网页</li></ol><p>webpack 提供了<code>watch</code>参数监听文件变化自动执行打包命令, 可以通过:</p><p><code>webpack --watch</code></p><p>或者在 webpack.config.js 中配置</p><p><code>watch: true</code></p><p>即使这样做依旧存在几个问题:</p><ol><li>每次变更时都是全部文件打包, 没有变更的文件也会重新打包</li><li>打包结果会写入文件系统即本地磁盘, 读取文件系统速率相对较慢</li><li>live-server 插件只能在 vscode 中使用</li><li>每次都会刷新整个页面, 无法保留页面当前状态</li></ol><p>那存在上述这些问题, 有没有工具能够解决呢? 有的.</p><h2 id="webpack-dev-server"><a class="markdownIt-Anchor" href="#webpack-dev-server"></a> webpack-dev-server</h2><p>webpack 提供了<code>webpack-dev-server</code>工具来解决上述问题, 我们一个一个阐述.</p><p>安装:</p><p><code>yarn add -D webpack-dev-server</code></p><p>安装完<code>webpack-dev-server</code>后就不需要安装<code>live-server</code>插件, 也不需要执行上述两步了, 直接运行:</p><p><code>webpack serve</code></p><p><code>web-pack-dev-server</code>内置了 express 服务监听文件变更, 并且只会打包变更文件, 并通过 websocket 通知浏览器刷新页面, 这样就解决上述<strong>问题 1</strong> 和 <strong>问题 3</strong>.</p><p>并且, <code>webpack-dev-server</code>使用<a href="https://www.npmjs.com/package/memfs">memfs</a>将打包产物赋值给变量直接写入内存中, 提升了读取效率, 解决<strong>问题 2</strong>.</p><h3 id="customize-webpack-dev-server"><a class="markdownIt-Anchor" href="#customize-webpack-dev-server"></a> customize webpack-dev-server</h3><p><code>webpack-dev-server</code>默认使用 express 本地启动一个服务, ~~如果你想的话, ~~也可以自定义一个服务. <strong>当然在项目中不建议这么做, 因为默认的服务中还存在 HMR 等重要特性, 使用默认服务即可.</strong> 这里举个自定义的简单例子.</p><p>安装必要包:</p><p><code>yarn add -D express webpack-dev-middleware</code></p><p>然后添加以下逻辑, 将<strong>webpack</strong>生成的<strong>compiler</strong>交由<strong>webpackDevMiddleware</strong>处理:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// server,js</span><br><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;express&quot;</span>);<br><span class="hljs-keyword">const</span> webpackDevMiddleware = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;webpack-dev-middleware&quot;</span>);<br><span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;webpack&quot;</span>);<br><span class="hljs-keyword">const</span> config = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./webpack.config&quot;</span>);<br><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();<br><span class="hljs-keyword">const</span> compiler = <span class="hljs-title function_">webpack</span>(config);<br><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">webpackDevMiddleware</span>(compiler));<br><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">8080</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;server is running on port 8080&quot;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>最后执行<code>node server.js</code>, 访问 8080 端口即可看到页面.</p><p>事实上, <code>webpack-dev-server</code>内置了<code>webpack-dev-middleware</code>, 也是通过上述的方式将<strong>compiler</strong>交由中间件托管, 只不过实现上更复杂.</p><h2 id="hmr"><a class="markdownIt-Anchor" href="#hmr"></a> HMR</h2><p>全程<strong>Hot Module Replacement</strong>, <code>webpack-dev-server</code>同样内置了该特性旨在解决<strong>问题 4</strong>.</p><p><code>webpack-dev-server</code>默认没有启动 HMR, 需要手动配置:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-attr">devServer</span>: &#123;<br>    <span class="hljs-attr">hot</span>: <span class="hljs-literal">true</span>,<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p>配置完需要在入口文件底部插入 HMR 逻辑, 通知<code>webpack-dev-server</code>哪些文件变更需要触发热更新, 不要用 optional chain</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (<span class="hljs-variable language_">module</span>.<span class="hljs-property">hot</span>) &#123;<br>  <span class="hljs-variable language_">module</span>.<span class="hljs-property">hot</span>.<span class="hljs-title function_">accept</span>([<span class="hljs-string">&quot;./math.js&quot;</span>], <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;hmr executed.&quot;</span>);<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>HMR 的实现原理还是很有意思的, 这里推荐阅读<a href="https://zhuanlan.zhihu.com/p/30669007">HMR 原理解析</a>, 深刻描述了 HMR 在<code>webpack-dev-server</code>中的实现原理.<s>比我叭叭叭讲强多了</s></p><h2 id="在框架中使用-hmr"><a class="markdownIt-Anchor" href="#在框架中使用-hmr"></a> 在框架中使用 HMR</h2><p>在实践过程中发现的问题, 这里强调一下.<br />jsx 文件或者是 vue 文件, 需要在文件内模块导出, 然后在入口文件导入模块并使用<code>import Cmp from 'cmp.xxx'</code>; 而不是直接在模块中执行完所有逻辑, 在入口文件简单<code>import 'cmp.xxx';</code>, 这样做<strong>HMR</strong>不会生效, 只会直接 location.reload().</p><h3 id="hmr-in-react"><a class="markdownIt-Anchor" href="#hmr-in-react"></a> HMR in React</h3><p>安装 HMR 需要的包:</p><p><code>yarn add -D @pmmmwh/react-refresh-webpack-plugin react-refresh</code></p><p>React 热更新的这些插件只能在开发环境(development)使用, 生产环境(production)打包时需要会报错, 所以这里通过<code>process.env.NODE_ENV</code>判断环境动态添加插件:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//...</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">ReactRefreshWebpackPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@pmmmwh/react-refresh-webpack-plugin&quot;</span>);<br><br><span class="hljs-keyword">const</span> isDevelopment = process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> !== <span class="hljs-string">&quot;production&quot;</span>;<br><br><span class="hljs-keyword">const</span> plugins = [<br>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">CleanWebpackPlugin</span>(),<br>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>(&#123;<br>    <span class="hljs-attr">template</span>: <span class="hljs-string">&quot;./index.html&quot;</span>,<br>    <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;Day7 p2&quot;</span>,<br>  &#125;),<br>];<br>isDevelopment &amp;&amp; plugins.<span class="hljs-title function_">push</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ReactRefreshWebpackPlugin</span>());<br><br><span class="hljs-keyword">const</span> babelPlugins = [];<br>isDevelopment &amp;&amp; babelPlugins.<span class="hljs-title function_">push</span>(<span class="hljs-string">&quot;react-refresh/babel&quot;</span>);<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-comment">//...</span><br>  <span class="hljs-attr">module</span>: &#123;<br>    <span class="hljs-attr">rules</span>: [<br>      &#123;<br>        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.jsx?$/i</span>,<br>        <span class="hljs-attr">exclude</span>: <span class="hljs-regexp">/node_modules/</span>,<br>        <span class="hljs-attr">use</span>: [<br>          &#123;<br>            <span class="hljs-attr">loader</span>: <span class="hljs-string">&quot;babel-loader&quot;</span>,<br>            <span class="hljs-attr">options</span>: &#123;<br>              <span class="hljs-attr">plugins</span>: babelPlugins,<br>            &#125;,<br>          &#125;,<br>        ],<br>      &#125;,<br>      <span class="hljs-comment">//...</span><br>    ],<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="hmr-in-vue"><a class="markdownIt-Anchor" href="#hmr-in-vue"></a> HMR in Vue</h3><p>安装 HMR 依赖的包:</p><p><code>yarn add -D vue-loader</code></p><p>Vue 热更新依赖的插件没有环境的问题, 直接在配置中添加即可:</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs diff">//...<br>const ReactRefreshWebpackPlugin = require(&#x27;@pmmmwh/react-refresh-webpack-plugin&#x27;);<br><span class="hljs-addition">+ const &#123; VueLoaderPlugin &#125; = require(&#x27;vue-loader&#x27;);</span><br><br>const isDevelopment = process.env.NODE_ENV !== &#x27;production&#x27;;<br><br>const plugins = [<br>  new CleanWebpackPlugin(),<br>  new HtmlWebpackPlugin(&#123;<br>    template: &#x27;./index.html&#x27;,<br>    title: &#x27;Day7 p2&#x27;,<br>    filename: &#x27;page/index.html&#x27;,<br>  &#125;),<br><span class="hljs-addition">+ new VueLoaderPlugin(),</span><br>];<br>isDevelopment &amp;&amp; plugins.push(new ReactRefreshWebpackPlugin());<br><br>const babelPlugins = [];<br>isDevelopment &amp;&amp; babelPlugins.push(&#x27;react-refresh/babel&#x27;);<br><br>module.exports = &#123;<br>  //...<br>  module: &#123;<br>    rules: [<br>      &#123;<br>        test: /\.jsx?$/i,<br>        exclude: /node_modules/,<br>        use: [<br>          &#123;<br>            loader: &#x27;babel-loader&#x27;,<br>            options: &#123;<br>              plugins: babelPlugins,<br>            &#125;,<br>          &#125;,<br><span class="hljs-addition">+         &#123;</span><br><span class="hljs-addition">+        test: /\.vue$/i,</span><br><span class="hljs-addition">+        use: &#x27;vue-loader&#x27;,</span><br><span class="hljs-addition">+      &#125;,</span><br>        ],<br>      &#125;,<br>      //...<br>    ]<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>具体 React/Vue 组件逻辑及入口文件引用逻辑查看示例代码.</p><h2 id="publicpath-path-contentbase-in-webpack5"><a class="markdownIt-Anchor" href="#publicpath-path-contentbase-in-webpack5"></a> publicPath, path, contentBase in webpack5</h2><p>webpack5 之前对这些配置的介绍可以参考: [[2021-06-25-path-publicPath-contentBase]]</p><h3 id="publicpath"><a class="markdownIt-Anchor" href="#publicpath"></a> publicPath</h3><p>publicPath 在 output 和 devServer 中配置的含义完全不同.</p><h4 id="in-output"><a class="markdownIt-Anchor" href="#in-output"></a> in output</h4><p>在 output 中, publicPath 表示 html 中引入文件路径的前缀, 并以<code>$&#123;publicPath&#125;$&#123;文件名&#125;</code>的字符串写入 html 中, publicPath 默认值为<code>''</code>.</p><p>在开发环境中, 通过<code>webpack-dev-server</code>启动的服务使得能够在浏览器中通过 http 访问 html 文件.<br />此时可以配置绝对路径(事实上也更推荐配置绝对路径), 例如:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">output</span>: &#123;<br>    <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;bundle.js&#x27;</span>,<br>    <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;./build&#x27;</span>),<br>    <span class="hljs-attr">publicPath</span>: <span class="hljs-string">&#x27;/page&#x27;</span>,<br>&#125;<br></code></pre></td></tr></table></figure><p>devServer 无相应配置, devServer 中的 publicPath 默认会使用 output 的 publicPath.</p><p>此时运行<code>webpack server</code>, 可以在浏览器看到拼接的文件路径, html 正常展示</p><p><img src="https://dev.azure.com/HealMSlin/8544be09-1224-4eb0-824b-90c4ec9d49ee/_apis/git/repositories/7a27a721-4c93-4ecf-8258-d5422217b60a/items?path=%2F1664697147057_929.png&amp;versionDescriptor%5BversionOptions%5D=0&amp;versionDescriptor%5BversionType%5D=0&amp;versionDescriptor%5Bversion%5D=master&amp;resolveLfs=true&amp;%24format=octetStream&amp;api-version=5.0" alt="" /></p><p>使用相对路径, 真正打包到文件系统时才建议使用相对路径, 因为打包到文件系统后浏览器打开是<code>file://</code>协议, 如果使用的是绝对路径拼接后就变成<code>file:///bundle.js</code>, 找不到对应文件.<br /><img src="https://dev.azure.com/HealMSlin/8544be09-1224-4eb0-824b-90c4ec9d49ee/_apis/git/repositories/7a27a721-4c93-4ecf-8258-d5422217b60a/items?path=%2F1664422677000_2677.png&amp;versionDescriptor%5BversionOptions%5D=0&amp;versionDescriptor%5BversionType%5D=0&amp;versionDescriptor%5Bversion%5D=master&amp;resolveLfs=true&amp;%24format=octetStream&amp;api-version=5.0" alt="" /></p><p>实际上, 生产环境下更多的也也是使用 CDN 域名前缀, 而不是相对路径.</p><p>开发环境下要用相对路径也可以用, 只是会徒增心智负担.<br />output 中 publicPath 使用相对路径时, <strong>devServer 中必须配置绝对路径</strong>, 原因后续解释, 先看下不这样做的后果, 先将 devServer 注释掉:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">output</span>: &#123;<br>    <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;bundle.js&#x27;</span>,<br>    <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;./build&#x27;</span>),<br>    <span class="hljs-attr">publicPath</span>: <span class="hljs-string">&#x27;./&#x27;</span>,<br>&#125;,<br><span class="hljs-attr">devServer</span>: &#123;<br>    <span class="hljs-attr">hot</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">devMiddleware</span>: &#123;<br>      <span class="hljs-comment">// publicPath: &#x27;/&#x27;</span><br>    &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><p>重新执行<code>webpack serve</code>, 浏览器显示:</p><p><img src="https://dev.azure.com/HealMSlin/8544be09-1224-4eb0-824b-90c4ec9d49ee/_apis/git/repositories/7a27a721-4c93-4ecf-8258-d5422217b60a/items?path=%2F1664697803627_9616.png&amp;versionDescriptor%5BversionOptions%5D=0&amp;versionDescriptor%5BversionType%5D=0&amp;versionDescriptor%5Bversion%5D=master&amp;resolveLfs=true&amp;%24format=octetStream&amp;api-version=5.0" alt="" /></p><p>将 devServer 的 publicPath 放开:</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs diff">output: &#123;<br>    filename: &#x27;bundle.js&#x27;,<br>    path: path.resolve(__dirname, &#x27;./build&#x27;),<br>    publicPath: &#x27;./&#x27;,<br>&#125;,<br>devServer: &#123;<br>    hot: true,<br>    devMiddleware: &#123;<br><span class="hljs-deletion">-      // publicPath: &#x27;/&#x27;</span><br><span class="hljs-addition">+      publicPath: &#x27;/&#x27;</span><br>    &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><p>执行<code>webpack serve</code>, 此时浏览器显示正常:</p><p><img src="https://dev.azure.com/HealMSlin/8544be09-1224-4eb0-824b-90c4ec9d49ee/_apis/git/repositories/7a27a721-4c93-4ecf-8258-d5422217b60a/items?path=%2F1664697915112_1455.png&amp;versionDescriptor%5BversionOptions%5D=0&amp;versionDescriptor%5BversionType%5D=0&amp;versionDescriptor%5Bversion%5D=master&amp;resolveLfs=true&amp;%24format=octetStream&amp;api-version=5.0" alt="" /></p><h4 id="in-devserver"><a class="markdownIt-Anchor" href="#in-devserver"></a> in devServer</h4><p>webpack5 中在 devServe 配置 publicPath 和 webpack4 的区别:</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs diff">devServer: &#123;<br>  hot: true,<br><span class="hljs-deletion">- publicPath: &#x27;/&#x27;,</span><br><span class="hljs-addition">+ // webpack5</span><br><span class="hljs-addition">+ devMiddleware: &#123;</span><br><span class="hljs-addition">+   publicPath: &#x27;/&#x27;</span><br><span class="hljs-addition">+ &#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>前面说过, devServer 通过<code>memfs</code>在内存中创建了类似静态文件服务, 使内存中的文件能够正常通过 http 访问, 所以 devServer 中的 publicPath 相当于 http 请求获取静态文件所需的前缀, 这就解释了以下几个问题:</p><ul><li>devServer 的 publicPath 为什么最好和 output 的 publicPath 保持一致? 如果静态文件服务中文件路径为<code>/asset/bundle.js</code>, 而 html 中请求的文件路径为<code>/bundle.js</code>, 自然请求不到对应文件</li><li>devServer 的 publicPath 为什么不能为相对路径? http 请求链接的前缀又怎么能是相对路径呢?</li><li>为什么 devServer 的 publicPath 开头结尾都需要带上<code>/</code>, 我理解是为了相对路径服务的(如果有错请忽略), 如果 devServer 的 publicPath 配置的是<code>/asset</code>, output 的 publicPath 配置<code>./</code>, 请求会变为<code>/bundle.js</code>, 只有配置为<code>/asset/</code>时, 请求才是<code>/asset/bundle.js</code>正常返回.</li></ul><p>当然, 对于<code>HtmlWebpackPlugin</code>插件, <code>filename</code>选项也可以配置路径+文件, 配合 publicPath 的相对路径理解起来就更繁琐了.</p><h4 id="总结一下-publicpath"><a class="markdownIt-Anchor" href="#总结一下-publicpath"></a> 总结一下 publicPath</h4><p>使用 publicPath 遵循以下几点:</p><ol><li>devServer 的 publicPath 和 output 的 publicPath 推荐保持一致, 或者不配置 devServer 的 publicPath</li><li>开发环境配置 publicPath 最好开头结尾都带上<code>/</code>, 并且浏览器访问时也要结尾也要带上</li><li>开发环境下最好不要使用相对路径</li><li>如果打包产物根据文件类型需要不提供文件夹区分, 可以直接配置对应的 filename</li><li><s>配置 webpack.config.js 的时候你最好知道你在干什么</s></li></ol><h3 id="contentbase"><a class="markdownIt-Anchor" href="#contentbase"></a> ContentBase</h3><p>照例介绍下 webpack5 对 ContentBase 的 breaking change:</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs diff">devServer: &#123;<br><span class="hljs-deletion">-  contentBase: path.resolve(__dirname, &#x27;.yui&#x27;),</span><br><span class="hljs-addition">+  static: &#123;</span><br><span class="hljs-addition">+    directory: path.resolve(__dirname, &#x27;./yui&#x27;),</span><br><span class="hljs-addition">+  &#125;</span><br>&#125;,<br></code></pre></td></tr></table></figure><p>contentBase 比较好理解, 不是直接通过入口文件引入的文件, 或者是入口文件关联文件中又关联的文件, devServer 就会到 ContentBase 配置的文件目录下寻找. 举个例子:</p><p>在 html 文件中引入 js 文件,该文件和入口文件没有直接关系, 这里要使用绝对路径, 否则会通过 publicPath 查找:</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs diff">&lt;body&gt;<br>  &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;<br>  &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;<br><br><span class="hljs-addition">+ &lt;script src=&quot;/test.js&quot;&gt;&lt;/script&gt;</span><br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><p>并且新建<code>yui/test.js</code>文件, 添加输出:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;这是个Test文件&quot;</span>);<br></code></pre></td></tr></table></figure><p>首先注释掉 contentBase, <strong>contentBase 不能配置为&quot;&quot;</strong>, 运行<code>webpack serve</code>:</p><p><img src="https://dev.azure.com/HealMSlin/8544be09-1224-4eb0-824b-90c4ec9d49ee/_apis/git/repositories/7a27a721-4c93-4ecf-8258-d5422217b60a/items?path=%2F1664701555781_1130.png&amp;versionDescriptor%5BversionOptions%5D=0&amp;versionDescriptor%5BversionType%5D=0&amp;versionDescriptor%5Bversion%5D=master&amp;resolveLfs=true&amp;%24format=octetStream&amp;api-version=5.0" alt="" /></p><p>可以看到默认 contentBase 搜索的文件夹是 public, 浏览器显示:</p><p><img src="https://dev.azure.com/HealMSlin/8544be09-1224-4eb0-824b-90c4ec9d49ee/_apis/git/repositories/7a27a721-4c93-4ecf-8258-d5422217b60a/items?path=%2F1664701719247_6132.png&amp;versionDescriptor%5BversionOptions%5D=0&amp;versionDescriptor%5BversionType%5D=0&amp;versionDescriptor%5Bversion%5D=master&amp;resolveLfs=true&amp;%24format=octetStream&amp;api-version=5.0" alt="" /></p><p>然后将 contentBase 放开, 运行<code>webpack serve</code>:</p><p><img src="https://dev.azure.com/HealMSlin/8544be09-1224-4eb0-824b-90c4ec9d49ee/_apis/git/repositories/7a27a721-4c93-4ecf-8258-d5422217b60a/items?path=%2F1664701782697_3793.png&amp;versionDescriptor%5BversionOptions%5D=0&amp;versionDescriptor%5BversionType%5D=0&amp;versionDescriptor%5Bversion%5D=master&amp;resolveLfs=true&amp;%24format=octetStream&amp;api-version=5.0" alt="" /></p><p>可以看到显示正常了.</p><h2 id="devserver-其他的常用配置"><a class="markdownIt-Anchor" href="#devserver-其他的常用配置"></a> devServer 其他的常用配置</h2><h3 id="hotonly"><a class="markdownIt-Anchor" href="#hotonly"></a> hotOnly</h3><p>热更新时模块代码报错, 修复后默认会刷新页面; hotOnly 保证报错修复仍然是热更新.</p><p><strong>Breaking change</strong> webpack4 -&gt; webpack5:</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-  hotOnly: true,</span><br><span class="hljs-addition">+  hot: &#x27;only&#x27;, // hot: true</span><br></code></pre></td></tr></table></figure><h3 id="compress"><a class="markdownIt-Anchor" href="#compress"></a> compress</h3><p>请求的文件以 gzip 形式压缩后返回</p><h3 id="host"><a class="markdownIt-Anchor" href="#host"></a> host</h3><p>默认值为<code>localhost(127.0.0.1)</code>, 如果希望其他地方也可以访问, 可以设置为<code>0.0.0.0</code></p><h3 id="open"><a class="markdownIt-Anchor" href="#open"></a> open</h3><p>可以配置指定浏览器打开指定页面.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">open</span>: &#123;<br>  <span class="hljs-attr">target</span>: [<span class="hljs-string">&#x27;/asset/page/&#x27;</span>], <span class="hljs-comment">// open multiple pages</span><br>  <span class="hljs-attr">app</span>: &#123;<br><span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;google-chrome&#x27;</span>,<br>  &#125;<br>&#125;,<br><span class="hljs-comment">// or</span><br><span class="hljs-attr">open</span>: <span class="hljs-literal">true</span>,<br></code></pre></td></tr></table></figure><h3 id="historyapifallback"><a class="markdownIt-Anchor" href="#historyapifallback"></a> historyApiFallback</h3><p>这个比较重要, 在 React/Vue 这类生成 SPA 页面的框架中非常常见, 主要作用是解决 SPA 页面在路由跳转之后, 进行页面刷新时, 返回 404 错误的问题.<br /><strong>生产环境下通过 nginx 配置, historyApiFallback 相当于干了开发时 nginx 的活</strong></p><p>和 open 一样有两种方式配置, <code>boolean|object</code>.<br />boolean 值默认为<code>false</code>, <code>true</code>页面刷新 404 时跳转<code>/index.html</code>,<br />object 值可以配置 rewrites, 根据 404 匹配的路由跳转不同路径</p><p>举个例子, 具体源码查看[[#实例代码]].</p><p>先不配<code>historyApiFallback</code>, 查看 react 路由的跳转:</p><p>当前路径: <code>127.0.0.1/me</code></p><p>展示内容:<br /><img src="https://dev.azure.com/HealMSlin/8544be09-1224-4eb0-824b-90c4ec9d49ee/_apis/git/repositories/7a27a721-4c93-4ecf-8258-d5422217b60a/items?path=%2F1664726548640_9042.png&amp;versionDescriptor%5BversionOptions%5D=0&amp;versionDescriptor%5BversionType%5D=0&amp;versionDescriptor%5Bversion%5D=master&amp;resolveLfs=true&amp;%24format=octetStream&amp;api-version=5.0" alt="" /></p><p>刷新后 404, 因为并没有对应的路径或文件匹配<code>/me</code></p><p><img src="https://dev.azure.com/HealMSlin/8544be09-1224-4eb0-824b-90c4ec9d49ee/_apis/git/repositories/7a27a721-4c93-4ecf-8258-d5422217b60a/items?path=%2F1664726704031_2224.png&amp;versionDescriptor%5BversionOptions%5D=0&amp;versionDescriptor%5BversionType%5D=0&amp;versionDescriptor%5Bversion%5D=master&amp;resolveLfs=true&amp;%24format=octetStream&amp;api-version=5.0" alt="" /></p><p>配置<code>historyApiFallback</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">historyApiFallback</span>: &#123;<br>  <span class="hljs-attr">rewrites</span>: [&#123; <span class="hljs-attr">from</span>: <span class="hljs-regexp">/about|me/</span>, <span class="hljs-attr">to</span>: <span class="hljs-string">&#x27;/asset/page/&#x27;</span> &#125;],<br>&#125;,<br></code></pre></td></tr></table></figure><p>重新运行<code>webpack serve</code>, 再次刷新当前路由, 刷新也能够正常显示:</p><p><img src="https://dev.azure.com/HealMSlin/8544be09-1224-4eb0-824b-90c4ec9d49ee/_apis/git/repositories/7a27a721-4c93-4ecf-8258-d5422217b60a/items?path=%2F1664726866345_7520.png&amp;versionDescriptor%5BversionOptions%5D=0&amp;versionDescriptor%5BversionType%5D=0&amp;versionDescriptor%5Bversion%5D=master&amp;resolveLfs=true&amp;%24format=octetStream&amp;api-version=5.0" alt="" /></p><h3 id="proxy"><a class="markdownIt-Anchor" href="#proxy"></a> proxy</h3><p>这里不做过多解释了, 具体配置可以查阅<a href="https://webpack.js.org/configuration/dev-server/#devserverproxy">官网</a>. 作用主要还是用于解决跨域问题, 不考虑服务端已经对 resHeader 做了跨域处理. 这里列出常用的配置, 使用可以参考[[#示例代码]]:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">devServer</span>: &#123;<br>  <span class="hljs-comment">//...</span><br>  <span class="hljs-attr">proxy</span>: &#123;<br>    <span class="hljs-string">&quot;/api&quot;</span>: &#123;<br>      <span class="hljs-attr">target</span>: <span class="hljs-string">&quot;http://localhost:8888&quot;</span>,<br>      <span class="hljs-attr">pathRewrite</span>: &#123;<br>        <span class="hljs-string">&quot;^/api&quot;</span>: <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-comment">// 正则替换, replace(/^api/, &#x27;&#x27;);</span><br>      &#125;,<br>      <span class="hljs-attr">secure</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 忽略https验证</span><br>      <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">//修改Origin为localhost:8888</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>未配置 proxy 前, 浏览器在<code>http://localhost:8080/asset/page/</code>发起跨域请求:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;http://localhost:8888/name&quot;</span>);<br></code></pre></td></tr></table></figure><p>毫无意外浏览器会拦截:</p><p><img src="https://dev.azure.com/HealMSlin/8544be09-1224-4eb0-824b-90c4ec9d49ee/_apis/git/repositories/7a27a721-4c93-4ecf-8258-d5422217b60a/items?path=%2F1664977295429_8174.png&amp;versionDescriptor%5BversionOptions%5D=0&amp;versionDescriptor%5BversionType%5D=0&amp;versionDescriptor%5Bversion%5D=master&amp;resolveLfs=true&amp;%24format=octetStream&amp;api-version=5.0" alt="" /></p><p>配置 proxy 后, 修改请求为:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;/api/name&quot;</span>);<br></code></pre></td></tr></table></figure><p>浏览器可以正常返回数据:</p><p><img src="https://dev.azure.com/HealMSlin/8544be09-1224-4eb0-824b-90c4ec9d49ee/_apis/git/repositories/7a27a721-4c93-4ecf-8258-d5422217b60a/items?path=%2F1664977379895_4155.png&amp;versionDescriptor%5BversionOptions%5D=0&amp;versionDescriptor%5BversionType%5D=0&amp;versionDescriptor%5Bversion%5D=master&amp;resolveLfs=true&amp;%24format=octetStream&amp;api-version=5.0" alt="" /></p><p>如果对 nginx 有所了解就会发现, devServer 的 proxy 和 historyApiFallback 其实就是充当了生产环境下的 nginx 配置.</p><h2 id="resolve"><a class="markdownIt-Anchor" href="#resolve"></a> resolve</h2><p>resolve 主要是对 import from 的路径做处理, 介绍下 resolve 对象中常用的几个属性.</p><h3 id="modules"><a class="markdownIt-Anchor" href="#modules"></a> modules</h3><p>默认值: <code>node_modules</code><br />引入模块的路径分为绝对路径, 相对路径, 模块路径; 绝对路径和相对路径容易理解, 就是根据文件系统或上下文目录查找; 模块路径则是只指定了包名, webpack 会通过<code>resolve.modules</code>指定的目录去查找文件, webpack 是通过<strong>enhanced-resolve</strong>库来进行模块路径查找.</p><h3 id="extensions"><a class="markdownIt-Anchor" href="#extensions"></a> extensions</h3><p>默认值: <code>['.js', '.json', '.wasm']</code><br />当 webpack 发现当前路径是文件并且没有后缀名时, 会使用<code>resolve.extensions</code>匹配, 所以对于 React/Vue 这类文件后缀为.jsx/.vue 的路径, 如果不带上后缀默认是会解析失败的, 需要配置:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">resolve</span>: &#123;<br>  <span class="hljs-attr">extensions</span>: [<span class="hljs-string">&quot;.js&quot;</span>, <span class="hljs-string">&quot;.json&quot;</span>, <span class="hljs-string">&quot;.wasm&quot;</span>, <span class="hljs-string">&quot;.jsx&quot;</span>, <span class="hljs-string">&quot;.vue&quot;</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="mainfiles"><a class="markdownIt-Anchor" href="#mainfiles"></a> mainFiles</h3><p>默认值: <code>index</code><br />当 webpack 发现当前路径是文件夹时, 会将<strong>resolve.mainFiles</strong>补充在路径后面, 然后通过<strong>resolve.extensions</strong>匹配文件.</p><h3 id="alias"><a class="markdownIt-Anchor" href="#alias"></a> alias</h3><p>type: <code>object</code><br />当路径使用频率高并且长时, 可以配置<code>resolve.alias</code>简化输入, Vue 脚手架就将<code>@</code>作为<code>path.resolve(__dirname, './src')</code>的别名.</p><h1 id="实例代码"><a class="markdownIt-Anchor" href="#实例代码"></a> 实例代码</h1><p><a href="https://github.com/Mariana-Yui/fe-learn-code/tree/main/learn-webpack/day7">https://github.com/Mariana-Yui/fe-learn-code/tree/main/learn-webpack/day7</a></p><h1 id="reference"><a class="markdownIt-Anchor" href="#reference"></a> reference</h1><ol><li><a href="https://zhuanlan.zhihu.com/p/30669007">Webpack HMR 原理解析</a></li><li><a href="https://github.com/facebook/react/issues/16604">How should we set up apps for HMR now that Fast Refresh replaces react-hot-loader?</a></li><li><a href="https://github.com/pmmmwh/react-refresh-webpack-plugin">React 热更新依赖</a></li><li><a href="https://blog.csdn.net/qq_43048301/article/details/121554459">Webpack5 中 devServer 配置 contentBase 报错的问题</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>webpack</category>
      
    </categories>
    
    
    <tags>
      
      <tag>webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pm2线上问题处理记录</title>
    <link href="/2022/09/27/2022-09-27-pm2-online-issue-record/"/>
    <url>/2022/09/27/2022-09-27-pm2-online-issue-record/</url>
    
    <content type="html"><![CDATA[<h1 id="背景"><a class="markdownIt-Anchor" href="#背景"></a> 背景</h1><p>线上机器存在两个 pm2 部署的系统服务, 由于 pm2 默认输出到<code>pm2-out.log</code>文件中, 系统运行了一年多这个文件已经几十 G 了, 查询日志定位问题时 grep 速度极慢…所以想法是修改输出日志文件到新文件中, 并对其做日志切割.</p><h1 id="具体实现"><a class="markdownIt-Anchor" href="#具体实现"></a> 具体实现</h1><h2 id="更换日志输出文件"><a class="markdownIt-Anchor" href="#更换日志输出文件"></a> 更换日志输出文件</h2><p>pm2 默认通过<code>ecosystem.config.json</code>进行各种配置, 这里对输出的文件进行修改</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">apps</span>: [<br>    &#123;<br>      <span class="hljs-comment">// ...other configs</span><br>      <span class="hljs-attr">error_file</span>: <span class="hljs-string">&quot;../logs/pm2-error-new.log&quot;</span>,<br>      <span class="hljs-attr">out_file</span>: <span class="hljs-string">&quot;../logs/pm2-out-new.log&quot;</span>,<br>      <span class="hljs-attr">log_file</span>: <span class="hljs-string">&quot;../logs/pm2-app-new.log&quot;</span>,<br>    &#125;,<br>  ],<br>&#125;;<br></code></pre></td></tr></table></figure><p>需要杀死当前服务的进程</p><p><code>pm2 delete &lt;id|name&gt;</code></p><p>不能只是<code>stop</code>, 更新的配置不会生效, 然后</p><p><code>pm2 start ecosystem.config.js</code></p><p>logs 下新文件成功生成了<br /><img src="https://dev.azure.com/HealMSlin/8544be09-1224-4eb0-824b-90c4ec9d49ee/_apis/git/repositories/7a27a721-4c93-4ecf-8258-d5422217b60a/items?path=%2F1664263425495_9764.png&amp;versionDescriptor%5BversionOptions%5D=0&amp;versionDescriptor%5BversionType%5D=0&amp;versionDescriptor%5Bversion%5D=master&amp;resolveLfs=true&amp;%24format=octetStream&amp;api-version=5.0" alt="" /></p><h2 id="日志切割"><a class="markdownIt-Anchor" href="#日志切割"></a> 日志切割</h2><p>这里使用 pm2 提供的日志切割插件<code>pm2-logrotate</code>, 可以设置默认的日志大小阈值, 日志文件日期格式, 进程轮询日志大小时间间隔, cron 定时任务等.</p><p>安装: <code>pm2 install pm2-logrotate</code></p><p>修改配置: <code>pm2 set pm2-logrotate:&lt;paramName&gt; &lt;value&gt;</code></p><p>查看插件配置: <code>pm2 conf pm2-logrotate</code></p><p>以下为我设置的<code>pm2-logrotate</code>配置:</p><p><img src="https://dev.azure.com/HealMSlin/8544be09-1224-4eb0-824b-90c4ec9d49ee/_apis/git/repositories/7a27a721-4c93-4ecf-8258-d5422217b60a/items?path=%2F1664263834486_4617.png&amp;versionDescriptor%5BversionOptions%5D=0&amp;versionDescriptor%5BversionType%5D=0&amp;versionDescriptor%5Bversion%5D=master&amp;resolveLfs=true&amp;%24format=octetStream&amp;api-version=5.0" alt="" /></p><h2 id="线上处理"><a class="markdownIt-Anchor" href="#线上处理"></a> 线上处理</h2><p>在开发机 devServer 上验证时畅通无阻, 但在线上机器测试时又是一番波折.</p><ul><li>Q: 线上机器执行<code>pm2 list</code>时没有输出</li></ul><p><img src="https://dev.azure.com/HealMSlin/8544be09-1224-4eb0-824b-90c4ec9d49ee/_apis/git/repositories/7a27a721-4c93-4ecf-8258-d5422217b60a/items?path=%2F1664264213113_3713.png&amp;versionDescriptor%5BversionOptions%5D=0&amp;versionDescriptor%5BversionType%5D=0&amp;versionDescriptor%5Bversion%5D=master&amp;resolveLfs=true&amp;%24format=octetStream&amp;api-version=5.0" alt="" /></p><ul><li>A: 最开始部署服务以及发版本重启服务时都是以 root 权限执行的<code>pm2 start</code>, 这导致申请普通权限的我并没有查看 root 用户进程的权限; 在申请 root 权限并执行<code>sudo su</code>后可以正常输出</li></ul><p><img src="https://dev.azure.com/HealMSlin/8544be09-1224-4eb0-824b-90c4ec9d49ee/_apis/git/repositories/7a27a721-4c93-4ecf-8258-d5422217b60a/items?path=%2F1664264308893_9536.png&amp;versionDescriptor%5BversionOptions%5D=0&amp;versionDescriptor%5BversionType%5D=0&amp;versionDescriptor%5Bversion%5D=master&amp;resolveLfs=true&amp;%24format=octetStream&amp;api-version=5.0" alt="" /></p><ul><li>Q: 线上机器 pm2 部署了两个服务, 但是<code>pm2 list</code>只输出一个</li><li>A: 查看两个服务的重启脚本文件后, 发现<code>PM2_HOME</code>环境变量, 用于在同一台机器上生成多个 pm2 实例, 类似于命名空间,不同实例之间相互隔离, 默认使用相同的<code>PM2_HOME</code></li></ul><p>设置<code>PM2_HOME</code>启动:</p><p><code>pm2 start PM2_HOME=$(pwd)/_pm2</code></p><p>或先暴露环境变量, 然后再启动:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">export</span> PM2_HOME=$(<span class="hljs-built_in">pwd</span>)/_pm2<br>pm2 start<br><span class="hljs-built_in">export</span> PM2_HOME=<span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-comment"># 清除变量</span><br></code></pre></td></tr></table></figure><p>在不同<code>PM2_HOME</code>下都能够看到 pm2 对应的服务了<br /><img src="https://dev.azure.com/HealMSlin/8544be09-1224-4eb0-824b-90c4ec9d49ee/_apis/git/repositories/7a27a721-4c93-4ecf-8258-d5422217b60a/items?path=%2F1664264837766_3422.png&amp;versionDescriptor%5BversionOptions%5D=0&amp;versionDescriptor%5BversionType%5D=0&amp;versionDescriptor%5Bversion%5D=master&amp;resolveLfs=true&amp;%24format=octetStream&amp;api-version=5.0" alt="" /></p><p><strong>参考资料 no.4 深入介绍了 copytruncate 机制的 pm2-logrotate 和 sign 机制的 egg-logrotator, 有兴趣的可以看看~</strong></p><h1 id="reference"><a class="markdownIt-Anchor" href="#reference"></a> reference</h1><ol><li><a href="https://pm2.keymetrics.io/docs/usage/specifics/">Multiple PM2 on the save server</a></li><li><a href="https://www.cnblogs.com/daner1257/p/10763888.html">pm2 日志管理 pm2-logrotate 介绍</a></li><li><a href="https://github.com/keymetrics/pm2-logrotate">pm2-logrotate</a></li><li><a href="https://juejin.cn/post/6844904151588012039">Node.js 应用日志切割原理与踩坑实践</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>nodejs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>nodejs</tag>
      
      <tag>pm2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webpack学习笔记(6)</title>
    <link href="/2022/09/23/2022-09-23-study-webpack-day6/"/>
    <url>/2022/09/23/2022-09-23-study-webpack-day6/</url>
    
    <content type="html"><![CDATA[<h1 id="学习笔记"><a class="markdownIt-Anchor" href="#学习笔记"></a> 学习笔记</h1><h2 id="babel"><a class="markdownIt-Anchor" href="#babel"></a> babel</h2><p>ES6+新出现的语法, 数据类型, 类, API 等, 对于不支持 ES6 的旧浏览器, 就需要 babel 将代码编译成 ES5 代码.</p><p>不管在什么工具下使用 babel 都必须安装 core 包文件:</p><p><code>yarn add @babel-core</code></p><p>在终端使用 babel, 将 src 文件夹下的源文件编译输出到 result 文件夹下:</p><p><code>npx babel src --out-dir result</code></p><p>不使用任何插件的情况下 babel 什么都不会做, 下面使用插件举例:</p><p>安装处理箭头函数插件: <code>yarn add -D @babel/plugin-transform-arrow-functions</code>,</p><p>安装处理 const,let 插件: <code>yarn add -D @babel/plugin-transform-block-scoping</code>,</p><p><code>npx babel src --out-dir result --plugins=@babel/plugin-transform-arrow-functions,@babel/plugin-transform-block-scoping</code></p><p>编译结果:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-meta">&quot;use strict&quot;</span>;<br><span class="hljs-keyword">var</span> message = <span class="hljs-string">&quot;Hello world&quot;</span>;<br><span class="hljs-keyword">var</span> foo = <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name);<br>&#125;;<br><br><span class="hljs-title function_">foo</span>(message);<br></code></pre></td></tr></table></figure><p>如果要使用其他插件可以在–plugins 后添加<br />一个一个安装插件的方式不是很方便, babel 提供了了<code>@babel/preset-env</code>包预设了会使用的 plugins, 安装:</p><p><code>yarn add -D @babel/preset-env</code></p><p>使用: <code>npx babel src --out-dir --presets=@babel/preset-env</code></p><h2 id="babel-原理"><a class="markdownIt-Anchor" href="#babel-原理"></a> babel 原理</h2><p>一张图介绍 babel 的底层原理, 可以通过[在线工具(<a href="https://esprima.org/demo/parse.html">https://esprima.org/demo/parse.html</a>)查看转换结果</p><pre><code class=" mermaid">graph TBA[ES6+源代码] --&gt; B[词法分析&lt;br&gt;Lexical Analysis]B --&gt; C[生成token数组]C --&gt; D[语法分析&lt;br&gt;Syntactic Analysis]D --&gt; E[生成AST抽象语法树]E --&gt; F[Traversal遍历]F --&gt; G[Visitor访问者]G --&gt; H[Plugins应用插件]H --&gt; I[new AST]I --&gt; J[目标代码]</code></pre><h2 id="babel-in-webpack"><a class="markdownIt-Anchor" href="#babel-in-webpack"></a> babel in webpack</h2><p><s>正常开发也不可能在命令行使用 babel</s><br />安装<code>babel-loader</code>: <code>yarn add -D babel-loader</code><br /><code>babel-loader</code>和<code>@babel/cli</code>一样都是特定工具下使用时需要安装的包文件.<br />babel 在 webpack.config.js 中配置, <strong>这里注意<code>exclude: /node_modules/</code>, 如果 babel 处理 node_modules 中的文件很有可能报错</strong>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">rules</span>: [<br>      &#123;<br>        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.js$/i</span>,<br>        <span class="hljs-attr">exclude</span>: <span class="hljs-regexp">/node_modules/</span>,<br>        <span class="hljs-attr">use</span>: &#123;<br>          <span class="hljs-attr">loader</span>: <span class="hljs-string">&#x27;babel-loader&#x27;</span>,<br>          <span class="hljs-attr">options</span>: &#123;<br>            <span class="hljs-comment">// plugins: [&#x27;@babel/plugin-transform-arrow-functions&#x27;, &#x27;@babel/plugin-transform-block-scoping&#x27;],</span><br>            <span class="hljs-attr">presets</span>: [<br>              [<span class="hljs-string">&#x27;@babel/preset-env&#x27;</span>, &#123;<br>                <span class="hljs-comment">// targets: [&quot;chrome 88&quot;],</span><br>                <span class="hljs-comment">// enmodules: true,</span><br>              &#125;]<br>            ]<br>          &#125;,<br>        &#125;,<br>      &#125;,<br>    ],<br></code></pre></td></tr></table></figure><p>可以看到和命令行使用非常类似, 不过是使用了 js 对象, 这里就直接使用预设<code>@babel/preset-env</code>, 这里不推荐在 presets 中配置 target, 建议和 postcss 等工具一起通过<code>.browserslistrc</code>配置兼容的浏览器范围.</p><p>现在 babel 最新版本为 7.x, 如果旧项目使用的是 babel7 之前的大版本, 经常会看到</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">presets</span>: [[<span class="hljs-string">&quot;es2015&quot;</span>], [<span class="hljs-string">&quot;react&quot;</span>], [<span class="hljs-string">&quot;stage-1&quot;</span>]];<br></code></pre></td></tr></table></figure><p>babel7 开始已经不建议使用, stage-x, es20xx 已废弃, 替换为<code>@babel/preset-env</code>; react 替换为<code>@babel/preset-react</code></p><p>像 postcss 可以单独配置 postcss.config.js 文件一样, babel 也可以单独配置, 文件命名: <code>babel.config.[json|js|cjs|mjs] | .babelrc[.json|.js|.cjs|mjs</code>, 后续都会在 babel.config.js 中修改.</p><p>配置:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-comment">// plugins: [],</span><br>  <span class="hljs-attr">presets</span>: [[<span class="hljs-string">&quot;@babel/preset-env&quot;</span>]],<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="polyfill"><a class="markdownIt-Anchor" href="#polyfill"></a> polyfill</h3><p>babel 默认只处理语法相关, 当我们使用新特性, 数据类型, 类或者 API(例如 Promise, Generator, Symbol, API 如 Array.prototype.includes), 就需要使用 polyfill</p><p>在 babel7.4 之后就不建议使用<code>@babel-polyfill</code>, 推荐使用<code>core-js</code>和<code>regenerator-runtime</code>, 安装:<br /><code>yarn add core-js regenerator-runtime</code></p><p>然后在 babel.config.js 中配置:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">presets</span>: [<br>    [<br>      <span class="hljs-string">&quot;@babel/preset-env&quot;</span>,<br>      &#123;<br>        <span class="hljs-attr">useBuiltIns</span>: <span class="hljs-string">&quot;usage&quot;</span>,<br>        <span class="hljs-attr">corejs</span>: <span class="hljs-number">3</span>, <span class="hljs-comment">// 必须填默认corejs: 2会报错</span><br>      &#125;,<br>    ],<br>  ],<br>&#125;;<br></code></pre></td></tr></table></figure><p>useBuiltIns:</p><ul><li>默认为<code>false</code>, 不引入任何 polyfill 逻辑, 即还是只处理语法;</li><li><code>'usage'</code>, 分析源代码中需要的 polyfill 以及<code>.browserslistrc</code>涉及的浏览器是否支持该 polyfill 按需引入</li><li><code>'entry'</code>, 需要手动在入口文件顶部引入以下包, 然后根据<code>.browserslistrc</code>引入剩余不支持的所有 polyfill, 因为引入的所有的包, 响应的打包体积会变大.</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;core-js/stable&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;regenerator-runtime/runtime&quot;</span>;<br></code></pre></td></tr></table></figure><p>corejs:<br />babel 默认使用 corejs 为<code>2</code>, 但是安装的最新<code>@babel/core</code>版本为 3.x, 所以需要修改 corejs 为<code>3</code>, 也可以具体到小版本<code>3.8</code>.</p><h4 id="babelplugin-transform-runtime"><a class="markdownIt-Anchor" href="#babelplugin-transform-runtime"></a> @babel/plugin-transform-runtime</h4><p>polyfill 默认情况下添加的所有特性都是全局的, 如果编写第三方库需要使用 polyfill 就有可能污染全局作用域, 为了解决这个问题需要安装<code>@babel/plugin-transform-runtime</code>来添加 polyfill.</p><p>关于<code>useBuiltIns</code>和<code>@babel/plugin-transform-runtime</code>的区别, babel 开发人员做出了回答<a href="https://github.com/babel/babel/issues/10271">https://github.com/babel/babel/issues/10271</a>:</p><blockquote><p>useBuiltIns and @babel/plugin-transform-runtime are mutually exclusive. Both are used to add polyfills: the first adds them globally, the second one adds them without attatching them to the global scope.<br />You should decide which behavior you want and stick with it.</p></blockquote><p>根据自己的场景使用<code>useBuiltIns</code>还是<code>@babel/plugin-transform-runtime</code>.</p><h3 id="babel-with-react"><a class="markdownIt-Anchor" href="#babel-with-react"></a> babel with react</h3><p>react 脚手架就是通过<code>@babel/preset-react</code>来解析 JSX 文件的, 用一个简单的 demo 介绍下 babel 在 react 中的使用.</p><p><code>babel.config.js</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">presets</span>: [<br>    [<br>      <span class="hljs-string">&quot;@babel/preset-env&quot;</span>,<br>      &#123;<br>        <span class="hljs-attr">useBuiltIns</span>: <span class="hljs-string">&quot;usage&quot;</span>,<br>        <span class="hljs-attr">corejs</span>: <span class="hljs-number">3</span>,<br>      &#125;,<br>    ],<br>    [<span class="hljs-string">&quot;@babel/preset-react&quot;</span>],<br>  ],<br>&#125;;<br></code></pre></td></tr></table></figure><p><code>index.jsx</code>:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; <span class="hljs-title class_">Component</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">ReactDOM</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-dom&quot;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Home</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Hello World<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Home</span> /&gt;</span></span>, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;app&quot;</span>));<br></code></pre></td></tr></table></figure><p><code>template.html</code>:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Day6 p2<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>打包结果:<br /><img src="https://dev.azure.com/HealMSlin/8544be09-1224-4eb0-824b-90c4ec9d49ee/_apis/git/repositories/7a27a721-4c93-4ecf-8258-d5422217b60a/items?path=%2F1663921580712_5592.png&amp;versionDescriptor%5BversionOptions%5D=0&amp;versionDescriptor%5BversionType%5D=0&amp;versionDescriptor%5Bversion%5D=master&amp;resolveLfs=true&amp;%24format=octetStream&amp;api-version=5.0" alt="" /></p><p>可以看到正常展示了.</p><h1 id="示例代码"><a class="markdownIt-Anchor" href="#示例代码"></a> 示例代码</h1><p><a href="https://github.com/Mariana-Yui/fe-learn-code/tree/main/learn-webpack/day6">https://github.com/Mariana-Yui/fe-learn-code/tree/main/learn-webpack/day6</a></p><h1 id="reference"><a class="markdownIt-Anchor" href="#reference"></a> reference</h1><p><a href="https://esprima.org/demo/parse.html#">babel 在线词法分析/语法分析</a><br /><a href="https://juejin.cn/post/6844903992762318855">前端 Javascript: Babel 怎么把字符串解析成 AST，是怎么进行词法/语法分析的？</a></p>]]></content>
    
    
    <categories>
      
      <category>webpack</category>
      
    </categories>
    
    
    <tags>
      
      <tag>webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webpack学习笔记(5)</title>
    <link href="/2022/09/15/2022-09-15-study-webpack-day5/"/>
    <url>/2022/09/15/2022-09-15-study-webpack-day5/</url>
    
    <content type="html"><![CDATA[<h1 id="学习笔记"><a class="markdownIt-Anchor" href="#学习笔记"></a> 学习笔记</h1><h2 id="mode-in-webpack-config"><a class="markdownIt-Anchor" href="#mode-in-webpack-config"></a> mode in webpack config</h2><p>使用:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">mode</span>: <span class="hljs-string">&quot;development&quot;</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><p>简单看下 webpack 官网对<code>mode</code>的描述:</p><table><thead><tr><th>option</th><th>description</th></tr></thead><tbody><tr><td><code>development</code></td><td>Sets <code>process.env.NODE_ENV</code> on <code>DefinePlugin</code> to value <code>development</code>.<br> Enables useful names for modules and chunks.</td></tr><tr><td><code>production</code></td><td>Sets <code>process.env.NODE_ENV</code> on <code>DefinePlugin</code> to value <code>production</code>.<br> Enables deterministic mangled names for modules and chunks,<br> <code>FlagDependencyUsagePlugin</code>, <code>FlagIncludedChunksPlugin</code>,<br> <code>ModuleConcatenationPlugin</code>, <code>NoEmitOnErrorsPlugin</code> and <code>TerserPlugin</code>.</td></tr><tr><td><code>none</code></td><td>Opts out of any default optimization options</td></tr></tbody></table><p>可以看到<code>mode</code>可以设置为<code>development</code>, <code>production</code>, <code>none</code>, 并且<code>development</code>和<code>production</code> 存在 webpack 预设的一些默认配置. 后面例子为特殊说明<code>mode</code>都为<code>development</code></p><h2 id="webpack-模块化原理"><a class="markdownIt-Anchor" href="#webpack-模块化原理"></a> webpack 模块化原理</h2><p>之前提到浏览器目前只能解析 ESM 模块(某些浏览器甚至无法解析模块), 需要添加<code>&lt;script type=&quot;module&quot;&gt;</code>, 但是通过 webpack 打包的代码, 允许 使用各种各样的模块化, AMD, CMD, CommonJS, ESModule 等, 它是如何帮助我们实现代码中支持模块化的呢? 这里以最常用的 CommonJS 和 ESModule 举例, 依次介绍 webpack 中:</p><ul><li>CommonJS 模块化实现原理</li><li>ES Module 模块化实现原理</li><li>CommonJS 加载 ES Module 原理</li><li>ES Module 加载 CommonJS 原理</li></ul><p>每种情况都会以简单案例讲解, 开始之前<code>webpack.config.js</code>先配置<code>devtool: &quot;source-map&quot;</code>, 因为<code>development</code>模式下打包默认使用<code>eval</code>, 不方便阅读打包产物代码, 具体含义后续介绍.</p><h3 id="iife-立即执行函数"><a class="markdownIt-Anchor" href="#iife-立即执行函数"></a> IIFE 立即执行函数</h3><p>产物中会出现大量立即执行函数, 存在多种写法, 可以先阅读<a href="https://segmentfault.com/a/1190000003902899">JavaScript 中的立即执行函数</a></p><h3 id="commonjs-模块化实现原理"><a class="markdownIt-Anchor" href="#commonjs-模块化实现原理"></a> CommonJS 模块化实现原理</h3><p>入口文件<code>index.js</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> &#123; dateFormat, prizeFormat &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./util/format&quot;</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">dateFormat</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">prizeFormat</span>(<span class="hljs-number">100</span>));<br></code></pre></td></tr></table></figure><p>引入模块文件:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">dateFormat</span>(<span class="hljs-params">date</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;2022-09-14&quot;</span>;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">prizeFormat</span>(<span class="hljs-params">prize</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;100.00&quot;</span>;<br>&#125;<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  dateFormat,<br>  prizeFormat,<br>&#125;;<br></code></pre></td></tr></table></figure><p>打包后的文件<code>bundle.js</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 立即执行函数建立作用域, 避免变量污染</span><br>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// 定义当前作用域下全局对象, 包含所有require引用的模块</span><br>  <span class="hljs-keyword">var</span> __webpack_modules__ = &#123;<br>    <span class="hljs-comment">// key为模块路径, 值为包含模块内容的函数</span><br>    <span class="hljs-string">&quot;./util/format.js&quot;</span>: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-variable language_">module</span></span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">function</span> <span class="hljs-title function_">dateFormat</span>(<span class="hljs-params">date</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;2022-09-14&quot;</span>;<br>      &#125;<br><br>      <span class="hljs-keyword">function</span> <span class="hljs-title function_">prizeFormat</span>(<span class="hljs-params">prize</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;100.00&quot;</span>;<br>      &#125;<br><br>      <span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>        dateFormat,<br>        prizeFormat,<br>      &#125;;<br>    &#125;,<br>  &#125;;<br>  <span class="hljs-comment">// 创建对象用于缓存</span><br>  <span class="hljs-keyword">var</span> __webpack_module_cache__ = &#123;&#125;;<br>  <span class="hljs-comment">// commonjs中require函数的polyfill实现</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">__webpack_require__</span>(<span class="hljs-params">moduleId</span>) &#123;<br>    <span class="hljs-comment">// 根据模块路径获取缓存中的模块内容</span><br>    <span class="hljs-keyword">var</span> cachedModule = __webpack_module_cache__[moduleId];<br>    <span class="hljs-comment">// 如果存在直接返回</span><br>    <span class="hljs-keyword">if</span> (cachedModule !== <span class="hljs-literal">undefined</span>) &#123;<br>      <span class="hljs-keyword">return</span> cachedModule.<span class="hljs-property">exports</span>;<br>    &#125;<br>    <span class="hljs-comment">// 缓存中不存在, 将module变量和在缓存中都初始化一个对象, 属性为exports</span><br>    <span class="hljs-keyword">var</span> <span class="hljs-variable language_">module</span> = (__webpack_module_cache__[moduleId] = &#123;<br>      <span class="hljs-attr">exports</span>: &#123;&#125;,<br>    &#125;);<br>    <span class="hljs-comment">// 将模块内容赋值给module, 从而得到module.exports, 后续能够从缓存中获取</span><br>    <span class="hljs-comment">// 实例中还没用到模块中引用其他模块的情况, 暂不讲解后两个参数</span><br>    __webpack_modules__[moduleId](<span class="hljs-variable language_">module</span>, <span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span>, __webpack_require__);<br>    <span class="hljs-comment">// 返回模块内容</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">var</span> __webpack_exports__ = &#123;&#125;;<br><br>  <span class="hljs-comment">// 立即执行函数输出结果</span><br>  (<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// 下面引用模块逻辑和打包前源码相同, 不做解释</span><br>    <span class="hljs-keyword">const</span> &#123; dateFormat, prizeFormat &#125; = <span class="hljs-title function_">__webpack_require__</span>(<span class="hljs-string">&quot;./util/format.js&quot;</span>);<br><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">dateFormat</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()));<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">prizeFormat</span>(<span class="hljs-number">100</span>));<br>  &#125;)();<br>&#125;)();<br></code></pre></td></tr></table></figure><p>打包后的所有逻辑都有对应的注释, 可以看到 webpack 通过<code>__webpack_modules__</code>对象存储模块路径和内容, <code>__webpack_module_cache__</code>对象缓存所有<code>module.exports</code>, <code>__webpack_require__</code>函数简单实现了 CommonJS 中<code>require</code></p><h3 id="esm-模块化实现原理"><a class="markdownIt-Anchor" href="#esm-模块化实现原理"></a> ESM 模块化实现原理</h3><p>入口文件<code>esm_index.js</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> math <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./util/math&quot;</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(math.<span class="hljs-title function_">sum</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(math.<span class="hljs-title function_">mul</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>));<br></code></pre></td></tr></table></figure><p>引入模块文件:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">a, b</span>) &#123;<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">mul</span>(<span class="hljs-params">a, b</span>) &#123;<br>  <span class="hljs-keyword">return</span> a * b;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  sum,<br>  mul,<br>&#125;;<br></code></pre></td></tr></table></figure><p>打包产物:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-string">&quot;use strict&quot;</span>;<br>  <span class="hljs-keyword">var</span> __webpack_modules__ = &#123;<br>    <span class="hljs-string">&quot;./util/math.js&quot;</span>: <span class="hljs-function">(<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-function">      __unused_webpack_module,</span></span><br><span class="hljs-params"><span class="hljs-function">      __webpack_exports__,</span></span><br><span class="hljs-params"><span class="hljs-function">      __webpack_require__</span></span><br><span class="hljs-params"><span class="hljs-function">    </span>) =&gt;</span> &#123;<br>      __webpack_require__.<span class="hljs-title function_">r</span>(__webpack_exports__);<br>      __webpack_require__.<span class="hljs-title function_">d</span>(__webpack_exports__, &#123;<br>        <span class="hljs-attr">default</span>: <span class="hljs-function">() =&gt;</span> __WEBPACK_DEFAULT_EXPORT__,<br>      &#125;);<br>      <span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">a, b</span>) &#123;<br>        <span class="hljs-keyword">return</span> a + b;<br>      &#125;<br><br>      <span class="hljs-keyword">function</span> <span class="hljs-title function_">mul</span>(<span class="hljs-params">a, b</span>) &#123;<br>        <span class="hljs-keyword">return</span> a * b;<br>      &#125;<br><br>      <span class="hljs-keyword">const</span> __WEBPACK_DEFAULT_EXPORT__ = &#123;<br>        sum,<br>        mul,<br>      &#125;;<br>    &#125;,<br>  &#125;;<br><br>  <span class="hljs-keyword">var</span> __webpack_module_cache__ = &#123;&#125;;<br>  <span class="hljs-comment">// 和commonjs打包结果类似, exports赋值, 写入缓存, 返回module.exports</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">__webpack_require__</span>(<span class="hljs-params">moduleId</span>) &#123;<br>    <span class="hljs-keyword">var</span> cachedModule = __webpack_module_cache__[moduleId];<br>    <span class="hljs-keyword">if</span> (cachedModule !== <span class="hljs-literal">undefined</span>) &#123;<br>      <span class="hljs-keyword">return</span> cachedModule.<span class="hljs-property">exports</span>;<br>    &#125;<br>    <span class="hljs-comment">// 缓存</span><br>    <span class="hljs-keyword">var</span> <span class="hljs-variable language_">module</span> = (__webpack_module_cache__[moduleId] = &#123;<br>      <span class="hljs-attr">exports</span>: &#123;&#125;,<br>    &#125;);<br>    <span class="hljs-comment">// exports复制</span><br>    __webpack_modules__[moduleId](<span class="hljs-variable language_">module</span>, <span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span>, __webpack_require__);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span>;<br>  &#125;<br><br>  (<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// define 这里</span><br>    __webpack_require__.<span class="hljs-property">d</span> = <span class="hljs-function">(<span class="hljs-params"><span class="hljs-built_in">exports</span>, definition</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> definition) &#123;<br>        <span class="hljs-comment">// 如果definition hasOwnProperty, module.exports没有该属性, 这里是default熟悉</span><br>        <span class="hljs-keyword">if</span> (<br>          __webpack_require__.<span class="hljs-title function_">o</span>(definition, key) &amp;&amp;<br>          !__webpack_require__.<span class="hljs-title function_">o</span>(<span class="hljs-built_in">exports</span>, key)<br>        ) &#123;<br>          <span class="hljs-comment">// 将__webpack_modules__中的属性代理到module.exports中, 和commonjs不同, 不是简单的复制</span><br>          <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(<span class="hljs-built_in">exports</span>, key, &#123;<br>            <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,<br>            <span class="hljs-attr">get</span>: definition[key],<br>          &#125;);<br>        &#125;<br>      &#125;<br>    &#125;;<br>  &#125;)();<br><br>  (<span class="hljs-function">() =&gt;</span> &#123;<br>    __webpack_require__.<span class="hljs-property">o</span> = <span class="hljs-function">(<span class="hljs-params">obj, prop</span>) =&gt;</span><br>      <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">hasOwnProperty</span>.<span class="hljs-title function_">call</span>(obj, prop);<br>  &#125;)();<br><br>  (<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// 给当前module.exports添加标识ESM属性</span><br>    __webpack_require__.<span class="hljs-property">r</span> = <span class="hljs-function">(<span class="hljs-params"><span class="hljs-built_in">exports</span></span>) =&gt;</span> &#123;<br>      <span class="hljs-comment">// 如果浏览器支持Symbol数据类型, 还会添加一个</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Symbol</span> !== <span class="hljs-string">&quot;undefined&quot;</span> &amp;&amp; <span class="hljs-title class_">Symbol</span>.<span class="hljs-property">toStringTag</span>) &#123;<br>        <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(<span class="hljs-built_in">exports</span>, <span class="hljs-title class_">Symbol</span>.<span class="hljs-property">toStringTag</span>, &#123; <span class="hljs-attr">value</span>: <span class="hljs-string">&quot;Module&quot;</span> &#125;);<br>      &#125;<br>      <span class="hljs-comment">// 添加__esModule属性</span><br>      <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(<span class="hljs-built_in">exports</span>, <span class="hljs-string">&quot;__esModule&quot;</span>, &#123; <span class="hljs-attr">value</span>: <span class="hljs-literal">true</span> &#125;);<br>    &#125;;<br>  &#125;)();<br><br>  <span class="hljs-comment">// 缓存对象</span><br>  <span class="hljs-keyword">var</span> __webpack_exports__ = &#123;&#125;;<br><br>  (<span class="hljs-function">() =&gt;</span> &#123;<br>    __webpack_require__.<span class="hljs-title function_">r</span>(__webpack_exports__);<br>    <span class="hljs-keyword">var</span> _util_math__WEBPACK_IMPORTED_MODULE_0__ =<br>      <span class="hljs-title function_">__webpack_require__</span>(<span class="hljs-string">&quot;./util/math.js&quot;</span>);<br>    <span class="hljs-comment">// 使用exports映射default对象的方法</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(_util_math__WEBPACK_IMPORTED_MODULE_0__[<span class="hljs-string">&quot;default&quot;</span>].<span class="hljs-title function_">sum</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>));<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(_util_math__WEBPACK_IMPORTED_MODULE_0__[<span class="hljs-string">&quot;default&quot;</span>].<span class="hljs-title function_">mul</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>));<br>  &#125;)();<br>&#125;)();<br></code></pre></td></tr></table></figure><p>可以看到其实和 commonjs 最大的区别是</p><ol><li>增加了 esmodule 属性标识</li><li>通过<code>Object.defineProperty</code>代理 module.exports 属性代替直接赋值</li><li><s>多了 default</s></li></ol><h3 id="混用-commonjs-和-esmodule"><a class="markdownIt-Anchor" href="#混用-commonjs-和-esmodule"></a> 混用 CommonJs 和 ESModule</h3><p>同时在项目中使用 CommonJS 和 ESModule 打包结果和上述大同小异, 可以直接示例代码中 esModule 文件夹下的打包产物, 这里不过多赘述.</p><h2 id="devtool-in-webpack"><a class="markdownIt-Anchor" href="#devtool-in-webpack"></a> devtool in webpack</h2><p>配置 devtool 能够帮助我们在程序报错更好地定位问题, webpack 中提供了 26 种 devtool 的值, 下面详细介绍.</p><p>mode 为<code>development</code>, devtool 默认值为<code>eval</code>;<br />mode 为<code>production</code>, devtool 默认值为(nond), 这里的 none 不是字符串, 表示没有该项配置;</p><h3 id="source-map"><a class="markdownIt-Anchor" href="#source-map"></a> source-map</h3><p>devtool 设置为<code>source-map</code>后, 打包产物会多出来一个<code>bundle.js.map</code>文件</p><p><img src="https://dev.azure.com/HealMSlin/8544be09-1224-4eb0-824b-90c4ec9d49ee/_apis/git/repositories/7a27a721-4c93-4ecf-8258-d5422217b60a/items?path=%2F1663606242302_6243.png&amp;versionDescriptor%5BversionOptions%5D=0&amp;versionDescriptor%5BversionType%5D=0&amp;versionDescriptor%5Bversion%5D=master&amp;resolveLfs=true&amp;%24format=octetStream&amp;api-version=5.0" alt="" /></p><p>并且在<code>bundle.js</code>最后会添加 source-map 链接</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span><span class="hljs-comment"># sourceMappingURL=bundle.js.map</span><br></code></pre></td></tr></table></figure><p>以下是 mode 为<code>production</code>, devtool 设置<code>source-map</code>生成的<code>bundle.js.map</code>内容:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;file&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;bundle.js&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;mappings&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;AASgB,IAAIA,SAAQ,CAACC,EAASC,KAAV,IAH1BC,QAAQC,IAFM,eAShBD,QAAQC,IAAIC&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;sources&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;webpack:///./src/index.js&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;sourcesContent&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-comment">/*源代码字符串*/</span><br>  <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;names&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;Promise&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;resolve&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;reject&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;console&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;log&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;abc&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;sourceRoot&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>每个字段含义如下:</p><ul><li>version：Source map 的版本，目前为 3。</li><li>file：转换后的文件名。</li><li>sourceRoot：转换前的文件所在的目录。如果与转换前的文件在同一目录，该项为空。</li><li>sources：转换前的文件。该项是一个数组，表示可能存在多个文件合并。有时也会包含 webpack 库中的文件</li><li>names：转换前的所有变量名和属性名。mode 为<code>development</code>时代码并没有进行混淆, 变量名和属性名都不变, names 为空数组</li><li>mappings：记录位置信息的字符串，记录原文件到打包文件的所有映射, 详情可以查阅<a href="https://www.ruanyifeng.com/blog/2013/01/javascript_source_map.html">阮一峰博客</a></li></ul><p>默认浏览器会开启 source-map, 配置如图:</p><p><img src="https://dev.azure.com/HealMSlin/8544be09-1224-4eb0-824b-90c4ec9d49ee/_apis/git/repositories/7a27a721-4c93-4ecf-8258-d5422217b60a/items?path=%2F1663847472517_2059.png&amp;versionDescriptor%5BversionOptions%5D=0&amp;versionDescriptor%5BversionType%5D=0&amp;versionDescriptor%5Bversion%5D=master&amp;resolveLfs=true&amp;%24format=octetStream&amp;api-version=5.0" alt="" /></p><p>在浏览器中可以看到 source-map 映射的源文件</p><p><img src="https://dev.azure.com/HealMSlin/8544be09-1224-4eb0-824b-90c4ec9d49ee/_apis/git/repositories/7a27a721-4c93-4ecf-8258-d5422217b60a/items?path=%2F1663847580783_1435.png&amp;versionDescriptor%5BversionOptions%5D=0&amp;versionDescriptor%5BversionType%5D=0&amp;versionDescriptor%5Bversion%5D=master&amp;resolveLfs=true&amp;%24format=octetStream&amp;api-version=5.0" alt="" /></p><h3 id="eval"><a class="markdownIt-Anchor" href="#eval"></a> eval</h3><p>JavaScript 原生支持的 eval 函数可以在结尾添加类似 source-map 的 sourceURL 用于打包前的源文件, 从而实现映射, 这也是<code>mode: &quot;development&quot;</code>的默认 devtool 配置, 但是这样的代码不方便阅读</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span><span class="hljs-comment"># sourceURL=webpack:///./src/index.js?</span><br></code></pre></td></tr></table></figure><h3 id="inline-source-map"><a class="markdownIt-Anchor" href="#inline-source-map"></a> inline-source-map</h3><p>不会再 source-map 文件, 而是以 base64 编码 inline 在打包产物 js 中</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span><span class="hljs-comment"># sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnVuZGxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1EQUFtRDs7QUFFbkQ7O0FBRUEsaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqIG5lY2Vzc2FyeSB3aGlsZSB1c2VCdWlsdEluczogJ2VudHJ5JyAqL1xuLy8gaW1wb3J0ICdjb3JlLWpzL3N0YWJsZSc7XG4vLyBpbXBvcnQgJ3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZSc7XG5cbmNvbnN0IG1lc3NhZ2UgPSAnSGVsbG8gd29ybGQnO1xuY29uc3QgZm9vID0gKG5hbWUpID0+IHtcbiAgY29uc29sZS5sb2cobmFtZSk7XG59O1xuXG5jb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge30pO1xuXG5mb28obWVzc2FnZSk7XG5cbmNvbnNvbGUubG9nKGFiYyk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9</span><br></code></pre></td></tr></table></figure><h3 id="eval-source-map"><a class="markdownIt-Anchor" href="#eval-source-map"></a> eval-source-map</h3><p>顾名思义, 会生成 eval 链接和 sourcep-map 链接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">//# </span><span class="language-bash">sourceMappingURL=data:application/json;charset=utf-8;<span class="hljs-built_in">base64</span>,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1EQUFtRDs7QUFFbkQ7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXguanM/YjYzNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiogbmVjZXNzYXJ5IHdoaWxlIHVzZUJ1aWx0SW5zOiAnZW50cnknICovXG4vLyBpbXBvcnQgJ2NvcmUtanMvc3RhYmxlJztcbi8vIGltcG9ydCAncmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lJztcblxuY29uc3QgbWVzc2FnZSA9ICdIZWxsbyB3b3JsZCc7XG5jb25zdCBmb28gPSAobmFtZSkgPT4ge1xuICBjb25zb2xlLmxvZyhuYW1lKTtcbn07XG5cbmNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7fSk7XG5cbmZvbyhtZXNzYWdlKTtcblxuY29uc29sZS5sb2coYWJjKTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//<span class="hljs-comment"># sourceURL=webpack-internal:///./src/index.js</span></span><br></code></pre></td></tr></table></figure><h3 id="cheap-source-map"><a class="markdownIt-Anchor" href="#cheap-source-map"></a> cheap-source-map</h3><p>source-map 对于报错信息会详细到某行某列, cheap-source-map 只会精细到行**(网上是这么说的, 虽然我验证的时候设置 source-map 或 cheap-source-map 好像没什么区别)**<br /><img src="https://dev.azure.com/HealMSlin/8544be09-1224-4eb0-824b-90c4ec9d49ee/_apis/git/repositories/7a27a721-4c93-4ecf-8258-d5422217b60a/items?path=%2F1663847377810_2941.png&amp;versionDescriptor%5BversionOptions%5D=0&amp;versionDescriptor%5BversionType%5D=0&amp;versionDescriptor%5Bversion%5D=master&amp;resolveLfs=true&amp;%24format=octetStream&amp;api-version=5.0" alt="" /></p><h3 id="cheap-module-source-map"><a class="markdownIt-Anchor" href="#cheap-module-source-map"></a> cheap-module-source-map</h3><p>如果源码经过 loader 例如 babel-loader 处理后, 使用 cheap-source-map 会链接到 loader 处理过的文件, 和源码还是有点区别的, 使用 cheap-module-source-map 就会正常指向源文件了.<br />这也是 react 官方脚手架本地环境下默认的 devtool 配置.</p><p><code>cheap-source-map</code>:</p><p><img src="https://dev.azure.com/HealMSlin/8544be09-1224-4eb0-824b-90c4ec9d49ee/_apis/git/repositories/7a27a721-4c93-4ecf-8258-d5422217b60a/items?path=%2F1663850502293_5513.png&amp;versionDescriptor%5BversionOptions%5D=0&amp;versionDescriptor%5BversionType%5D=0&amp;versionDescriptor%5Bversion%5D=master&amp;resolveLfs=true&amp;%24format=octetStream&amp;api-version=5.0" alt="" /></p><p><code>cheap-module-source-map</code>:</p><p><img src="https://dev.azure.com/HealMSlin/8544be09-1224-4eb0-824b-90c4ec9d49ee/_apis/git/repositories/7a27a721-4c93-4ecf-8258-d5422217b60a/items?path=%2F1663850594410_5564.png&amp;versionDescriptor%5BversionOptions%5D=0&amp;versionDescriptor%5BversionType%5D=0&amp;versionDescriptor%5Bversion%5D=master&amp;resolveLfs=true&amp;%24format=octetStream&amp;api-version=5.0" alt="" /></p><h3 id="hidden-source-map"><a class="markdownIt-Anchor" href="#hidden-source-map"></a> hidden-source-map</h3><p>会生成 source-map 文件, 但不会在 javascript 文件中链接, 一般用于前端错误信息上报, 后端通过错误中的行列信息还原出源文件的报错位置.</p><h3 id="nosources-source-map"><a class="markdownIt-Anchor" href="#nosources-source-map"></a> nosources-source-map</h3><p>使用 nosources 关键字生成的 source-map 文件中不包含 sourcesContent 内容, 因此调试时只能看到源文件的行列错误信息, 无法看到源码<br /><img src="https://dev.azure.com/HealMSlin/8544be09-1224-4eb0-824b-90c4ec9d49ee/_apis/git/repositories/7a27a721-4c93-4ecf-8258-d5422217b60a/items?path=%2F1663851512071_8530.png&amp;versionDescriptor%5BversionOptions%5D=0&amp;versionDescriptor%5BversionType%5D=0&amp;versionDescriptor%5Bversion%5D=master&amp;resolveLfs=true&amp;%24format=octetStream&amp;api-version=5.0" alt="" /></p><p>上面介绍了比较典型的几个 devtool 配置, 理解了每个关键字的含义也就知道如何配置了. 所有的 devtool 配置都是以下几个关键字的排列组合</p><p><code>[inline-|hidden-|eval][nosources-][cheap-[module-]][source-map]</code></p><p>下面给出不同环境下的最佳配置:</p><ul><li>开发/测试环境: <code>source-map</code> or <code>cheap-module-source-map</code></li><li>线上环境: false or 根据上报需求使用 hidden, nosources</li></ul><h1 id="示例代码"><a class="markdownIt-Anchor" href="#示例代码"></a> 示例代码</h1><p><a href="https://github.com/Mariana-Yui/fe-learn-code/tree/main/learn-webpack/day5">https://github.com/Mariana-Yui/fe-learn-code/tree/main/learn-webpack/day5</a></p><h1 id="reference"><a class="markdownIt-Anchor" href="#reference"></a> reference</h1><p><a href="https://segmentfault.com/a/1190000003902899">JavaScript 中的立即执行函数</a><br /><a href="https://juejin.cn/post/6960941899616092167">一文搞懂 SourceMap 以及 webpack devtool</a></p>]]></content>
    
    
    <categories>
      
      <category>webpack</category>
      
    </categories>
    
    
    <tags>
      
      <tag>webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webpack学习笔记(4)</title>
    <link href="/2022/09/09/2022-09-09-study-webpack-day4/"/>
    <url>/2022/09/09/2022-09-09-study-webpack-day4/</url>
    
    <content type="html"><![CDATA[<h1 id="学习笔记"><a class="markdownIt-Anchor" href="#学习笔记"></a> 学习笔记</h1><h2 id="plugin"><a class="markdownIt-Anchor" href="#plugin"></a> Plugin</h2><ul><li>Loader 是用于特定的模块类型进行转换</li><li>Plugin 则可以用于执行更加广泛的任务, 比如打包优化, 资源管理, 环境变量注入等功能, 你能想到的功能 plugin 应该都可以实现.</li></ul><p>所有 plugin 都会暴露出类, 通过实例化使用 plugin, 配置如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">plugins</span>: [<span class="hljs-keyword">new</span> <span class="hljs-title class_">CleanWebpackPlugin</span>(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>()],<br>&#125;;<br></code></pre></td></tr></table></figure><p>先介绍下常用的 plugin:</p><h3 id="cleanwebpackplugin"><a class="markdownIt-Anchor" href="#cleanwebpackplugin"></a> <code>CleanWebpackPlugin</code></h3><p>每次打包前将 output 的文件夹删除, webpack 打包产物会在产物目录下直接写入, 并不会自动删除</p><p>安装: <code>yarn add -D clean-webpack-plugin</code></p><p>使用: <code>const &#123; CleanWebpackPlugin &#125; = require('clean-webpack-plugin');</code></p><h3 id="htmlwebpackplugin"><a class="markdownIt-Anchor" href="#htmlwebpackplugin"></a> <code>HtmlWebpackPlugin</code></h3><p>之前打包产物并不包含 html 文件, 需要自己创建 html 文件并将打包产物 js,css 文件引入, 费时费力; 该插件用于在最终打包产物目录下生成 html 文件并进行资源的关联</p><p>安装: <code>yarn add -D html-webpack-plugin</code></p><p>使用: <code>const HtmlWebpackPlugin = require('html-webpack-plugin');</code></p><p>这里是否需要解构根据不同插件开发者习惯而定, 不必纠结.<br /><code>HtmlWebpackPlugin</code>插件内部内置了一个 ejs 模板, 打包时插件就会通过传入的变量对 ejs render 得到最后的 html 文件并写入构建产物目录中, 可以简单看下这个 ejs 文件:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>&lt;%= htmlWebpackPlugin.options.title %&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>同样的, 也可以自定义模板文件, vue, react 这类框架的脚手架就是这么干的; 通过 vue-cli 生成的项目的 html 模板文件在<code>public/index.html</code>下, 修改自定义模板文件配置:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>(&#123;<br>  <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;Mariana Blog&quot;</span>,<br>  <span class="hljs-attr">template</span>: <span class="hljs-string">&quot;./public/template.html&quot;</span>,<br>  <span class="hljs-attr">filename</span>: <span class="hljs-string">&quot;output.html&quot;</span>, <span class="hljs-comment">// 打包产物中html的文件名</span><br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="defineplugin"><a class="markdownIt-Anchor" href="#defineplugin"></a> <code>DefinePlugin</code></h3><p>允许在编译时创建配置的全局常量, webpack 内置插件(不需要单独安装)</p><p>使用: <code>const &#123; DefinePlugin &#125; = require('webpack');</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">DefinePlugin</span>(&#123;<br>  <span class="hljs-attr">BASE_URL</span>: <span class="hljs-string">&#x27;&quot;./&quot;&#x27;</span>,<br>&#125;);<br></code></pre></td></tr></table></figure><p>需要注意的一点是如果定义字符串<strong>不能省略引号</strong>, 可能是因为源码又进行 eval 等处理, 没具体看过源码, 只是猜测.</p><h3 id="copywebpackplugin"><a class="markdownIt-Anchor" href="#copywebpackplugin"></a> <code>CopyWebpackPlugin</code></h3><p>将文件夹中指定目录 copy 带打包产物中</p><p>安装: <code>yarn add -D copy-webpack-plugin</code></p><p>使用: <code>const CopyWebpackPlugin = require('webpack')</code></p><p>简单配置如下, 更多配置可以查阅官网</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">CopyWebpackPlugin</span>(&#123;<br>  <span class="hljs-attr">patterns</span>: [<br>    &#123;<br>      <span class="hljs-attr">from</span>: <span class="hljs-string">&quot;public&quot;</span>,<br>      <span class="hljs-attr">globOptions</span>: &#123;<br>        <span class="hljs-attr">ignore</span>: [<span class="hljs-string">&quot;**/template.html&quot;</span>, <span class="hljs-string">&quot;**/.DS_Store&quot;</span>],<br>      &#125;,<br>    &#125;,<br>  ],<br>&#125;);<br></code></pre></td></tr></table></figure><p>其中 globOption 通过<code>glob</code>库进行文件匹配, 需要添加<code>**</code>, 更多语法参考<a href="https://www.npmjs.com/package/glob">https://www.npmjs.com/package/glob</a></p><p>可以看到打包产物 public/下 include 的文件都复制到 build 中了<br /><img src="https://dev.azure.com/HealMSlin/8544be09-1224-4eb0-824b-90c4ec9d49ee/_apis/git/repositories/7a27a721-4c93-4ecf-8258-d5422217b60a/items?path=%2F1662993074608_764.png&versionDescriptor%5BversionOptions%5D=0&versionDescriptor%5BversionType%5D=0&versionDescriptor%5Bversion%5D=master&resolveLfs=true&%24format=octetStream&api-version=5.0" width="400" /></p><h1 id="示例代码"><a class="markdownIt-Anchor" href="#示例代码"></a> 示例代码</h1><p><a href="https://github.com/Mariana-Yui/fe-learn-code/tree/main/learn-webpack/day4">https://github.com/Mariana-Yui/fe-learn-code/tree/main/learn-webpack/day4</a></p>]]></content>
    
    
    <categories>
      
      <category>webpack</category>
      
    </categories>
    
    
    <tags>
      
      <tag>webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webpack学习笔记(3)</title>
    <link href="/2022/09/03/2022-09-03-study-webpack-day3/"/>
    <url>/2022/09/03/2022-09-03-study-webpack-day3/</url>
    
    <content type="html"><![CDATA[<h1 id="学习笔记"><a class="markdownIt-Anchor" href="#学习笔记"></a> 学习笔记</h1><h2 id="postcss"><a class="markdownIt-Anchor" href="#postcss"></a> postcss</h2><p>postcss 是通过 JavaScript 转换样式的工具, 可以帮助我们进行 css 的转换和适配, 比如添加浏览器前缀, reset css, 但是要实现这些功能需要 postcss 对应的插件, 单独使用 postcss 一般什么都干不了<br />所以如果要使用 postcss, 需要两步:</p><ol><li>查找对应插件, 比如 webpack 中的<code>post-loader</code></li><li>安装对应的 npm 包</li></ol><p>这里以通过命令行终端使用 postcss 对 css 自动加浏览器前缀举例 🌰</p><ol><li><code>yarn add postcss postcss-cli autoprefixer -D</code><br /><code>postcss</code>为工具, <code>postcss-cli</code>在终端可以使用, <code>autoprefixer</code>为自动加浏览器前缀的插件(必须安装)</li><li><code>npx postcss --use autoprefixer -o output.css ./entry.css</code><br />可以看到输出的<code>output.css</code>已经加上了浏览器前缀, 这里<code>autoprefixer</code>需要兼容的浏览器也是读取<code>browserslistrc</code></li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css">:-webkit-full-screen &#123;<br>&#125;<br><span class="hljs-selector-pseudo">:fullscreen</span> &#123;<br>&#125;<br><span class="hljs-selector-class">.content</span> &#123;<br>  -webkit-user-select: none;<br>  -moz-user-select: none;<br>  user-select: none;<br>&#125;<br></code></pre></td></tr></table></figure><p>也可以在线查看<code>autoprefixer</code>处理的结果: <a href="https://autoprefixer.github.io/">https://autoprefixer.github.io/</a></p><h3 id="use-in-webpack"><a class="markdownIt-Anchor" href="#use-in-webpack"></a> use in webpack</h3><p>在终端使用 postcss 需要安装<code>postcss-cli</code>, 同样的, 如果要在 webpack 中使用 postcss, 需要安装<code>postcss-loader</code>, <code>webpack.config.js</code>加上如下配置: 这时候就需要指定 options 了不能直接指定 loader</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// module.rules</span><br>&#123;<br>    <span class="hljs-string">&quot;test&quot;</span>: <span class="hljs-regexp">/\.s?css$/i</span>,<br>    <span class="hljs-string">&quot;use&quot;</span>: [<br>        <span class="hljs-string">&quot;style-loader&quot;</span>,<br>        <span class="hljs-string">&quot;css-loader&quot;</span>,<br>        &#123;<br>            <span class="hljs-string">&quot;loader&quot;</span>: <span class="hljs-string">&quot;postcss-loader&quot;</span>,<br>            <span class="hljs-string">&quot;options&quot;</span>: &#123;<br>                <span class="hljs-string">&quot;postcssOptions&quot;</span>: &#123;<br>                    <span class="hljs-string">&quot;plugins&quot;</span>: [<br>                        <span class="hljs-string">&quot;autoprefixer&quot;</span><br>                    ]<br>                &#125;<br>            &#125;<br>        &#125;,<br>        <span class="hljs-string">&quot;sass-loader&quot;</span><br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到重新打包后页面加上了浏览器前缀:<br /><img src="https://dev.azure.com/HealMSlin/8544be09-1224-4eb0-824b-90c4ec9d49ee/_apis/git/repositories/7a27a721-4c93-4ecf-8258-d5422217b60a/items?path=%2F1662195688318_7948.png&amp;versionDescriptor%5BversionOptions%5D=0&amp;versionDescriptor%5BversionType%5D=0&amp;versionDescriptor%5Bversion%5D=master&amp;resolveLfs=true&amp;%24format=octetStream&amp;api-version=5.0" alt="" /></p><h3 id="postcss-preset-env"><a class="markdownIt-Anchor" href="#postcss-preset-env"></a> postcss-preset-env</h3><blockquote><p><a href="https://github.com/csstools/postcss-plugins/tree/main/plugin-packs/postcss-preset-env">PostCSS Preset Env</a> lets you convert modern CSS into something most browsers can understand</p></blockquote><p>对于一些 css 写法, 比如<code>#12345678</code>,有的浏览器能够解析为 rgba, 有些浏览器无法解析导致不生效, 只用于添加浏览器前缀的<code>autoprefixer</code>就无法处理这种情况, 所以需要<code>postcss-preset-env</code>插件将其解析为大多数浏览器能够看懂的<code>rgba()</code>格式. 值得注意的是<code>postcss-preset-env</code>插件内置了<code>autoprefixer</code>, 所以使用<code>postcss-loader</code>时只需要引入<code>postcss-preset-env</code>即可.</p><h3 id="postcssconfigjs"><a class="markdownIt-Anchor" href="#postcssconfigjs"></a> postcss.config.js</h3><p>对于 css, sass, less, stylus 而言, rules 中 resources 匹配如果编写重复的 postcss 逻辑看起来是头大的, 这里可以创建<code>postcss.config.js</code>统一配置 options. <code>webpack.config.js</code>中<code>postcss-loader</code>就可以使用 string 了.<br />这里 plugins 中配置<code>postcss-preset-env</code>或<code>require('postcss-preset-env')</code>都是可以的, 除了部分插件用法<code>require('plugin-name')(...args)</code>不能传入 string 的形式</p><p>postcss.config.js:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">plugins</span>: [<span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;postcss-preset-env&quot;</span>)],<br>&#125;;<br></code></pre></td></tr></table></figure><p>webpack.config.js:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>    <span class="hljs-string">&quot;test&quot;</span>: <span class="hljs-regexp">/.s?css$/i</span>,<br>    <span class="hljs-string">&quot;use&quot;</span>: [<br>        <span class="hljs-string">&quot;style-loader&quot;</span>,<br>        <span class="hljs-string">&quot;css-loader&quot;</span>,<br>        <span class="hljs-string">&quot;postcss-loader&quot;</span>,<br>        <span class="hljs-string">&quot;sass-loader&quot;</span><br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到浏览器前缀和 css 特殊写法都能够被正常解析了:<br /><img src="https://dev.azure.com/HealMSlin/8544be09-1224-4eb0-824b-90c4ec9d49ee/_apis/git/repositories/7a27a721-4c93-4ecf-8258-d5422217b60a/items?path=%2F1662198290436_5913.png&amp;versionDescriptor%5BversionOptions%5D=0&amp;versionDescriptor%5BversionType%5D=0&amp;versionDescriptor%5Bversion%5D=master&amp;resolveLfs=true&amp;%24format=octetStream&amp;api-version=5.0" alt="" /></p><h3 id="importloaders"><a class="markdownIt-Anchor" href="#importloaders"></a> importLoaders</h3><p>如果 css 文件中<code>@import url(another.css)</code>, import 的 css 文件默认是不会被<code>css-loader</code>前执行的, 之前的 loader 只处理当前文件中的 css 样式, 所以这种情况需要在<code>css-loader</code>解析完后再返回让之前 loader 进行处理, 配置如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br><span class="hljs-attr">loader</span>: <span class="hljs-string">&#x27;css-loader&#x27;</span>,<br><span class="hljs-attr">options</span>: &#123;<br><span class="hljs-attr">importLoaders</span>: <span class="hljs-number">1</span>,<br>&#125;,<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="file-loader"><a class="markdownIt-Anchor" href="#file-loader"></a> file-loader</h3><p>处理 import/require()方式引入的文件资源, 打包时放到输出的文件夹中<br />首先安装 loader:<br /><code>yarn add -D file-loader</code><br />以图片资源举例, 默认没有使用<code>file-loader</code>时使用 import/require()引入资源会报错(backgrgound-image 形式是可以正常引入资源的)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable constant_">ERROR</span> <span class="hljs-keyword">in</span> ./img/girl.<span class="hljs-property">png</span> <span class="hljs-number">1</span>:<span class="hljs-number">0</span><br><span class="hljs-title class_">Module</span> parse <span class="hljs-attr">failed</span>: <span class="hljs-title class_">Unexpected</span> character <span class="hljs-string">&#x27;�&#x27;</span> (<span class="hljs-number">1</span>:<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>安装完后添加配置即可正常打包, webpack4 和 webpack5 下配置略有区别, 官方已经不建议在 webpack5 下使用<code>file_loader</code>,<code>url-loader</code>, 参考<a href="https://blog.csdn.net/qq_45770253/article/details/123862085">解决 webpack5 打包 css 背景图片问题</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 带+的为webpack5下需要新增的配置</span><br>&#123;<br>    <span class="hljs-string">&quot;test&quot;</span>: <span class="hljs-regexp">/.(gif|jpe?g|png)$/i</span>,<br>    <span class="hljs-string">&quot;use&quot;</span>: [<br>        &#123;<br>            <span class="hljs-string">&quot;loader&quot;</span>: <span class="hljs-string">&quot;file-loader&quot;</span>,<br>+            <span class="hljs-string">&quot;options&quot;</span>: &#123;<br>+                <span class="hljs-string">&quot;esModule&quot;</span>: <span class="hljs-literal">false</span><br>+            &#125;<br>        &#125;<br>    ],<br>+    <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;javascript/auto&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>默认输出文件名为 md4 的 hash 值, 可以指定输出文件名格式, 常用 placeholder:</p><ul><li><code>[ext]</code>: 原文件扩展名</li><li><code>[name]</code>: 源文件名</li><li><code>[hash]</code>: 文件内容, 使用 md4 散列函数处理, 生成 128 位 hash 值(32 个 16 进制)</li><li><code>[contentHash]</code>: 在<code>file-loader</code>中和<code>[hash]</code>一致</li><li><code>[hash:&lt;Length&gt;]</code>: 截取 hash 长度</li><li><code>[path]</code>: 文件相对于 webpack 配置文件的路径</li></ul><p>也可以在输出文件名前直接带上文件夹路径:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">options</span>: &#123;<br><span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;img/[name].[hash:6].[ext]&#x27;</span>,<br><span class="hljs-attr">esModule</span>: <span class="hljs-literal">false</span>,<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到打包结果符合预期:<br /><img src="https://dev.azure.com/HealMSlin/8544be09-1224-4eb0-824b-90c4ec9d49ee/_apis/git/repositories/7a27a721-4c93-4ecf-8258-d5422217b60a/items?path=%2F1662218739257_7112.png&amp;versionDescriptor%5BversionOptions%5D=0&amp;versionDescriptor%5BversionType%5D=0&amp;versionDescriptor%5Bversion%5D=master&amp;resolveLfs=true&amp;%24format=octetStream&amp;api-version=5.0" alt="" /></p><h3 id="url-loader"><a class="markdownIt-Anchor" href="#url-loader"></a> url-loader</h3><p>require()/import 引入的资源不再生成单独文件, 直接打包进 bundle 中,使用<code>url-loader</code>后就不需要配置<code>file-loader</code>了(loader 还是要安装哦)<br />首先安装<code>url-loader</code>:<br /><code>yarn add -D url-loader</code><br />配置和<code>file-loader</code>一直, 将 loader 改为<code>url-loader</code>, 先看下更改为<code>url-loader</code>后的打包输出内容:<br /><img src="https://dev.azure.com/HealMSlin/8544be09-1224-4eb0-824b-90c4ec9d49ee/_apis/git/repositories/7a27a721-4c93-4ecf-8258-d5422217b60a/items?path=%2F1662219838044_7269.png&amp;versionDescriptor%5BversionOptions%5D=0&amp;versionDescriptor%5BversionType%5D=0&amp;versionDescriptor%5Bversion%5D=master&amp;resolveLfs=true&amp;%24format=octetStream&amp;api-version=5.0" alt="" /></p><p>可以看到图片资源都被打包进 bundle.js 里了, 但实际项目中这很明显是不合理的, 全部打包进 bundle 会增大 js 文件体积, 但全部使用<code>file-loader</code>生成单独文件又会徒增多个 http 请求, 所以就需要一个阈值来指定<code>&lt; 阈值</code>打包进 bundle, <code>&gt; 阈值</code>的单独生成文件, 配置如下, 这里以两张图片(girl.png|7.8M, grassland.png|2.5M)举例, 设置<code>limit</code>为 3M:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>    <span class="hljs-string">&quot;loader&quot;</span>: <span class="hljs-string">&quot;url-loader&quot;</span>,<br>    <span class="hljs-string">&quot;options&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;img/[name].[hash:6].[ext]&quot;</span>,<br>        <span class="hljs-string">&quot;limit&quot;</span>: <span class="hljs-number">3</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>,<br>        <span class="hljs-string">&quot;esModule&quot;</span>: <span class="hljs-literal">false</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打包结果:<br /><img src="https://dev.azure.com/HealMSlin/8544be09-1224-4eb0-824b-90c4ec9d49ee/_apis/git/repositories/7a27a721-4c93-4ecf-8258-d5422217b60a/items?path=%2F1662220100265_9387.png&amp;versionDescriptor%5BversionOptions%5D=0&amp;versionDescriptor%5BversionType%5D=0&amp;versionDescriptor%5Bversion%5D=master&amp;resolveLfs=true&amp;%24format=octetStream&amp;api-version=5.0" alt="" /></p><h2 id="migrate-to-webpack5"><a class="markdownIt-Anchor" href="#migrate-to-webpack5"></a> migrate to webpack5</h2><p>webpack5 内置了资源模块类型(asset module type), 已经不再推荐使用<code>file-loader</code>, <code>url-loader</code>, 可以通过添加新的模块类型来替换这些 loader, 不需要再安装这些 loader</p><ul><li><code>asset/resource</code>: 替换<code>file-loader</code></li><li><code>asset/inline</code>: 替换<code>url-loader</code></li><li><code>asset/source</code>: 替换<code>raw-loader</code>, 不常用</li><li><code>asset</code>: 根据配置的 maxSize 判断使用 resource 还是 inline</li></ul><p>以下是上述 webpack4 配置的 webpack5 版本:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>    <span class="hljs-string">&quot;test&quot;</span>: <span class="hljs-string">&quot;/.(gif|jpe?g|png)$/i&quot;</span>,<br>    <span class="hljs-comment">// asset == asset/resource + asset/inline</span><br>    <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;asset&quot;</span>,<br>    <span class="hljs-string">&quot;generator&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;filename&quot;</span>: <span class="hljs-string">&quot;img/[name].[hash:6][ext]&quot;</span><br>    &#125;,<br>    <span class="hljs-string">&quot;parser&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;dataUrlCondition&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;maxSize&quot;</span>: <span class="hljs-number">3</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>webpack5 也提供了指定全局资源打包路径的方式, 当然, 这种方式我<strong>不推荐</strong>.</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs diff">&#123;<br>    &quot;output&quot;: &#123;<br>        &quot;filename&quot;: &quot;bundle.js&quot;,<br>        &quot;path&quot;: path.resolve(__dirname, &#x27;./build&#x27;),<br><span class="hljs-addition">+       &quot;assetModuleFilename&quot;: &quot;img/[name].[hash:6][ext]&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里使用<strong>generator</strong>和<strong>parser</strong>代替了原来的<strong>options</strong>, 需要注意的是这里的 placeholder <code>[ext]</code>为<code>.extname</code>, 而 webpack5 之前<code>[ext]</code>为<code>extname</code>, 所以这里不需要加<code>.</code></p><p>打包结果与 webpack4 输出一致:<br /><img src="https://dev.azure.com/HealMSlin/8544be09-1224-4eb0-824b-90c4ec9d49ee/_apis/git/repositories/7a27a721-4c93-4ecf-8258-d5422217b60a/items?path=%2F1662220100265_9387.png&amp;versionDescriptor%5BversionOptions%5D=0&amp;versionDescriptor%5BversionType%5D=0&amp;versionDescriptor%5Bversion%5D=master&amp;resolveLfs=true&amp;%24format=octetStream&amp;api-version=5.0" alt="" /></p><h3 id="别的-resource"><a class="markdownIt-Anchor" href="#别的-resource"></a> 别的 resource</h3><p>对于字体, 音频, 视频等资源处理也和图片资源大致一样, 这里以字体举例:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br><span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.(ttf|eot|woff2?)$/i</span>,<br><span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;asset/resource&#x27;</span>,<br><span class="hljs-attr">generator</span>: &#123;<br><span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;font/[name].[hash:6][ext]&#x27;</span>,<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="示例代码"><a class="markdownIt-Anchor" href="#示例代码"></a> 示例代码</h1><p><a href="https://github.com/Mariana-Yui/fe-learn-code/tree/main/learn-webpack/day3">https://github.com/Mariana-Yui/fe-learn-code/tree/main/learn-webpack/day3</a></p>]]></content>
    
    
    <categories>
      
      <category>webpack</category>
      
    </categories>
    
    
    <tags>
      
      <tag>webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webpack学习笔记(2)</title>
    <link href="/2022/09/02/2022-09-02-study-webpack-day2/"/>
    <url>/2022/09/02/2022-09-02-study-webpack-day2/</url>
    
    <content type="html"><![CDATA[<h1 id="学习笔记"><a class="markdownIt-Anchor" href="#学习笔记"></a> 学习笔记</h1><ol><li>webpack 默认 config 文件名<code>webpack.config.js</code>, 可以通过<code>webpack --config webpack.config.js</code>指定配置文件, 默认导出到<code>./dist/main.js</code>, 一个最基础的配置文件如下:</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">entry</span>: <span class="hljs-string">&quot;./index.js&quot;</span>,<br>  <span class="hljs-attr">output</span>: &#123;<br>    <span class="hljs-attr">filename</span>: <span class="hljs-string">&quot;bundle.js&quot;</span>,<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;./build&quot;</span>,<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><ol start="2"><li><p>webpack 默认只支持 import js 文件, 对于 css, img 这类模块需要额外的 loader 进行解析</p><ol><li><p>loader 可以通过三种方式使用</p><ol><li><p>内联方式: import “css-loader!./style.css”</p></li><li><p>cli 方式: 已废弃</p></li><li><p>配置方式: <code>modules.rules</code>中允许配置多个 loader, rules 是一个[Rule]数组, Rule 是一个对象, 包含常用属性:</p><ol><li><p>test: 正则表达式, 对 resource 进行匹配</p></li><li><p>loader: 只有一个 loader 时可以使用这个属性, 值为字符串</p></li><li><p>use: [UseEntry]数组, useEntry 也是个对象包含常用属性:</p><ol><li><p>loader: 必须有 loader 属性, 值为字符串</p></li><li><p>options: 可选属性, 字符串或对象, 值会传到 loader 中</p></li></ol></li></ol></li><li><p>直接使用<code>loader: 'xx-loader'</code>或者<code>use: ['xx-loader']</code>都是<code>use: [&#123;loader: 'xx-loader'&#125;</code>的简写</p></li></ol></li><li><p>普通的 css 文件使用<code>css_loader</code><strong>解析</strong>, 安装: <code>yarn add -D css-loader</code>. <code>css-loader</code>只是让 webpack 能够正确解析 css 模块, 还需要使用<code>style-loader</code>生成&lt;style&gt;插入到&lt;head&gt;中, 安装: <code>yarn add -D style-loader</code>, 对相同 resource 的 loader, webpack 处理顺序是从右往左的, 所以对于普通的 css 文件, 配置应该是<code>['style-loader', 'css-loader']</code>, 先解析 css 文件, 再插入 html 中.</p><ol><li><p>对于 sass/less/stylus 这类预处理工具也是同样的, 以 sass 为例, 安装: <code>yarn add -D sass sass-loader@10</code>(最新版的 sass-loader 不适配 sass, 安装 version10) 配置: <code>use: ['style-loader', 'css-loader', 'sass-loader']</code></p></li><li><p>小知识: 可以使用<code>npx sass foo.scss &gt; bar.css</code> 将 scss 转换为 css</p></li></ol></li></ol></li><li><p>针对不同浏览器兼容性, webpack 通过 browserslist 管理需要兼容的浏览器, 配置文件名<code>.browserslistrc</code>, babel, autoprefixer 等插件处理兼容性时都会先查询该浏览器配置,不会对不符合的浏览器做兼容 browserslist 编写规则如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">default</span> <span class="hljs-comment">//默认的浏览器, 该行可以省略</span><br>&gt; <span class="hljs-number">1</span>% <span class="hljs-comment">//占有率&gt;1%, 可以在https://caniuse.com/usage-table查询个浏览器占有率</span><br>last <span class="hljs-number">2</span> version <span class="hljs-comment">// 每个浏览器的最近两个版本</span><br>not dead <span class="hljs-comment">// 两年内官方有支持或更新的浏览器</span><br></code></pre></td></tr></table></figure><ol><li><p>babel, autoprefixer 会通过<code>caniuse-lite</code>这个包去解析<code>.browserslistrc</code>里的内容, 也可以通过<code>npx browserslist &quot;&gt; 1%, last 2 version, not dead&quot;</code>查看输出匹配的浏览器列表</p></li><li><p>指定兼容浏览器 可以使用上述创建<code>.browserslistrc</code>, 也可以在<code>package.json</code>中新增<code>browserslist</code>字段.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;browserslist&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;&gt; 1%&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;last 2 version&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;not dead&quot;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li><li><p>如果什么配置都没有, 会使用默认的 browser 配置</p></li></ol><img src="https://dev.azure.com/HealMSlin/8544be09-1224-4eb0-824b-90c4ec9d49ee/_apis/git/repositories/7a27a721-4c93-4ecf-8258-d5422217b60a/items?path=%2F1662051646312_1893.png&versionDescriptor%5BversionOptions%5D=0&versionDescriptor%5BversionType%5D=0&versionDescriptor%5Bversion%5D=master&resolveLfs=true&%24format=octetStream&api-version=5.0" width="300" /><ol start="4"><li><code>or</code>/<code>,</code>取并集, <code>and</code>取交集, <code>not</code>取反, 一般默认都是取并集</li></ol></li></ol><h1 id="配置示例"><a class="markdownIt-Anchor" href="#配置示例"></a> 配置示例</h1><p>放上最终的<code>webpack.config.js</code>和<code>.browserslistrc</code>配置<br />webpack.config.js:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;path&quot;</span>);<br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">entry</span>: <span class="hljs-string">&quot;./index.js&quot;</span>,<br>  <span class="hljs-attr">output</span>: &#123;<br>    <span class="hljs-attr">filename</span>: <span class="hljs-string">&quot;bundle.js&quot;</span>,<br>    <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&quot;./build&quot;</span>),<br>  &#125;,<br>  <span class="hljs-attr">module</span>: &#123;<br>    <span class="hljs-attr">rules</span>: [<br>      &#123;<br>        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.s?css$/i</span>,<br>        <span class="hljs-attr">use</span>: [<span class="hljs-string">&quot;style-loader&quot;</span>, <span class="hljs-string">&quot;css-loader&quot;</span>, <span class="hljs-string">&quot;sass-loader&quot;</span>],<br>      &#125;,<br>    ],<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p>.browserslistrc:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">&gt; <span class="hljs-number">1</span>%<br>last <span class="hljs-number">2</span> version<br>not dead<br></code></pre></td></tr></table></figure><h1 id="示例代码"><a class="markdownIt-Anchor" href="#示例代码"></a> 示例代码</h1><p><a href="https://github.com/Mariana-Yui/fe-learn-code/tree/main/learn-webpack/day2">https://github.com/Mariana-Yui/fe-learn-code/tree/main/learn-webpack/day2</a></p>]]></content>
    
    
    <categories>
      
      <category>webpack</category>
      
    </categories>
    
    
    <tags>
      
      <tag>webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webpack学习笔记(1)</title>
    <link href="/2022/09/01/2022-09-01-study-webpack-day1/"/>
    <url>/2022/09/01/2022-09-01-study-webpack-day1/</url>
    
    <content type="html"><![CDATA[<h1 id="引言"><a class="markdownIt-Anchor" href="#引言"></a> 引言</h1><p>系统学习 webpack5 的第一天…立志成为前端 dalao(大概</p><h1 id="学习笔记"><a class="markdownIt-Anchor" href="#学习笔记"></a> 学习笔记</h1><ol><li><p>webpack 安装通常需要安装<code>webpack</code>和<code>webpack-cli</code>但后者不是必须的, 在主流框架 vue, react 中都没有使用而且使用自己的 cli</p><ol><li><code>webpack-cli</code>的作用是在使用<code>webpack --config=webpack.config.js</code>指定 webpack 配置文件或者默认配置文件是通过<code>webpack-cli</code>执行的, 当然也可以像 vue,react 一样自己编写 cli</li></ol></li><li><p>没有安装<code>webpack-cli</code>直接执行<code>webpack</code>也会提示需要安装</p></li></ol><p><img src="https://dev.azure.com/HealMSlin/8544be09-1224-4eb0-824b-90c4ec9d49ee/_apis/git/repositories/7a27a721-4c93-4ecf-8258-d5422217b60a/items?path=%2F1661880098783_9947.png&amp;versionDescriptor%5BversionOptions%5D=0&amp;versionDescriptor%5BversionType%5D=0&amp;versionDescriptor%5Bversion%5D=master&amp;resolveLfs=true&amp;%24format=octetStream&amp;api-version=5.0" alt="" /></p><ol start="3"><li>直接运行<code>webpack</code>没指定文件路径 webpack 默认会寻找 src 目录, 没有会报错</li></ol><p><img src="https://dev.azure.com/HealMSlin/8544be09-1224-4eb0-824b-90c4ec9d49ee/_apis/git/repositories/7a27a721-4c93-4ecf-8258-d5422217b60a/items?path=%2F1661952204310_1520.png&amp;versionDescriptor%5BversionOptions%5D=0&amp;versionDescriptor%5BversionType%5D=0&amp;versionDescriptor%5Bversion%5D=master&amp;resolveLfs=true&amp;%24format=octetStream&amp;api-version=5.0" alt="" /></p><ol start="4"><li><p>以以往开发的经验, 建议都局部安装 webpack</p></li><li><p>webpack 默认只支持处理导入导出语法编译,不会改变除此之外的部分, esmodule 语法可以直接使用<code>&lt;script type=&quot;module&quot;&gt;</code>调用, 但是如果要使用 cjs 语法或者不使用<code>type=&quot;module&quot;</code>的普通 script 标签引入, 都需要使用 webpack 进行编译</p></li></ol><h1 id="示例代码"><a class="markdownIt-Anchor" href="#示例代码"></a> 示例代码</h1><p><a href="https://github.com/Mariana-Yui/fe-learn-code/tree/main/learn-webpack/day1">https://github.com/Mariana-Yui/fe-learn-code/tree/main/learn-webpack/day1</a></p>]]></content>
    
    
    <categories>
      
      <category>webpack</category>
      
    </categories>
    
    
    <tags>
      
      <tag>webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>lerna使用记录</title>
    <link href="/2022/08/25/2022-08-25-lerna-record/"/>
    <url>/2022/08/25/2022-08-25-lerna-record/</url>
    
    <content type="html"><![CDATA[<h1 id="引言"><a class="markdownIt-Anchor" href="#引言"></a> 引言</h1><p>记录一下工作中使用到的 lerna 常用命令(并不常用), 部分是对<a href="https://juejin.cn/post/6844903911095025678#heading-2">基于 Lerna 管理 packages 的 Monorepo 项目最佳实践</a>的记录, 部分是工作中遇到的问题记录.</p><h1 id="目录结构"><a class="markdownIt-Anchor" href="#目录结构"></a> 目录结构</h1><p>可以通过<code>tree -L 2 --gitignore</code>生成</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stylus">├── README<span class="hljs-selector-class">.md</span><br>├── babel<span class="hljs-selector-class">.config</span><span class="hljs-selector-class">.js</span><br>├── commitlint<span class="hljs-selector-class">.config</span><span class="hljs-selector-class">.js</span><br>├── lerna<span class="hljs-selector-class">.json</span><br>├── package<span class="hljs-selector-class">.json</span><br>├── packages<br>│   ├── cli<br>│   └── cli-shared-utils<br>└── yarn.lock<br></code></pre></td></tr></table></figure><h1 id="常用命令"><a class="markdownIt-Anchor" href="#常用命令"></a> 常用命令</h1><ol><li><p><code>lerna init</code>: 初始化一个 monorepo 项目, 生成 lerna.json, package.json 和 packages 文件夹</p></li><li><p><code>lerna create</code>: 在 packages 文件夹下添加 package, npm 包目录结构</p></li><li><p><code>lerna add</code>: packages/*全部安装依赖<br />3.1 <code>--scope packageName</code>: 指定 package 安装依赖, 也可以<code>lerna add anotherPackageName --scope packageName</code>将 packages/*下一个包作为另一个包的依赖<br />3.2 lerna 默认通过 npm 安装依赖, 可以添加以下使用 yarn 安装依赖</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;npmClient&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;yarn&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li><li><p><code>lerna version</code>: 需要保证当前 branch clean</p><ol><li><code>lerna version [major | minor | patch | premajor | preminor | prepatch | prerelease]</code>类似<code>npm version</code>一样, 将 packages 中变更的 package 改变版本号</li><li>打 tag, 并自动将 tag 同步 remote, 如果各种原因导致 tag 已存在需要删除 remote tag</li><li>生成 <a href="http://CHANGELOG.md">CHANGELOG.md</a>, 建议使用配置参数<code>--conventional-commits</code>, 以<a href="https://conventionalcommits.org/">传统的提交规范</a>生成 log, 如下图可以看到我们规范提交的 commit 信息都被写入了 CHANGELOG 中<br /><img src="https://dev.azure.com/HealMSlin/8544be09-1224-4eb0-824b-90c4ec9d49ee/_apis/git/repositories/7a27a721-4c93-4ecf-8258-d5422217b60a/items?path=%2F1661445238686_7737.png&amp;versionDescriptor%5BversionOptions%5D=0&amp;versionDescriptor%5BversionType%5D=0&amp;versionDescriptor%5Bversion%5D=master&amp;resolveLfs=true&amp;%24format=octetStream&amp;api-version=5.0" alt="" /><br /><img src="https://dev.azure.com/HealMSlin/8544be09-1224-4eb0-824b-90c4ec9d49ee/_apis/git/repositories/7a27a721-4c93-4ecf-8258-d5422217b60a/items?path=%2F1661445271386_3522.png&amp;versionDescriptor%5BversionOptions%5D=0&amp;versionDescriptor%5BversionType%5D=0&amp;versionDescriptor%5Bversion%5D=master&amp;resolveLfs=true&amp;%24format=octetStream&amp;api-version=5.0" alt="" /><br /><a href="http://CHANGELOG.md">CHANGELOG.md</a> 中可以看到根据提交的前缀进行了分类<br /><img src="https://dev.azure.com/HealMSlin/8544be09-1224-4eb0-824b-90c4ec9d49ee/_apis/git/repositories/7a27a721-4c93-4ecf-8258-d5422217b60a/items?path=%2F1661931145247_8800.png&amp;versionDescriptor%5BversionOptions%5D=0&amp;versionDescriptor%5BversionType%5D=0&amp;versionDescriptor%5Bversion%5D=master&amp;resolveLfs=true&amp;%24format=octetStream&amp;api-version=5.0" alt="" /></li></ol></li><li><p><code>lerna publish</code>: 通常不会单独使用<code>lerna version</code>, 因为<code>lerna publish</code>就包含<code>lerna version</code>, 以及会将涉及版本号变动的包<code>npm publish</code>, 需要注意的是如果包名带有<code>@xx/</code>前缀, 需要在<a href="https://www.npmjs.com/org/create">npm organization</a>注册该前缀组织</p><ol><li>这是个工作中遇到的奇怪问题: 如果 package.json scripts 中事先定义了类似配置如下, 只能使用<code>npm run patch/publish</code>来使用 lerna, 不能直接在 terminal 执行<code>lerna ...</code>, 否则会一直在 package.json 中添加 gitHead 导致提交失败</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;patch&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;lerna version patch --conventional-commits --yes&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;publish&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;lerna publish from-package --yes&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li><li><p><code>lerna clean</code>: 清除 packages/* 下各 package 依赖, 如果要删除项目中所有依赖可以通过<code>lerna cleanr</code> + <code>rm -r node_modules</code></p></li><li><p><code>lerna bootstrap</code>: 安装所有 packages 依赖, 默认情况下会有以下问题<br />7.1 会将依赖都安装到 package 中, 没有做依赖提升<br />7.2 <code>--hoist</code>会做到依赖提升, 但是和<code>&quot;npmClient&quot;: &quot;yarn&quot;</code>冲突, <strong>–hoist is not supported with --npm-client=yarn, use yarn workspaces instead</strong><br />这时候就要使用 yarn workspace 配合 lerna 使用, 前者负责依赖安装管理, 后者负责版本管理发布, 启用 yarn workspace 后<code>lerna bootstrap</code>等同于<code>yarn install</code>, yarn 会对依赖提升<br />相关配置:</p></li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// lerna.json</span><br><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;npmClient&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;yarn&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;useWorkspaces&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br><span class="hljs-punctuation">&#125;</span><br><br><span class="hljs-comment">// package.json</span><br><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;workspaces&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br><span class="hljs-string">&quot;packages/*&quot;</span><br><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h1 id="lernajson"><a class="markdownIt-Anchor" href="#lernajson"></a> lerna.json</h1><ol><li><code>version</code>: 固定模式(fixed)或独立模式(inpendent)<br />默认是固定模式, 即 packages/* 下所有 package 都是统一版本号, 和 lerna.json 中 version 配置一直, 每回发布都会更新 version 配置, 生成的 <a href="http://CHANGELOG.md">CHANGELOG.md</a> 在项目根目录下, 如果要使用独立模式, 配置<code>&quot;version&quot;: &quot;inpendent&quot;</code>, 各 pacage 单独管理版本号, <a href="http://CHANGELOG.md">CHANGELOG.md</a> 分布在各自文件夹下</li></ol><h1 id="reference"><a class="markdownIt-Anchor" href="#reference"></a> reference</h1><ol><li><a href="https://juejin.cn/post/6844903911095025678">基于 Lerna 管理 packages 的 Monorepo 项目最佳实践</a></li><li><a href="https://yrq110.me/post/tool/how-lerna-manage-package-dependencies/">Lerna 的依赖管理及 hoisting 浅析</a></li><li><a href="https://www.cnblogs.com/ly0612/p/15545803.html">新版本 husky 配置不生效</a></li><li><a href="https://github.com/typicode/husky/issues/840">Environment variable ‘HUSKY_GIT_PARAMS’ is not available globally #840</a></li><li><a href="http://www.febeacon.com/lerna-docs-zh-cn/routes/commands/">yarn 指令总览</a></li><li><a href="https://juejin.cn/post/7012622147726082055">Lerna 独立模式下如何优雅的发包</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>lerna</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>koa-static 源码分析</title>
    <link href="/2022/08/20/2022-08-20-koa-static/"/>
    <url>/2022/08/20/2022-08-20-koa-static/</url>
    
    <content type="html"><![CDATA[<h1 id="koa-static"><a class="markdownIt-Anchor" href="#koa-static"></a> koa-static</h1><p><code>koa-static</code>是 koa 的静态文件服务中间件</p><h1 id="example"><a class="markdownIt-Anchor" href="#example"></a> Example</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> koaStatic = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;koa-static&#x27;</span>);<br><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">koaStatic</span>(&#123;<br>path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;../static&#x27;</span>);<br>&#125;, &#123;&#125;));<br><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">8888</span>);<br></code></pre></td></tr></table></figure><p>比如你的<code>static</code>文件目录结构为</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">├── <span class="hljs-selector-tag">html</span><br>│   └── upfile<span class="hljs-selector-class">.html</span><br>└── uploads<br>│   └── aa.js<br></code></pre></td></tr></table></figure><p>那就可以通过浏览器访问<code>http://localhost:8888/html/upfile.html</code>访问静态文件了</p><h1 id="options"><a class="markdownIt-Anchor" href="#options"></a> options</h1><p>截取自<code>koa-static</code>github readme 的常用 options</p><ul><li><code>maxage</code> Browser cache max-age in milliseconds. defaults to 0</li><li><code>hidden</code> Allow transfer of hidden files. defaults to false</li><li><code>index</code> Default file name, defaults to ‘index.html’</li><li><code>defer</code> If true, serves after <code>return next()</code>, allowing any downstream middleware to respond first.</li><li><code>gzip</code> Try to serve the gzipped version of a file automatically when gzip is supported by a client and if the requested file with .gz extension exists. defaults to true.</li><li>[setHeaders] Function to set custom headers on response.</li><li><code>extensions</code> Try to match extensions from passed array to search for file when no extension is sufficed in URL. First found is served. (defaults to <code>false</code>)</li></ul><h1 id="源码分析"><a class="markdownIt-Anchor" href="#源码分析"></a> 源码分析</h1><p><code>koa-static</code>依赖<code>koa-send</code>包, 大部分逻辑都是<code>koa-send</code>处理的, <code>koa-static</code>只对<code>options.defer</code>做了处理.</p><ul><li>defer 顾名思义, 如果为<code>true</code>, 则先执行<code>koa-send</code>, 找到文件直接返回, 否则<code>await next()</code>; <code>false</code>则相反, 先<code>await next()</code>, <code>ctx.body</code>如果还是<code>null</code>则执行<code>koa-send</code></li></ul><p><code>koa-send</code>核心逻辑通过<code>path.resolvePath(ctx.path)</code>和初始化时的 root 路径拼接得到文件在服务端的真实文件路径, 最后以 readable stream 的形式返回</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">ctx.<span class="hljs-property">body</span> = fs.<span class="hljs-title function_">createReadStream</span>(path);<br></code></pre></td></tr></table></figure><p>koa 中同样对 stream 类型的数据做了处理, 通过<code>pipe</code>管道返回给浏览器数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// application.js</span><br><span class="hljs-comment">// responses</span><br><span class="hljs-keyword">if</span> (<span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">isBuffer</span>(body)) <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">end</span>(body);<br><span class="hljs-keyword">if</span> (<span class="hljs-string">&#x27;string&#x27;</span> === <span class="hljs-keyword">typeof</span> body) <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">end</span>(body);<br><span class="hljs-keyword">if</span> (body <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Stream</span>) <span class="hljs-keyword">return</span> body.<span class="hljs-title function_">pipe</span>(res);<br></code></pre></td></tr></table></figure><p><code>koa-static</code>也通过<code>fs.stat</code>获取文件的具体信息设置响应头</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">ctx.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;Content-Length&#x27;</span>, stats.<span class="hljs-property">size</span>)<br><br><span class="hljs-keyword">if</span> (!ctx.<span class="hljs-property">response</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;Last-Modified&#x27;</span>)) ctx.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;Last-Modified&#x27;</span>, stats.<span class="hljs-property">mtime</span>.<span class="hljs-title function_">toUTCString</span>())<br>&#125;<br><br><span class="hljs-keyword">if</span> (!ctx.<span class="hljs-property">type</span>) ctx.<span class="hljs-property">type</span> = <span class="hljs-title function_">type</span>(path, encodingExt)<br><br></code></pre></td></tr></table></figure><p>对 option.setHeader 的处理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (setHeaders) <span class="hljs-title function_">setHeaders</span>(ctx.<span class="hljs-property">res</span>, path, stats);<br></code></pre></td></tr></table></figure><p>对 option.hidden 的处理, 这里 option.hidden 为 true 以及文件名以<code>.</code>开头都是会隐藏的, <code>isHidden</code>函数判断文件名是否为<code>.xxx</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// hidden file support, ignore</span><br><span class="hljs-keyword">if</span> (!hidden &amp;&amp; <span class="hljs-title function_">isHidden</span>(root, path)) <span class="hljs-keyword">return</span>;<br></code></pre></td></tr></table></figure><p>对 option.extensions 的处理, 设置了 extensions 数组则允许浏览器 url 不带上后缀</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (extensions &amp;&amp; !<span class="hljs-regexp">/\./</span>.<span class="hljs-title function_">exec</span>(<span class="hljs-title function_">basename</span>(path))) &#123;<br>  <span class="hljs-keyword">const</span> list = [].<span class="hljs-title function_">concat</span>(extensions);<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; list.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">let</span> ext = list[i];<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> ext !== <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&#x27;option extensions must be array of strings or false&#x27;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-regexp">/^\./</span>.<span class="hljs-title function_">exec</span>(ext)) ext = <span class="hljs-string">`.<span class="hljs-subst">$&#123;ext&#125;</span>`</span>;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">await</span> <span class="hljs-title function_">exists</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;path&#125;</span><span class="hljs-subst">$&#123;ext&#125;</span>`</span>)) &#123;<br>      path = <span class="hljs-string">`<span class="hljs-subst">$&#123;path&#125;</span><span class="hljs-subst">$&#123;ext&#125;</span>`</span>;<br><br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>koa</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>obsidian插件记录</title>
    <link href="/2022/08/08/2022-08-08-obsidian-plugins/"/>
    <url>/2022/08/08/2022-08-08-obsidian-plugins/</url>
    
    <content type="html"><![CDATA[<h1 id="背景"><a class="markdownIt-Anchor" href="#背景"></a> 背景</h1><p>发现了个好用的 note app: <code>obsidian</code>, 内置插件以及第三方插件都能大幅度提升写笔记体验, 于是把之前用 jekyll 搭建的博客文件夹挪到里面, 代码虽然是同步 git 的, 但是插件被我 gitignore 掉了, 都存在本地, 避免极端情况要重新装一遍记录下用到第三方的插件.</p><h1 id="第三方插件"><a class="markdownIt-Anchor" href="#第三方插件"></a> 第三方插件</h1><ol><li>calendar<br />展示日历用于记录每周的日记情况, 点击日期即可生成当天的 md 文件<br /><img src="https://raw.githubusercontent.com/Mariana-Yui/images/master/blog-imgs/202208082337559.png" width="300" /><br />可以配合内置插件<code>日记</code>和<code>模板</code>食用<br /><img src="https://raw.githubusercontent.com/Mariana-Yui/images/master/blog-imgs/202208082344111.png" alt="" /></li><li>emoji toolbar<br />提供 emoji 表情方便写笔记时搜索</li><li>style settings<br />自定义外观主题的样式, 外观主题在这里下载 ↓<br /><img src="https://raw.githubusercontent.com/Mariana-Yui/images/master/blog-imgs/202208082353487.png" alt="" /></li><li>sliding panes<br /><img src="https://raw.githubusercontent.com/Mariana-Yui/images/master/blog-imgs/202208082352300.png" alt="" /></li><li>image auto upload plugin<br />🐮🍺 需要配合<code>picGo</code>食用, 直接把图片复制进来就可以通过 picGo 上传到图床, 再也不用手动上传了<br />其中<code>picGo server</code>配置默认为<code>http://127.0.0.1:36677/upload</code>, 具体端口号可以再 picGo app 配置中找到 ↓<br /><img src="https://raw.githubusercontent.com/Mariana-Yui/images/master/blog-imgs/202208082357506.png" alt="" /></li><li>obsidian git<br />每隔 X 分钟自动同步 git, 对我的场景没啥用, blog 有些未写完的文件本来就不想 commit, 以后别的场景可能会遇到</li><li>day planner<br />设置每天的时间轴</li></ol><h1 id="diy"><a class="markdownIt-Anchor" href="#diy"></a> DIY</h1><ol><li>calendar<br />通过查找源码可以发现</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> noteDate = <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">moment</span>(file.<span class="hljs-property">basename</span>, format, <span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure><p><code>calendar</code>会对文件全名通过 moment.js 处理, 这就导致你如果文件名是<code>2022-08-10-obsidian-plugins</code>这样它就识别不出来, 就无法在日历上通过 dot 标识当天的日记, 啃爹呐这是 😅. 看了看 issue 也有人发出了相同一问, 半年过去了作者也没解决, 那我们就自己搞个 polyfill, 既然你全名不能生成日期那我就截断能生成日期的那部分不就好了-.-, 博主的笔记文件名都是<code>yyyy-mm-dd-笔记标题</code>这种格式, 通过以下正则即可让旧笔记显示在 📅 上了~</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> noteDate = <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">moment</span>(<br>  file.<span class="hljs-property">basename</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/\d&#123;4&#125;-\d&#123;2&#125;-\d&#123;2&#125;/g</span>),<br>  format,<br>  <span class="hljs-literal">true</span><br>);<br></code></pre></td></tr></table></figure><p>效果图:<br /><img src="https://dev.azure.com/HealMSlin/8544be09-1224-4eb0-824b-90c4ec9d49ee/_apis/git/repositories/7a27a721-4c93-4ecf-8258-d5422217b60a/items?path=%2F1660139613361_5344.png&amp;versionDescriptor%5BversionOptions%5D=0&amp;versionDescriptor%5BversionType%5D=0&amp;versionDescriptor%5Bversion%5D=master&amp;resolveLfs=true&amp;%24format=octetStream&amp;api-version=5.0" alt="" /></p><h1 id="多提一嘴"><a class="markdownIt-Anchor" href="#多提一嘴"></a> 多提一嘴</h1><p>在 obsidian 中写 markdown 无法使用 prettier 对源码进行格式化, 所以需要使用设置 pre-commit 钩子在 commit 前格式化 md 文件, 具体操作如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">npx husky-init <span class="hljs-comment"># add --yarn2 for Yarn 2</span><br>yarn add --dev pretty-quick<br>yarn husky <span class="hljs-built_in">set</span> .husky/pre-commit <span class="hljs-string">&quot;npx pretty-quick --staged&quot;</span><br></code></pre></td></tr></table></figure><h1 id="reference"><a class="markdownIt-Anchor" href="#reference"></a> reference</h1><ol><li><a href="https://sspai.com/post/67619">Obsidian 新手系列之你不可不知的插件</a></li><li><a href="https://prettier.io/docs/en/precommit.html">add prettier format before commit</a></li><li><a href="https://zhuanlan.zhihu.com/p/428499423">Obsidian 中使用 Calendar 插件快捷建立日记、周记</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>obsidian</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webpack开发实践记录</title>
    <link href="/2022/07/15/2022-07-15-webpack-record/"/>
    <url>/2022/07/15/2022-07-15-webpack-record/</url>
    
    <content type="html"><![CDATA[<p>开个新坑</p>]]></content>
    
    
    
    <tags>
      
      <tag>webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ant-design-vue(vue3)组件二次开发记录</title>
    <link href="/2022/07/15/2022-07-26-vue-slot/"/>
    <url>/2022/07/15/2022-07-26-vue-slot/</url>
    
    <content type="html"><![CDATA[<h1 id="背景"><a class="markdownIt-Anchor" href="#背景"></a> 背景</h1><p>react 如果想在 ant-design 封装的组件上二次开发, 因为 jsx 的特性, 可以将 dom 作为 props, 所以很简单, 但 vue 就有点麻烦, 需要使用 slot 插槽的方式, 以下是业务开发中时间成功后的记录, 感觉还是学到了挺多东西.</p><h1 id="attrs-和slots"><a class="markdownIt-Anchor" href="#attrs-和slots"></a> $attrs 和$slots</h1><p>在具体时间之前需要了解一些前置知识, <code>$attrs</code>和<code>slots</code>都是绑定在组件作用域上的私有属性, 不需要在<code>setup</code>中 return, 同时, 也可以在<code>setup(props, ctx)</code>的 ctx 上下文中看到 attrs 和 slots 两个属性, 表示的含义都是一样的.</p><h2 id="attrs"><a class="markdownIt-Anchor" href="#attrs"></a> $attrs</h2><p>先看下官方的解释:</p><blockquote><p>The $attrs object includes all attributes that are not declared by the component’s props or emits options (e.g., class, style, v-on listeners, etc.).</p></blockquote><p>也就是说父组件传入子组件的属性中没被子组件 props 声明的都会包含在<code>$attr</code> 中, 包括 class, style, v-on 这些 dom 原生的属性或 vue 绑定的事件.<br />这就很适合我们需要二次开发组件的场景, 保证传入的原有属性不受影响的前提下, 传入新的属性进行改造</p><h3 id="在子组件中开启attrs"><a class="markdownIt-Anchor" href="#在子组件中开启attrs"></a> 在子组件中开启$attrs</h3><p><code>$attr</code>想在子组件中使用需要设置<code>inheritAttrs: true</code>, vue3 默认该设置, 所以可以直接使用</p><h2 id="slots"><a class="markdownIt-Anchor" href="#slots"></a> $slots</h2><p>顾名思义, <code>$attrs</code>包含了所有传入的非 props 属性, 那<code>$slots</code>就是包含了传入的所有插槽了</p><h1 id="v-bind"><a class="markdownIt-Anchor" href="#v-bind"></a> v-bind</h1><p><code>$attrs</code>包含了父组件传入的所有非 props 属性, <code>v-bind=&quot;$attrs&quot;</code>则将所有属性绑定在对应组件标签上</p><h1 id="具名插槽和作用域插槽"><a class="markdownIt-Anchor" href="#具名插槽和作用域插槽"></a> 具名插槽和作用域插槽</h1><h2 id="具名插槽"><a class="markdownIt-Anchor" href="#具名插槽"></a> 具名插槽</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 子组件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">base-layout</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:header</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Here might be a page title<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:default</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>A paragraph for the main content.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>And another one.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:footer</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Here&#x27;s some contact info<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">base-layout</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 父组件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Here might be a page title<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">main</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>A paragraph for the main content.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>And another one.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Here&#x27;s some contact info<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="作用域插槽"><a class="markdownIt-Anchor" href="#作用域插槽"></a> 作用域插槽</h2><p>一般情况下父组件和子组件属于各自的作用域, 作用域插槽则可以让父组件使用插槽时访问子组件的变量</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 子组件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;( item, index ) in items&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">slot</span></span><br><span class="hljs-tag">      <span class="hljs-attr">:item</span>=<span class="hljs-string">&quot;item&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">:index</span>=<span class="hljs-string">&quot;index&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">:another-attribute</span>=<span class="hljs-string">&quot;anotherAttribute&quot;</span></span><br><span class="hljs-tag">    &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 父组件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">todo-list</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:default</span>=<span class="hljs-string">&quot;slotProps&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;fas fa-check&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;green&quot;</span>&gt;</span>&#123;&#123; slotProps.item &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">todo-list</span>&gt;</span><br></code></pre></td></tr></table></figure><p>其中, <code>v-slot:default</code>可以简写为<code>#default</code>, <code>slotProps</code>为包含绑定在<code>&lt;slot&gt;</code>上所有属性的对象, 变量名可以自定义, 也可以直接<code>v-slot:default=&quot;&#123;item, index, anotherAttribute&#125;&quot;</code>这样写.<br />下面这张图可以帮助理解:<br /><img src="https://v3.cn.vuejs.org/images/scoped-slot.png" alt="" /></p><h1 id="二次开发-table-组件"><a class="markdownIt-Anchor" href="#二次开发-table-组件"></a> 二次开发 Table 组件</h1><p>ant-design 原生的<code>Table</code>组件不支持将整个表格 disabled, 接下来就要实现该功能,(这也是我业务中所需要的功能)<br />改造完组件使用方式和 ant-design 原生的<code>Table</code>相同, 只是支持了表格全局 disabled, 这里使用官方的案例</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 父组件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">a-table</span> <span class="hljs-attr">:columns</span>=<span class="hljs-string">&quot;columns&quot;</span> <span class="hljs-attr">:data-source</span>=<span class="hljs-string">&quot;data&quot;</span> <span class="hljs-attr">:disabled</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">name</span>=<span class="hljs-string">&quot;&#123; text &#125;&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">a</span>&gt;</span>&#123;&#123; text &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">customTitle</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">smile-outlined</span> /&gt;</span><br>        Name<br>      <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">tags</span>=<span class="hljs-string">&quot;&#123; text: tags &#125;&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">a-tag</span></span><br><span class="hljs-tag">          <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;tag in tags&quot;</span></span><br><span class="hljs-tag">          <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;tag&quot;</span></span><br><span class="hljs-tag">          <span class="hljs-attr">:color</span>=<span class="hljs-string">&quot;tag === &#x27;loser&#x27; ? &#x27;volcano&#x27; : tag.length &gt; 5 ? &#x27;geekblue&#x27; : &#x27;green&#x27;&quot;</span></span><br><span class="hljs-tag">        &gt;</span><br>          &#123;&#123; tag.toUpperCase() &#125;&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">a-tag</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">action</span>=<span class="hljs-string">&quot;&#123; record &#125;&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">a</span>&gt;</span>Invite 一 &#123;&#123; record.name &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">a-divider</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;vertical&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">a</span>&gt;</span>Delete<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">a-divider</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;vertical&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ant-dropdown-link&quot;</span>&gt;</span><br>          More actions<br>          <span class="hljs-tag">&lt;<span class="hljs-name">down-outlined</span> /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>&lt;/a-table<br>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- a-table.vue --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;table-wrap&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;disabled ? &#x27;mask&#x27;: &#x27;&#x27;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 把disabled作为props, ant-design自带的那些属性都作为$attrs透传 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">antd-table</span> <span class="hljs-attr">v-bind</span>=<span class="hljs-string">&quot;$attrs&quot;</span>&gt;</span><br>      <span class="hljs-comment">&lt;!-- </span><br><span class="hljs-comment">        important! 这里template根据父组件的$lots遍历, slotProps为ant-design作用于插槽向外暴露的属性, &lt;slot&gt;则使用v-bind重新将slotProps重新暴露给父组件</span><br><span class="hljs-comment">      --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(value, key) in $slots&quot;</span> #[<span class="hljs-attr">key</span>]=<span class="hljs-string">&quot;slotProps&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">:name</span>=<span class="hljs-string">&quot;key&quot;</span> <span class="hljs-attr">v-bind</span>=<span class="hljs-string">&quot;slotProps&quot;</span> /&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">antd-table</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">import</span> &#123; defineComponent &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;</span><br><span class="language-javascript">  <span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Table</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;ant-design-vue&quot;</span>;</span><br><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineComponent</span>(&#123;</span><br><span class="language-javascript">    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;ATable&quot;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">inheritAttrs</span>: <span class="hljs-literal">true</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">props</span>: &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">disabled</span>: <span class="hljs-title class_">Boolean</span>,</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">    <span class="hljs-attr">components</span>: &#123;</span><br><span class="language-javascript">      <span class="hljs-string">&quot;antd-table&quot;</span>: <span class="hljs-title class_">Table</span>,</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">    <span class="hljs-title function_">setup</span>(<span class="hljs-params">props, ctx</span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-keyword">return</span> &#123;&#125;;</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">  &#125;);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;scss&quot;</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="language-css"></span><br><span class="language-css">  <span class="hljs-selector-class">.table-wrap</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">position</span>: relative;</span><br><span class="language-css">    <span class="hljs-selector-class">.mask</span> &#123;</span><br><span class="language-css">      <span class="hljs-attribute">position</span>: absolute;</span><br><span class="language-css">      <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;</span><br><span class="language-css">      <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;</span><br><span class="language-css">      <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#f5f5f570</span>;</span><br><span class="language-css">      <span class="hljs-attribute">z-index</span>: <span class="hljs-number">1</span>;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">  &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="reference"><a class="markdownIt-Anchor" href="#reference"></a> reference</h1><ol><li><a href="https://v3.cn.vuejs.org/api/directives.html#v-bind">v-bind</a></li><li><a href="https://vuejs.org/guide/components/attrs.html">Fallthrough Attributes (attrs 穿透属性)</a></li><li><a href="https://v3.cn.vuejs.org/guide/component-slots.html">具名插槽</a></li><li><a href="https://vuejs.org/guide/components/slots.html">slot</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>vue3</tag>
      
      <tag>ant-design-vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue-cli开发plugin记录</title>
    <link href="/2022/07/11/2022-07-11-vue-cli-plugin-trial/"/>
    <url>/2022/07/11/2022-07-11-vue-cli-plugin-trial/</url>
    
    <content type="html"><![CDATA[<h1 id="背景"><a class="markdownIt-Anchor" href="#背景"></a> 背景</h1><p>又双叒叕是因为看到 vue 项目里大佬将基建代码包装在了 vue-cli 中并通过<code>vue-cli-service command</code>亦或者<code>vue invoke command</code>的方式执行代码, 一直对 vue-cli 不太熟悉花了半天时间大概了解 vue-cli plugin 的开发流程, 至此记录.</p><h1 id="vue-add"><a class="markdownIt-Anchor" href="#vue-add"></a> vue add</h1><p>如果想要安装 vue 第三方插件可以通过<code>vue add eslint</code>来安装, vue-cli 会自动在 eslint 前加上 vue-cli-plugin 前缀, 即安装 vue-cli-plugin-eslint, 当然也可以直接输入全名.</p><blockquote><p>如果一个插件已经被安装，你可以使用 vue invoke 命令跳过安装过程，只调用它的生成器。这个命令会接受和 vue add 相同的参数。</p></blockquote><p>所以 vue add 做了两件事, 1.安装组件 2.执行<code>vue invoke</code>命令</p><h1 id="plugin-的目录结构"><a class="markdownIt-Anchor" href="#plugin-的目录结构"></a> plugin 的目录结构</h1><p>首先插件自身也是 npm 包, 一个标准的第三方插件目录结构如下:</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">├── README.md<br>├── generator.<span class="hljs-keyword">js </span> <span class="hljs-comment"># generator（可选）</span><br>├── index.<span class="hljs-keyword">js </span>     <span class="hljs-comment"># service 插件</span><br>├── package.<span class="hljs-keyword">json</span><br><span class="hljs-keyword"></span>├── prompts.<span class="hljs-keyword">js </span>   <span class="hljs-comment"># prompt 文件（可选）</span><br>└── ui.<span class="hljs-keyword">js </span>        <span class="hljs-comment"># Vue UI 集成（可选）</span><br></code></pre></td></tr></table></figure><h1 id="vue-invoke"><a class="markdownIt-Anchor" href="#vue-invoke"></a> vue invoke</h1><p>我理解<code>vue invoke plugin-name</code>会先初始化插件即执行插件中的生成器(<code>generator.js</code>或<code>generator/index.js</code>)和目录下的<code>index.js</code></p><h2 id="generator-with-promptsjs"><a class="markdownIt-Anchor" href="#generator-with-promptsjs"></a> generator with prompts.js</h2><p>当目录中存在<code>prompts.js</code>时, <code>vue invoke</code>会以可交互形式输入参数. 内置的<code>inquirer</code>回去解析<code>prompts.js</code>, 参数配置参考<a href="https://github.com/SBoudrias/Inquirer.js">inquirer</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// prompts.js</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = [<br>  &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;example&#x27;</span>,<br>    <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;confirm&#x27;</span>,<br>    <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;是否添加示例组件到项目components目录？&#x27;</span>,<br>    <span class="hljs-attr">default</span>: <span class="hljs-literal">false</span>,<br>    <span class="hljs-attr">filter</span>: <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;&#125;,<br>    <span class="hljs-attr">validate</span>: <span class="hljs-function">(<span class="hljs-params">val, options</span>) =&gt;</span> &#123;&#125;<br>  &#125;<br>];<br></code></pre></td></tr></table></figure><p>交互结束后, 会执行 generator(<code>generator.js</code>或<code>generator/index.js</code>), 上述交互的输出会作为 generator 的第二个参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// generator.js</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">api, options</span>) &#123;&#125;;<br></code></pre></td></tr></table></figure><h1 id="vue-cli-service"><a class="markdownIt-Anchor" href="#vue-cli-service"></a> vue-cli-service</h1><p>使用@vue/cli 脚手架搭建 vue 项目时, <code>package.json</code>中就能够看到<code>vue-cli-service serve/build</code>这类命令, 其中的<code>serve</code>, <code>build</code>都是 vue-cli 注册的命令, 这类命令分为<br />第三方插件注册的命令和本地注册的命令</p><h2 id="如何注册命令"><a class="markdownIt-Anchor" href="#如何注册命令"></a> 如何注册命令</h2><p>在插件目录下的<code>index.js</code>文件通过一下方式注册命令, <code>api.registerCommand</code>的第一个参数即命令名, 第二个参数为运行<code>vue-cli-service 命令名</code>执行的回调. <code>api</code>的更多用法可以参考: <a href="https://cli.vuejs.org/dev-guide/plugin-api.html">https://cli.vuejs.org/dev-guide/plugin-api.html</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-function">(<span class="hljs-params">api</span>) =&gt;</span> &#123;<br>  api.<span class="hljs-title function_">registerCommand</span>(<br>    <span class="hljs-string">&#x27;greet&#x27;</span>,<br>    &#123;<br>      <span class="hljs-attr">description</span>: <span class="hljs-string">&#x27;Write a greeting to the console&#x27;</span>,<br>      <span class="hljs-attr">usage</span>: <span class="hljs-string">&#x27;vue-cli-service greet&#x27;</span><br>    &#125;,<br>    <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`👋  Hello`</span>);<br>    &#125;<br>  );<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="第三方插件"><a class="markdownIt-Anchor" href="#第三方插件"></a> 第三方插件</h2><p>以 vue-cli-plugin-eslint 为例, 以下是源码中插件根目录下<code>index.js</code>的部分源码:<br />使用<code>vue add</code>在下载完插件后, 执行<code>vue invoke</code>运行<code>index.js</code>的代码, 从而注册 eslint 命令, 从而可以运行<code>vue-cli-service eslint</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//...</span><br>api.<span class="hljs-title function_">registerCommand</span>(<br>  <span class="hljs-string">&#x27;lint&#x27;</span>,<br>  &#123;<br>    <span class="hljs-attr">description</span>: <span class="hljs-string">&#x27;lint and fix source files&#x27;</span>,<br>    <span class="hljs-attr">usage</span>: <span class="hljs-string">&#x27;vue-cli-service lint [options] [...files]&#x27;</span>,<br>    <span class="hljs-attr">options</span>: &#123;<br>      <span class="hljs-string">&#x27;--format [formatter]&#x27;</span>: <span class="hljs-string">&#x27;specify formatter (default: codeframe)&#x27;</span>,<br>      <span class="hljs-string">&#x27;--no-fix&#x27;</span>: <span class="hljs-string">&#x27;do not fix errors or warnings&#x27;</span>,<br>      <span class="hljs-string">&#x27;--no-fix-warnings&#x27;</span>: <span class="hljs-string">&#x27;fix errors, but do not fix warnings&#x27;</span>,<br>      <span class="hljs-string">&#x27;--max-errors [limit]&#x27;</span>: <span class="hljs-string">&#x27;specify number of errors to make build failed (default: 0)&#x27;</span>,<br>      <span class="hljs-string">&#x27;--max-warnings [limit]&#x27;</span>:<br>        <span class="hljs-string">&#x27;specify number of warnings to make build failed (default: Infinity)&#x27;</span><br>    &#125;,<br>    <span class="hljs-attr">details</span>:<br>      <span class="hljs-string">&#x27;For more options, see https://eslint.org/docs/user-guide/command-line-interface#options&#x27;</span><br>  &#125;,<br>  <span class="hljs-function">(<span class="hljs-params">args</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./lint&#x27;</span>)(args, api);<br>  &#125;<br>);<br><span class="hljs-comment">//...</span><br></code></pre></td></tr></table></figure><h2 id="本地注册命令"><a class="markdownIt-Anchor" href="#本地注册命令"></a> 本地注册命令</h2><p>有时候可能并不需要开发一个完整的插件, 也不想发布 npm 包, 只想注册一个 vue-cli 命令, 可以<code>package.json</code>中添加本地的 js 文件, 这样 vue-cli 回去遍历相应文件, 也能够成功运行<code>vue-cli-service test</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// package.json</span><br><span class="hljs-string">&quot;vuePlugins&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;service&quot;</span>: [<br>      <span class="hljs-string">&quot;src/plugins/my-commands.js&quot;</span><br>    ]<br>  &#125;<br><br><span class="hljs-comment">// src/plugins/my-commands.js</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-function">(<span class="hljs-params">api</span>) =&gt;</span> &#123;<br>  api.<span class="hljs-title function_">registerCommand</span>(<span class="hljs-string">&#x27;test&#x27;</span>, &#123;&#125;, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;test&#x27;</span>);<br>  &#125;);<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="本地的插件"><a class="markdownIt-Anchor" href="#本地的插件"></a> 本地的插件</h1><p>本地开发的插件包不想发布到 npm 可以通过<code>package.json</code>dependency 中的<code>file:</code>引入, 可以<code>node_module</code>中看到.<br /><strong>注意: file:的引入方式不是软链的方式, 如果本地插件有变更, 需要<code>yarn upgrade vue-cli-plugin-name</code>更新</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-string">&quot;devDependencies&quot;</span>: &#123;<br>  <span class="hljs-string">&quot;vue-cli-plugin-name&quot;</span>: <span class="hljs-string">&quot;file:./src/plugins/vue-cli-plugin-name&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="reference"><a class="markdownIt-Anchor" href="#reference"></a> reference</h1><ol><li><a href="https://cli.vuejs.org/zh/dev-guide/plugin-dev.html">插件开发指南</a></li><li><a href="https://juejin.cn/post/6844903988781907975">妈妈：我会写 Vue-CLI 插件了 😸</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>vue</tag>
      
      <tag>vue-cli</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nestjs使用记录(一) - typeorm使用</title>
    <link href="/2022/07/01/2022-07-01-typeorm-apply-to-nestjs/"/>
    <url>/2022/07/01/2022-07-01-typeorm-apply-to-nestjs/</url>
    
    <content type="html"><![CDATA[<h1 id="背景"><a class="markdownIt-Anchor" href="#背景"></a> 背景</h1><p>最近维护的许多 toB 系统都使用 typeorm 并大量使用其中的装饰器<code>decorator</code> 进行 db 的 CRUD, 忙里偷闲稍微记录一下</p><h1 id="引言"><a class="markdownIt-Anchor" href="#引言"></a> 引言</h1><p>文章会使用 的例子并结合自身项目开发中的内容讲解</p><h1 id="typeorm-in-nestjs"><a class="markdownIt-Anchor" href="#typeorm-in-nestjs"></a> typeorm in nestjs</h1><h2 id="引入-db-配置"><a class="markdownIt-Anchor" href="#引入-db-配置"></a> 引入 db 配置</h2><h3 id="同步"><a class="markdownIt-Anchor" href="#同步"></a> 同步</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js">@<span class="hljs-title class_">Module</span>(&#123;<br>  <span class="hljs-attr">imports</span>: [<br>    <span class="hljs-title class_">TypeOrmModule</span>.<span class="hljs-title function_">forRoot</span>(&#123;<br>      <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;postgres&#x27;</span>,<br>      <span class="hljs-attr">host</span>: <span class="hljs-string">&#x27;localhost&#x27;</span>,<br>      <span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;postgres&#x27;</span>,<br>      <span class="hljs-attr">password</span>: <span class="hljs-string">&#x27;pass&#x27;</span>,<br>      <span class="hljs-attr">port</span>: <span class="hljs-number">5432</span>,<br>      <span class="hljs-attr">database</span>: <span class="hljs-string">&#x27;shop&#x27;</span>,<br>      <span class="hljs-attr">entities</span>: [<span class="hljs-title class_">Product</span>],<br>      <span class="hljs-attr">subscribers</span>: [<span class="hljs-title class_">ProductSubscriber</span>],<br>      <span class="hljs-attr">synchronize</span>: <span class="hljs-literal">true</span>,<br>      <span class="hljs-attr">autoLoadEntities</span>: <span class="hljs-literal">true</span>,<br>      <span class="hljs-attr">logger</span>: <span class="hljs-string">&#x27;advanced-console&#x27;</span>,<br>      <span class="hljs-attr">logging</span>: <span class="hljs-string">&#x27;all&#x27;</span><br>    &#125;),<br>    <span class="hljs-title class_">ProductModule</span><br>  ],<br>  <span class="hljs-attr">controllers</span>: [<span class="hljs-title class_">AppController</span>],<br>  <span class="hljs-attr">providers</span>: [<span class="hljs-title class_">AppService</span>]<br>&#125;)<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppModule</span> &#123;&#125;<br></code></pre></td></tr></table></figure><h3 id="异步"><a class="markdownIt-Anchor" href="#异步"></a> 异步</h3><p>异步需要传入一个函数, 例子中是<code>getTypeORMConfig</code>, 函数返回值和同步引入一直</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">TypeOrmModule</span>.<span class="hljs-title function_">forRootAsync</span>(&#123;<br>  <span class="hljs-attr">useFactory</span>: getTypeORMConfig<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="引入-entity-或-repository"><a class="markdownIt-Anchor" href="#引入-entity-或-repository"></a> 引入 Entity 或 Repository</h2><p><code>Entity</code>是描述表结构的类, <code>Repository</code>是可以理解成自定义<code>Entity</code>, 可以在原有<code>Entity</code>基础上自定义方法</p><h3 id="entity"><a class="markdownIt-Anchor" href="#entity"></a> Entity</h3><p><code>@CreateDateColumn</code>, <code>UpdateDateColumn</code> 特殊列，自动设置为实体的插入/更新时间。 不需要在此列中手动写入值，该值会自动设置<br /><code>@DeleteDateColumn</code> 会在<code>soft-delete</code>时自动设置, 暂时没用到</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;<br>  <span class="hljs-title class_">Column</span>,<br>  <span class="hljs-title class_">CreateDateColumn</span>,<br>  <span class="hljs-title class_">DeleteDateColumn</span>,<br>  <span class="hljs-title class_">Entity</span>,<br>  <span class="hljs-title class_">PrimaryGeneratedColumn</span>,<br>  <span class="hljs-title class_">UpdateDateColumn</span><br>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;typeorm&#x27;</span>;<br><br>@<span class="hljs-title class_">Entity</span>()<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Product</span> &#123;<br>  @<span class="hljs-title class_">PrimaryGeneratedColumn</span>()<br>  <span class="hljs-attr">id</span>: number;<br><br>  @<span class="hljs-title class_">Column</span>(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;varchar&#x27;</span> &#125;)<br>  <span class="hljs-attr">name</span>: string;<br><br>  @<span class="hljs-title class_">Column</span>(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;numeric&#x27;</span> &#125;)<br>  <span class="hljs-attr">quantity</span>: number;<br><br>  @<span class="hljs-title class_">Column</span>(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;decimal&#x27;</span>, <span class="hljs-attr">precision</span>: <span class="hljs-number">12</span>, <span class="hljs-attr">scale</span>: <span class="hljs-number">2</span> &#125;)<br>  <span class="hljs-attr">price</span>: number;<br><br>  @<span class="hljs-title class_">Column</span>(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;boolean&#x27;</span>, <span class="hljs-attr">default</span>: <span class="hljs-literal">false</span> &#125;)<br>  <span class="hljs-attr">isDeleted</span>: boolean;<br><br>  @<span class="hljs-title class_">CreateDateColumn</span>()<br>  <span class="hljs-attr">createDate</span>: <span class="hljs-title class_">Date</span>;<br><br>  @<span class="hljs-title class_">UpdateDateColumn</span>()<br>  <span class="hljs-attr">updateDate</span>: <span class="hljs-title class_">Date</span>;<br><br>  @<span class="hljs-title class_">DeleteDateColumn</span>()<br>  <span class="hljs-attr">deleteDate</span>: <span class="hljs-title class_">Date</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="repository"><a class="markdownIt-Anchor" href="#repository"></a> Repository</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">@<span class="hljs-title class_">EntityRepository</span>(<span class="hljs-title class_">Product</span>) <span class="hljs-comment">// 传入entity</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DocumentRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Repository</span>&lt;<span class="hljs-title class_">Prository</span>&gt; &#123;<br>  <span class="hljs-keyword">async</span> <span class="hljs-title function_">findDocuments</span>(<span class="hljs-params"></span>) &#123;&#125;<br>  <span class="hljs-comment">// ...custom function</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="引入"><a class="markdownIt-Anchor" href="#引入"></a> 引入</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// app.module.ts</span><br>@<span class="hljs-title class_">Module</span>(&#123;<br>  <span class="hljs-attr">imports</span>: [<br>    <span class="hljs-title class_">TypeOrmModule</span>.<span class="hljs-title function_">forRootAsync</span>(&#123;<br>      <span class="hljs-attr">useFactory</span>: getTypeORMConfig,<br>    &#125;),<br>    <span class="hljs-title class_">TypeOrmModule</span>.<span class="hljs-title function_">forFeature</span>([  <span class="hljs-comment">// 可以传入entity或repository</span><br>      <span class="hljs-title class_">DocumentRepository</span>,<br>      <span class="hljs-title class_">HistoryRepository</span>,<br>      <span class="hljs-title class_">SystemRepository</span>,<br>      <span class="hljs-title class_">RetryRepository</span>,<br>    ]),<br>  ],<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="subscribe-listener"><a class="markdownIt-Anchor" href="#subscribe-listener"></a> subscribe listener</h2><p>typeorm 提供了一系列钩子监听各种操作并在操作之前/之后执行钩子中定义的方法, 看字面意思都知道这些钩子的触发时机, 就不一一介绍</p><ul><li>AfterLoad</li><li>AfterInsert</li><li>BeforeInsert</li><li>AfterUpdate</li><li>BeforeUpdate</li><li>AfterRemove</li><li>BeforeRemove</li></ul><h3 id="定义-subcriber"><a class="markdownIt-Anchor" href="#定义-subcriber"></a> 定义 subcriber</h3><p><code>listenTo</code>设置表示监听的 entity/repository, 不设置则表示监听所有 entity/repository</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">EntitySubscriberInterface</span>, <span class="hljs-title class_">EventSubscriber</span>, <span class="hljs-title class_">UpdateEvent</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;typeorm&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Product</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./product.entity&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Logger</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@nestjs/common&#x27;</span>;<br><br>@<span class="hljs-title class_">EventSubscriber</span>()<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProductSubscriber</span> implements <span class="hljs-title class_">EntitySubscriberInterface</span>&lt;<span class="hljs-title class_">Product</span>&gt; &#123;<br>  <span class="hljs-title function_">listenTo</span>(): any &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Product</span>;<br>  &#125;<br><br>  <span class="hljs-title function_">afterUpdate</span>(<span class="hljs-attr">event</span>: <span class="hljs-title class_">UpdateEvent</span>&lt;<span class="hljs-title class_">Product</span>&gt;): <span class="hljs-title class_">Promise</span>&lt;any&gt; | <span class="hljs-keyword">void</span> &#123;<br>    <span class="hljs-keyword">const</span> priceGotUpdated = event.<span class="hljs-property">updatedColumns</span>.<span class="hljs-title function_">find</span>(<br>      <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> value.<span class="hljs-property">propertyName</span>,<br>      <span class="hljs-title class_">Product</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">price</span><br>    );<br>    <span class="hljs-keyword">if</span> (priceGotUpdated) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Number</span>(event.<span class="hljs-property">databaseEntity</span>.<span class="hljs-property">price</span>) !== event.<span class="hljs-property">entity</span>.<span class="hljs-property">price</span>) &#123;<br>        <span class="hljs-title class_">Logger</span>.<span class="hljs-title function_">log</span>(<br>          <span class="hljs-string">`Price changed from </span><br><span class="hljs-string">        <span class="hljs-subst">$&#123;event.databaseEntity.price&#125;</span> to </span><br><span class="hljs-string">        <span class="hljs-subst">$&#123;event.entity.price&#125;</span>`</span>,<br>          <span class="hljs-string">&#x27;Product Price Updated&#x27;</span><br>        );<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="引入-2"><a class="markdownIt-Anchor" href="#引入-2"></a> 引入</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// app.module.ts</span><br>@<span class="hljs-title class_">Module</span>(&#123;<br>  <span class="hljs-attr">imports</span>: [<br>    <span class="hljs-title class_">TypeOrmModule</span>.<span class="hljs-title function_">forRootAsync</span>(&#123;<br>      <span class="hljs-attr">useFactory</span>: getTypeORMConfig,<br>    &#125;),<br>    <span class="hljs-title class_">TypeOrmModule</span>.<span class="hljs-title function_">forFeature</span>([<br>      <span class="hljs-title class_">DocumentRepository</span>,<br>      <span class="hljs-title class_">HistoryRepository</span>,<br>      <span class="hljs-title class_">SystemRepository</span>,<br>      <span class="hljs-title class_">RetryRepository</span>,<br>    ]),<br>  ],<br>  <span class="hljs-attr">providers</span>: [<span class="hljs-title class_">DocumentSubscriber</span>],<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="在-service-中使用-repository"><a class="markdownIt-Anchor" href="#在-service-中使用-repository"></a> 在 service 中使用 repository</h2><ol><li>直接在构造函数中初始化</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// nestjs</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProductService</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span><br><span class="hljs-params">    @InjectRepository(Template)</span><br><span class="hljs-params">    private readonly templateRepository: Repository&lt;Template&gt;</span><br><span class="hljs-params">  </span>) &#123;&#125;<br>&#125;<br><br><span class="hljs-comment">// eggjs</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProductService</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">ctx: Context</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(ctx);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">repo</span> = <span class="hljs-title function_">getRepository</span>(<span class="hljs-title class_">Template</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>对方法使用<code>@Transaction</code>, <code>@TransactionRepository</code></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">@<span class="hljs-title class_">Transaction</span><br>public <span class="hljs-keyword">async</span> <span class="hljs-title function_">create</span>(<span class="hljs-params"></span><br><span class="hljs-params">  @TransactionRepository(Template) templateRepository: Repository&lt;Template&gt;</span><br><span class="hljs-params"></span>) &#123;<br>  actRepository.<span class="hljs-title function_">save</span>(...)<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="reference"><a class="markdownIt-Anchor" href="#reference"></a> reference</h1><ol><li><a href="https://medium.com/@Semyonic/subscribers-a-k-a-entity-listeners-of-typeorm-on-nestjs-a97ac75acc2d">Subscribers a.k.a Entity Listeners of TypeORM on NestJS</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>nestjs</tag>
      
      <tag>typeorm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>开发nodejs cli过程记录</title>
    <link href="/2022/06/22/2022-06-22-how-to-write-a-node-cli-tool/"/>
    <url>/2022/06/22/2022-06-22-how-to-write-a-node-cli-tool/</url>
    
    <content type="html"><![CDATA[<h1 id="背景"><a class="markdownIt-Anchor" href="#背景"></a> 背景</h1><p>阅读组里常用的 node 编写的 cli 源码记录</p><h1 id="npm-packages"><a class="markdownIt-Anchor" href="#npm-packages"></a> npm packages</h1><p>介绍一些开发 cli 工具很实用的 npm 包</p><h2 id="command-exists"><a class="markdownIt-Anchor" href="#command-exists"></a> command-exists</h2><blockquote><p>node module to check if a command-line command exists</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> commandExists = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;command-exists&#x27;</span>);<br><span class="hljs-comment">// 异步用法</span><br><span class="hljs-title function_">commandExits</span>(<span class="hljs-string">&#x27;ls&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, commandExists</span>) =&gt;</span> &#123;...&#125;);<br><span class="hljs-comment">// 同步用法</span><br>commandExists.<span class="hljs-title function_">sync</span>(<span class="hljs-string">&#x27;ls&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="fs-extra"><a class="markdownIt-Anchor" href="#fs-extra"></a> fs-extra</h2><blockquote><p>fs-extra adds file system methods that aren’t included in the native fs module and adds promise support to the fs methods. It also uses graceful-fs to prevent EMFILE errors. It should be a drop in replacement for fs.<br />fs-extra 提供了很多 fs 的扩展操作例如复制, 清空等操作, 相当好用<br />整理一些比较使用的 api:</p></blockquote><ol><li><code>emptyDir</code>: 字面意思，清空文件夹</li><li><code>readJSON</code>: Reads a JSON file and then parses it into an object.</li><li><code>writeJSON</code>: Write a JSON object stringified into file</li></ol><h2 id="ora"><a class="markdownIt-Anchor" href="#ora"></a> ora</h2><blockquote><p>Elegant terminal spinner</p></blockquote><p>用于优雅输出终端提示文案<br />以下是小 demo 及运行输出:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> ora = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;ora&quot;</span>);<br><span class="hljs-keyword">const</span> spinner = <span class="hljs-title function_">ora</span>(<span class="hljs-string">&quot;default text&quot;</span>).<span class="hljs-title function_">start</span>(<span class="hljs-string">&quot;default text 2&quot;</span>);<br><span class="hljs-comment">// spinner.text = &#x27;Loading rainbows&#x27;;</span><br>spinner.<span class="hljs-title function_">info</span>(<span class="hljs-string">&quot;hello world&quot;</span>);<br>spinner.<span class="hljs-title function_">succeed</span>(<span class="hljs-string">&quot;hello world&quot;</span>);<br>spinner.<span class="hljs-title function_">fail</span>(<span class="hljs-string">&quot;hello world&quot;</span>);<br>spinner.<span class="hljs-title function_">succeed</span>();<br></code></pre></td></tr></table></figure><p><img src="https://dev.azure.com/HealMSlin/8544be09-1224-4eb0-824b-90c4ec9d49ee/_apis/git/repositories/7a27a721-4c93-4ecf-8258-d5422217b60a/items?path=%2F1661877086095_5819.png&amp;versionDescriptor%5BversionOptions%5D=0&amp;versionDescriptor%5BversionType%5D=0&amp;versionDescriptor%5Bversion%5D=master&amp;resolveLfs=true&amp;%24format=octetStream&amp;api-version=5.0" alt="" /><br />其中<code>ora</code>需要实例化为<code>spinner</code>使用, <code>ora()</code>, <code>start()</code>参数为<code>string</code>时都表示默认输出文本, <code>spinner.text</code>同理, 后设置的优先级更高, 在<code>spinner.xxx()</code>未传入参数时会输出默认文本</p><h3 id="tips"><a class="markdownIt-Anchor" href="#tips"></a> tips</h3><p>最新版本的<code>ora</code>只能使用 ESModule 引入, commonjs 方式引入请使用 v4 版本</p><h1 id="实用操作"><a class="markdownIt-Anchor" href="#实用操作"></a> 实用操作</h1><h2 id="查看包的最新版本和所有版本"><a class="markdownIt-Anchor" href="#查看包的最新版本和所有版本"></a> 查看包的最新版本和所有版本</h2><p>查看最新版本</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">npm view package-name versions --json<br><span class="hljs-comment">// or</span><br>yarn info package-name versions --json<br></code></pre></td></tr></table></figure><p>查看所有版本</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">npm view package-name version --json<br><span class="hljs-comment">// &quot;1.0.1205&quot;</span><br><span class="hljs-comment">// or</span><br>yarn info package-name version --json<br><span class="hljs-comment">// &#123;&quot;type&quot;:&quot;inspect&quot;,&quot;data&quot;:&quot;1.0.1205&quot;&#125;</span><br></code></pre></td></tr></table></figure><h2 id="processcwd和__dirname"><a class="markdownIt-Anchor" href="#processcwd和__dirname"></a> process.cwd()和__dirname</h2><p>这两个命令行的输出在开发 cli 这种全局包中区别尤为明显</p><p><code>process.cwd()</code>: 返回当前工作目录。可以通过<code>process.chdir()</code>更改.<br /><code>__dirname</code>返回源代码所在的目录。</p><h2 id="spawn"><a class="markdownIt-Anchor" href="#spawn"></a> spawn</h2><p>我们使用 spawn 执行 linux 命令后如何获得对应的输出呢? 看源码时使用了两种方式, 两种都可以<br />先看下如何使用 spawn</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> &#123; spawn &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;child_process&quot;</span>);<br><span class="hljs-keyword">const</span> ls = <span class="hljs-title function_">spawn</span>(<span class="hljs-string">&quot;ls&quot;</span>, [<span class="hljs-string">&quot;-la&quot;</span>], &#123;&#125;);<br></code></pre></td></tr></table></figure><ol><li>spawn 第三个参数中<code>stdio</code>默认值为 <code>pipe</code>, 相当于<code>相当于 ['pipe', 'pipe', 'pipe']</code>, 对应<code>stdin</code>, <code>stdout</code>, <code>stderr</code>.<br /><code>pipe</code>会在子进程和父进程之间创建管道。子进程的标准输入、标准输出和标准错误被重定向到 ChildProcess 对象上相应的 subprocess.stdin、subprocess.stdout 和 subprocess.stderr 流。默认情况下子进程的输出父进程是看不到的, 需要使用以下方式。这里<code>stdio: 'pipe'</code>很容易误解</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">ls.<span class="hljs-property">stdout</span>.<span class="hljs-title function_">setEncoding</span>(<span class="hljs-string">&quot;utf8&quot;</span>);<br>ls.<span class="hljs-property">stdout</span>.<span class="hljs-title function_">pipe</span>(process.<span class="hljs-property">stdout</span>);<br><span class="hljs-comment">// or</span><br>ls.<span class="hljs-property">stdout</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;data&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) &#123;<br>  process.<span class="hljs-property">stdout</span>.<span class="hljs-title function_">write</span>(data);<br>&#125;);<br></code></pre></td></tr></table></figure><ol start="2"><li>设置<code>stdio: 'inherit'</code>, 通过相应的标准输入输出流传入/传出父进程, 子进程直接使用父进程的流。 在前三个位置，这分别相当于 process.stdin、process.stdout 和 process.stderr。对于说明性的内容可以直接使用<code>stdio: 'inherit'</code>, 对于需要处理的输出数据, 默认即可, 通过<code>stdout.on('data')</code>处理数据</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> ls = <span class="hljs-title function_">spawn</span>(<span class="hljs-string">&quot;ls&quot;</span>, [<span class="hljs-string">&quot;-la&quot;</span>], &#123; <span class="hljs-attr">stdio</span>: <span class="hljs-string">&quot;inherit&quot;</span> &#125;);<br><span class="hljs-comment">// 会直接输出ls -la的内容, 无法通过ondata监听stdout, stderr还是可以监听</span><br><span class="hljs-comment">// 使用process.stdout无法ondata, 使用ls.stdout.ondata也是会报错的</span><br></code></pre></td></tr></table></figure><h2 id="cwd"><a class="markdownIt-Anchor" href="#cwd"></a> cwd</h2><p>spawn 第三个参数中支持 cwd 表示子进程命令要运行的目录, 例如<code>yarn link</code>就需要指定目录才能正常</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> child = <span class="hljs-title function_">spawn</span>(<span class="hljs-string">&quot;yarn&quot;</span>, [<span class="hljs-string">&quot;link&quot;</span>], &#123; <span class="hljs-attr">cwd</span>: xx &#125;);<br></code></pre></td></tr></table></figure><h2 id="requireresolve"><a class="markdownIt-Anchor" href="#requireresolve"></a> require.resolve</h2><p>一般用于获取 npm 包的绝对路径, 如果当前源码运行的目录<code>node_modules</code>不存在这个包, 会直接抛出异常, 用法如下:<br />博主只用到了模块路径的使用方法, <code>require.resolve</code>会在执行这个函数的目录开始逐级往外查找查找<code>node_modules</code>, 按照这样的搜索顺序<code>[&quot;/Users/enhanced-resolve/node_modules&quot;, &quot;/Users/node_modules&quot;, &quot;/node_modules&quot;]</code><br />具体可以参考<a href="https://juejin.cn/post/6844904055806885895">node 的路径解析 require.resolve</a><br /><strong><code>require.resolve和process.cwd()不同, process.chdir()无法更改查找路径</code></strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 获取包所在的目录绝对路径</span><br>path.<span class="hljs-title function_">join</span>(<span class="hljs-built_in">require</span>.<span class="hljs-title function_">resolve</span>($&#123;moduleName&#125;/package.<span class="hljs-property">json</span>), <span class="hljs-string">&#x27;..&#x27;</span>)<br><span class="hljs-comment">// 不加package.json 默认找index.js</span><br></code></pre></td></tr></table></figure><h1 id="reference"><a class="markdownIt-Anchor" href="#reference"></a> reference</h1><ol><li><a href="http://nodejs.cn/api/child_process.html#optionsstdio">nodejs 官方文档 child_process</a></li><li><a href="https://juejin.cn/post/6844904055806885895">node 的路径解析 require.resolve</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>node</tag>
      
      <tag>cli</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>whistle实用操作记录</title>
    <link href="/2022/06/16/2022-06-16-whistle-config-record/"/>
    <url>/2022/06/16/2022-06-16-whistle-config-record/</url>
    
    <content type="html"><![CDATA[<h1 id="背景"><a class="markdownIt-Anchor" href="#背景"></a> 背景</h1><p>背景其实也是和同事闲聊, 然后聊到这个, 就尝试了下, 总结了三种方法</p><h1 id="whistle-部分请求不走代理"><a class="markdownIt-Anchor" href="#whistle-部分请求不走代理"></a> whistle 部分请求不走代理</h1><p>试想一个场景要把域名<code>www.abc.com</code>代理到某台机器 ip, 但是<code>www.abc.com/api</code>不走代理, 可以</p><ol><li>第一种最简单的, 写对应匹配的正则表达式, 但是需要比较熟练的正则使用经历</li></ol><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">/www</span>\<span class="hljs-string">.abc</span>\<span class="hljs-string">.com</span>\/?!<span class="hljs-params">(api)</span>/ 127.0.0.1<br></code></pre></td></tr></table></figure><ol start="2"><li>使用<code>ignore://host</code>, 这里还支持 ignore file, sock 之类的, 还需要看代理的映射</li></ol><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">www<span class="hljs-selector-class">.abc</span><span class="hljs-selector-class">.com</span> <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span><br>www<span class="hljs-selector-class">.abc</span>.com/api ignore:<span class="hljs-comment">//host</span><br></code></pre></td></tr></table></figure><ol start="3"><li><code>excludeFilter</code>(我还没试过, 不过同事说可以诶嘿)</li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">www.abc.com excludeFilter:<span class="hljs-regexp">//</span><span class="hljs-regexp">/(api)/</span><br></code></pre></td></tr></table></figure><p>更多的例如请求头过滤, <code>includeFilter</code>, 可以参考<a href="https://cloud.tencent.com/edu/learning/course-2605-50298">https://cloud.tencent.com/edu/learning/course-2605-50298</a></p><h1 id="reference"><a class="markdownIt-Anchor" href="#reference"></a> reference</h1><ol><li><a href="https://cloud.tencent.com/edu/learning/course-2605-50298">ignore</a></li><li><a href="https://wproxy.org/whistle/rules/filter.html">filter</a></li><li><a href="https://cloud.tencent.com/edu/learning/course-2605-50298">pipe-过滤规则</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>whistle</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>react脚手架中使用sass/less modules</title>
    <link href="/2022/06/13/2022-06-13-react-css-module/"/>
    <url>/2022/06/13/2022-06-13-react-css-module/</url>
    
    <content type="html"><![CDATA[<h1 id="背景"><a class="markdownIt-Anchor" href="#背景"></a> 背景</h1><p>还是在看 react 项目代码时发现引入 css 时并不是直接<code>import 'xx.less'</code>, 而是通过<code>import style from 'xx.less'</code>的方式引入, 前者引入实际上是全局的 css 配置, 可能会全局污染别的组件, 而后者则通过 css module 的方式使 css 只作用于当前组件</p><h1 id="配置-css-module"><a class="markdownIt-Anchor" href="#配置-css-module"></a> 配置 css module</h1><p>配置中的<code>importLoaders</code>必须是 3</p><h2 id="sass"><a class="markdownIt-Anchor" href="#sass"></a> sass</h2><p><code>create-react-app</code>react 的脚手架默认支持了 sass, 所以不需要额外安装 sass 及 sass-loader, 同时也支持了 sass in css module, 通过<code>npm run eject</code>可以看到 webpack 中对应的配置.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// Adds support for CSS Modules, but using SASS</span><br><span class="hljs-comment">// using the extension .module.scss or .module.sass</span><br>&#123;<br>  <span class="hljs-attr">test</span>: sassModuleRegex,<br>  <span class="hljs-attr">use</span>: <span class="hljs-title function_">getStyleLoaders</span>(<br>    &#123;<br>      <span class="hljs-attr">importLoaders</span>: <span class="hljs-number">3</span>,<br>      <span class="hljs-attr">sourceMap</span>: isEnvProduction ? shouldUseSourceMap : isEnvDevelopment,<br>      <span class="hljs-attr">modules</span>: &#123;<br>        <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;local&#x27;</span>,<br>        <span class="hljs-attr">getLocalIdent</span>: getCSSModuleLocalIdent,<br>      &#125;,<br>    &#125;,<br>    <span class="hljs-string">&#x27;sass-loader&#x27;</span>,<br>  ),<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="importloader"><a class="markdownIt-Anchor" href="#importloader"></a> importLoader</h3><p>这里<code>importLoader</code>作用于<code>css-loader</code>, 必须是 3 的原因是, <code>sass-loader</code>前面还有<code>postcss-loader</code>和<code>css-loader</code>正好三个 loader</p><h2 id="less"><a class="markdownIt-Anchor" href="#less"></a> less</h2><p>脚手架默认不支持 less, 先安装 less 和 less-loader</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yarn add less less-loader<br></code></pre></td></tr></table></figure><p>然后配置 webpack, 如果要支持<code>import .. from</code>需要设置<code>module: true</code>, 需要注意的是,直接 import 和 import…from 是<strong>互斥</strong>的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.less$/</span>,<br>  <span class="hljs-attr">use</span>: <span class="hljs-title function_">getStyleLoaders</span>(<br>    &#123;<br>      <span class="hljs-attr">modules</span>: <span class="hljs-literal">true</span>,<br>      <span class="hljs-attr">importLoaders</span>: <span class="hljs-number">3</span>,<br>      <span class="hljs-attr">sourceMap</span>: isEnvProduction &amp;&amp; shouldUseSourceMap,<br>    &#125;,<br>    <span class="hljs-string">&#x27;less-loader&#x27;</span>,<br>  ),<br>  <span class="hljs-comment">// Don&#x27;t consider CSS imports dead code even if the</span><br>  <span class="hljs-comment">// containing package claims to have no side effects.</span><br>  <span class="hljs-comment">// Remove this when webpack adds a warning or an error for this.</span><br>  <span class="hljs-comment">// See https://github.com/webpack/webpack/issues/6571</span><br>  <span class="hljs-attr">sideEffects</span>: <span class="hljs-literal">true</span>,<br>&#125;,<br></code></pre></td></tr></table></figure><h1 id="使用-css-modules"><a class="markdownIt-Anchor" href="#使用-css-modules"></a> 使用 css modules</h1><h2 id="sass-2"><a class="markdownIt-Anchor" href="#sass-2"></a> sass</h2><ol><li>新建<code>[name].module.scss</code>, 文件名必须带有<em>module</em>, 否则不会被识别为 css modules</li><li>在 tsx 中使用</li></ol><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// style.scss</span><br><span class="hljs-selector-class">.hd</span> &#123;<br>  <span class="hljs-attribute">color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> style <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./style.module.scss&#x27;</span>;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#123;style.hd&#125;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span>;<br></code></pre></td></tr></table></figure><h2 id="less-2"><a class="markdownIt-Anchor" href="#less-2"></a> less</h2><ol><li>随便新建<code>[name].less</code></li><li>(optional)如果使用的是 typescript, 默认 typescript 无法识别<code>import xx from 'xx.less</code>, 会报错<strong>TS2307: Cannot find module ‘./style.less’ or its corresponding type declarations.</strong>, 需要在<code>src/</code>下新建<code>react-app-env.d.ts</code>, 把下面声明加到文件中, 错误消失</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// react-app-env.d.ts</span><br><span class="hljs-keyword">declare</span> <span class="hljs-variable language_">module</span> <span class="hljs-string">&#x27;*.less&#x27;</span> &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">content</span>: &#123; [<span class="hljs-attr">className</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">string</span> &#125;;<br>  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> content;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>使用方法同 sass</li></ol><h1 id="reference"><a class="markdownIt-Anchor" href="#reference"></a> reference</h1><ol><li><a href="https://stackoverflow.com/questions/57749719/using-less-files-with-react">Using .less files with React</a></li><li><a href="https://juejin.cn/post/7031528538209681444">react 中 css modules-基本使用</a></li><li><a href="https://zhuanlan.zhihu.com/p/94706976">css-loader 中 importLoaders 的理解</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>react</tag>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AntDesign, ProComponent使用踩坑</title>
    <link href="/2022/06/09/2022-06-09-ant-design-in-use/"/>
    <url>/2022/06/09/2022-06-09-ant-design-in-use/</url>
    
    <content type="html"><![CDATA[<p><a href="https://ant.design/">ant-design 官网</a><br /><a href="https://procomponents.ant.design/">ProComponent 官网</a></p><h1 id="背景"><a class="markdownIt-Anchor" href="#背景"></a> 背景</h1><p>最近有个需求迭代要修改中台系统, 该系统是使用 react + ant-design + ProComponent 搭建#的, 记录下遇到的问题</p><h1 id="遇到的问题"><a class="markdownIt-Anchor" href="#遇到的问题"></a> 遇到的问题</h1><h2 id="1-ant-design-设置表单的validator一直显示xxx-is-not-a-valid-undefined"><a class="markdownIt-Anchor" href="#1-ant-design-设置表单的validator一直显示xxx-is-not-a-valid-undefined"></a> 1. ant-design 设置表单的<code>validator</code>一直显示<code>xxx is not a valid undefined</code></h2><p>ant-design 中表单校验默认<code>type</code>都是<code>string</code>, 报错本来想显示的是<code>xxx is not a valid number</code>之类, 如果要检验别的类型检查是否没有配置<code>type</code>, 如下所示:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-attr">min</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-attr">max</span>: <span class="hljs-number">10</span>,<br>  <span class="hljs-attr">transform</span>: <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> +value,<br>  <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;请输入xx&#x27;</span>,<br>  <span class="hljs-comment">// type: &#x27;number&#x27;,  // 需要配置哦</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-procomponent-中-form-表单项设置初始值失败"><a class="markdownIt-Anchor" href="#2-procomponent-中-form-表单项设置初始值失败"></a> 2. ProComponent 中 form 表单项设置初始值失败</h2><p>这个问题, 官方文档已经做了解释, 是我不会看文档(别骂了别骂了):</p><blockquote><p>你不能用控件的 value 或 defaultValue 等属性来设置表单域的值，默认值可以用 Form 里的 initialValues 来设置。注意 initialValues 不能被 setState 动态更新，你需要用 setFieldsValue 来更新。 你不应该用 setState，可以使用 form.setFieldsValue 来动态改变表单值。</p></blockquote><p><code>initialValue</code>如果一开始就在<code>columns</code>中定义好是会生效的, 但是我的需求场景是通过请求动态获取<code>initialValue</code>, form 中内部托管了数据处理, 所以下面这样写是不会生效的:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> options = your code;<br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">columns$</span>: any[] = [...columns];<br>    columns$.<span class="hljs-title function_">splice</span>(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, &#123;<br>      <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;xxx&#x27;</span>,<br>      <span class="hljs-attr">dataIndex</span>: <span class="hljs-string">&#x27;xxx&#x27;</span>,<br>      <span class="hljs-attr">valueType</span>: <span class="hljs-string">&#x27;select&#x27;</span>,<br>      <span class="hljs-attr">valueEnum</span>: your code,<br>      <span class="hljs-attr">initialValue</span>: options,<br>    &#125;);<br>    <span class="hljs-title function_">setColumns</span>(columns$);<br>  &#125;, [xxx]);<br></code></pre></td></tr></table></figure><p>需要这样:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// ts</span><br><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> options = your code;<br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">columns$</span>: any[] = [...columns];<br>    columns$.<span class="hljs-title function_">splice</span>(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, &#123;<br>      <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;xxx&#x27;</span>,<br>      <span class="hljs-attr">dataIndex</span>: <span class="hljs-string">&#x27;xxx&#x27;</span>,<br>      <span class="hljs-attr">valueType</span>: <span class="hljs-string">&#x27;select&#x27;</span>,<br>      <span class="hljs-attr">valueEnum</span>: your code,<br>    &#125;);<br>    form.<span class="hljs-title function_">setFieldsValue</span>(&#123; <span class="hljs-attr">templateTitle</span>: options &#125;);<br>    <span class="hljs-title function_">setColumns</span>(columns$);<br>  &#125;, [xxx]);<br><br><span class="hljs-comment">// tsx</span><br><span class="hljs-keyword">const</span> [form] = <span class="hljs-title function_">useForm</span>();<br><span class="hljs-keyword">return</span> (<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ProTable</span> <span class="hljs-attr">form</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">form</span> &#125;&#125; /&gt;</span></span>)<br></code></pre></td></tr></table></figure><h2 id="3-protable-params-变化不触发-request"><a class="markdownIt-Anchor" href="#3-protable-params-变化不触发-request"></a> 3. ProTable params 变化不触发 request</h2><p>这个问题我定位了半天, 一直以为是 params 变更比较出了问题, 事实上查阅 issue<a href="https://github.com/ant-design/pro-table/issues/174">🐛[BUG] params 更新无法触发 request</a>证明 params 确实也是浅比较, 但是问题并不出在这…<br />查阅 issue<a href="https://github.com/ant-design/pro-components/issues/2750">🐛[BUG]pro-table 中如果 request 中有 await，当 params 变更后不会再次触发 request</a>发现, <strong>ProTable 的 request 中如果上一个请求还没返回数据, 下一个请求时会被拦截的并不会触发</strong>, 然后来看下代码中的逻辑:</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs tsx">&lt;<span class="hljs-title class_">ProTable</span>&lt;<span class="hljs-title class_">TableListItem</span>&gt;<br>  &#123;...your other config&#125;<br>  params=&#123;&#123; templateList, systemId, status &#125;&#125;<br>  request=&#123;<span class="hljs-function">(<span class="hljs-params">params, sorter, filter</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// if (templateList?.length) &#123;</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">queryDocuments</span>(&#123;...params&#125;);<br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">data</span>: [],<br>      <span class="hljs-attr">success</span>: <span class="hljs-literal">true</span>,<br>      <span class="hljs-attr">total</span>: <span class="hljs-number">0</span>,<br>    &#125;;<br>  &#125;&#125;<br>  form=&#123;&#123; form &#125;&#125;<br>/&gt;<br></code></pre></td></tr></table></figure><p>其中 <code>systemId</code>和<code>templateList</code>变化都会触发<code>request</code>, 并且更新时间差不多,这就导致<code>systemId</code>触发的 request 还没返回数据, <code>templateList</code>触发的 request 被截断了, 甚至不是阻塞…issue 中大家都觉得这是不合理的, 是个 bug, 但是作者觉得没啥问题…(行 ⑧)</p><p>所以 这里需要加个<code>if</code>判断只触发<code>templateList</code>更新时的请求</p><h2 id="在-typeorm-中使用-in"><a class="markdownIt-Anchor" href="#在-typeorm-中使用-in"></a> 在 typeorm 中使用 in</h2><p>需求场景还需要支持多选搜索, 所以原先 sql 中的<code>=</code>需要变更为<code>in</code>, 顺便记录下 typeorm 下的 sql 要怎么写</p><h3 id=""><a class="markdownIt-Anchor" href="#"></a> =</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts">query.<span class="hljs-title function_">andWhere</span>(<span class="hljs-string">&#x27;xxx.templateId = :templateId&#x27;</span>, &#123; templateId &#125;);<br><span class="hljs-comment">// 或</span><br>query.<span class="hljs-title function_">andWhere</span>(<span class="hljs-string">`xxx.templateId = <span class="hljs-subst">$&#123;templateId&#125;</span>`</span>);<br></code></pre></td></tr></table></figure><h3 id="in"><a class="markdownIt-Anchor" href="#in"></a> in</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts">query.<span class="hljs-title function_">andWhere</span>(<span class="hljs-string">&#x27;xxx.templateTitle in (:templateTitle)&#x27;</span>, &#123; templateTitle &#125;); <span class="hljs-comment">// templateTitle是数组</span><br></code></pre></td></tr></table></figure><h1 id="reference"><a class="markdownIt-Anchor" href="#reference"></a> reference</h1><ol><li><a href="https://github.com/ant-design/pro-components/issues/2750">🐛[BUG]pro-table 中如果 request 中有 await，当 params 变更后不会再次触发 request</a></li><li><a href="https://github.com/ant-design/pro-table/issues/174">🐛[BUG] params 更新无法触发 request</a></li><li><a href="https://procomponents.ant.design/components/table?current=1&amp;pageSize=5#protable">ProComponent</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>ant-design</tag>
      
      <tag>react</tag>
      
      <tag>ProComponent</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅析tsconfig.json中module, moduleResolution, target, lib的作用</title>
    <link href="/2022/05/15/2022-05-15-tsconfig-confused-field-explain/"/>
    <url>/2022/05/15/2022-05-15-tsconfig-confused-field-explain/</url>
    
    <content type="html"><![CDATA[<h1 id="背景"><a class="markdownIt-Anchor" href="#背景"></a> 背景</h1><ol><li>业务部门这一年全面拥抱 typescript, 再也不直接使用 js 编写代码。但是我们知道 ts 实际上还是会被编译成 js 的，<code>tsconfig.json</code>则起到重要作用, 其中<code>module</code>, <code>moduleResolution</code>, <code>target</code>, <code>lib</code>这些 field 及其 value 长得好像都差不多, 所以一直没搞清楚这些 field 是做什么的</li></ol><h1 id="module"><a class="markdownIt-Anchor" href="#module"></a> module</h1><p>定义<strong>模块解决方案</strong>, typescript 中都是通过<code>import/export</code>处理模块, 但编译成 js 存在<code>AMD</code>, <code>CMD</code>, <code>ES20XX</code>, <code>commonjs</code>等多重模块解决方案, 这里的建议是运行在浏览器的项目使用<code>ES20XX</code>, 因为现代浏览器大多已经原生支持<code>import/export</code>; 运行在 node.js 的项目使用<code>commonjs</code>, 高版本的 node 版本才开始支持<code>import/export</code>, <code>commonjs</code>会使用<code>module.export/require</code>引入模块, 其余值很少用到.</p><h2 id="不同-module-编译出的代码"><a class="markdownIt-Anchor" href="#不同-module-编译出的代码"></a> 不同 module 编译出的代码</h2><h3 id="commonjs"><a class="markdownIt-Anchor" href="#commonjs"></a> <strong>commonjs</strong></h3><p><img src="https://raw.githubusercontent.com/Mariana-Yui/images/master/blog-imgs/20220524-exp4.png" alt="" /></p><h3 id="es20xx"><a class="markdownIt-Anchor" href="#es20xx"></a> <strong>es20xx</strong></h3><p><img src="https://raw.githubusercontent.com/Mariana-Yui/images/master/blog-imgs/20220524-exp3.png" alt="" /></p><p><strong>如果明确项目是运行在高版本 node, 可以尝试使用<code>ES20XX</code>, 但是也需要注意引入的第三方 npm 包是否支持, 在 nestjs 中尝试使用<code>ES20XX</code>就会有报错, 于是老老实实的使用<code>commonjs</code></strong><br /><img src="https://raw.githubusercontent.com/Mariana-Yui/images/master/blog-imgs/20220524-exp1.png" alt="" /></p><h1 id="moduleresolution"><a class="markdownIt-Anchor" href="#moduleresolution"></a> moduleResolution</h1><p>定义编译器如何<strong>找到(处理)引入的包文件</strong>, 共有两种可用的模块解析策略: <code>node</code>和<code>classic</code>, <code>node</code>是 typescript 现在默认的解析策略, <code>classic</code>更多是用于向下兼容, 很少回去配置改 field, 保持默认即可</p><h1 id="target"><a class="markdownIt-Anchor" href="#target"></a> target</h1><p>定义<strong>编译为什么版本的代码</strong>, 我们都知道,es2015~es20xx 每年都会新增新的 api 和新的语法, 例如 es2017 之后可以使用<code>async/await</code>, target 设置为<code>es2017</code>编译时<code>tsc</code>就不会对该语法做 polyfill, 设置为<code>es2015</code>就会进行 polyfill</p><h2 id="不同-target-编译出的代码"><a class="markdownIt-Anchor" href="#不同-target-编译出的代码"></a> 不同 target 编译出的代码</h2><p>可以看到当设置 es2015 时会对<code>async/await</code>做 polyfill</p><h3 id="es2017"><a class="markdownIt-Anchor" href="#es2017"></a> <strong>es2017</strong></h3><p><img src="https://raw.githubusercontent.com/Mariana-Yui/images/master/blog-imgs/20220524-exp5.png" alt="" /></p><h3 id="es2015"><a class="markdownIt-Anchor" href="#es2015"></a> <strong>es2015</strong></h3><p><img src="https://raw.githubusercontent.com/Mariana-Yui/images/master/blog-imgs/20220524-exp6.png" alt="" /></p><h1 id="lib"><a class="markdownIt-Anchor" href="#lib"></a> lib</h1><p>定义支持的<strong>类型声明</strong>, 大部分情况下都是和 target 一致, 除了一些特殊场景, 比如: 1. target 设置了 es5 但是存在对 Promise 的 polyfill 处理 2. 运行在浏览器中需要 BOM/DOM 对象类型声明, 可以设置数组</p><h1 id="ts-or-babel"><a class="markdownIt-Anchor" href="#ts-or-babel"></a> ts or babel</h1><p>另外 typescript 是可以直接代码编译为 es5 的, 但是目前业界前端打包方案还是愿意将 babel 和 typescript 结合使用, 反正是有好处=。=</p><blockquote><p>babel 和 ts 都会转换语法，两者是冲突的，一般不会同时出现。然后 Promise 是 api，Symbol 是内置类型，api 可以通过 polyfill 在不支持的环境上获得支持，但类型不支持就是不支持，没有 polyfill。而且现代浏览器基本都支持 promise 和 symbol，没什么好担忧的</p></blockquote><h1 id="reference"><a class="markdownIt-Anchor" href="#reference"></a> reference</h1><ol><li><a href="https://medium.com/@tommedema/typescript-confusion-tsconfig-json-module-moduleresolution-target-lib-explained-65db2c44b491#id_token=eyJhbGciOiJSUzI1NiIsImtpZCI6ImIxYTgyNTllYjA3NjYwZWYyMzc4MWM4NWI3ODQ5YmZhMGExYzgwNmMiLCJ0eXAiOiJKV1QifQ.eyJpc3MiOiJodHRwczovL2FjY291bnRzLmdvb2dsZS5jb20iLCJuYmYiOjE2NTI2MTEyMzgsImF1ZCI6IjIxNjI5NjAzNTgzNC1rMWs2cWUwNjBzMnRwMmEyamFtNGxqZGNtczAwc3R0Zy5hcHBzLmdvb2dsZXVzZXJjb250ZW50LmNvbSIsInN1YiI6IjExMTAxMjUzOTgwMTUwNjQxNDg5MCIsImVtYWlsIjoiaGVhbG1zbGluQGdtYWlsLmNvbSIsImVtYWlsX3ZlcmlmaWVkIjp0cnVlLCJhenAiOiIyMTYyOTYwMzU4MzQtazFrNnFlMDYwczJ0cDJhMmphbTRsamRjbXMwMHN0dGcuYXBwcy5nb29nbGV1c2VyY29udGVudC5jb20iLCJuYW1lIjoibGluIExpbiIsInBpY3R1cmUiOiJodHRwczovL2xoMy5nb29nbGV1c2VyY29udGVudC5jb20vYS0vQU9oMTRHaVVuUWdGYkZTV1FLdUo3NG1LazNTeXpTUFVoa3h6Q0lPWUc1X3E9czk2LWMiLCJnaXZlbl9uYW1lIjoibGluIiwiZmFtaWx5X25hbWUiOiJMaW4iLCJpYXQiOjE2NTI2MTE1MzgsImV4cCI6MTY1MjYxNTEzOCwianRpIjoiZDcyM2IyNjU0M2QzZmI1YTk1NmRjOGNiOTNjYjQyM2RhNDQ1ZGYzNiJ9.bDAxv4MZqbrpvHVDjD0xu-738zVDWW7HF0GHndJg5LmCOA47NuXvsB7uLKsvtvwm6262qHwhMyDWzem4lGKjHjJfu_fDLMrr73zZP6Zn2yI-apfM_-PgIyaUCd5uUXZTsZ7JrdTDs-UvyGUM3MSzVCSrmSEgGBHX6HFPpyemEAVkSu0L5Fch5-0XEoH4NgNaapuVPDzpdbSDqH-RCkMh76Y1qW9kmajJKUNL6VL6OpJpGJfrK01L9kifeD4JjKgGXtpKJoW0K2ICfec_mFDp9GfRrFq-0b2-WnfoBVc8PeQ25zfYRBTQcQWcB6eeJLDO0I1Nrk83Clc89ixWzkX-vg">Typescript confusion: tsconfig.json module, moduleResolution, target &amp; lib explained</a></li><li><a href="https://lq782655835.github.io/blogs/project/ts-tsconfig.html">Typescript tsconfig.json 全解析</a></li><li><a href="https://www.typescriptlang.org/tsconfig#lib">Intro to the TSConfig Reference</a></li><li><a href="https://www.zhihu.com/question/322722786">用了 typescript 还需要 babel 或者 polyfill 吗？</a></li><li><a href="https://juejin.cn/post/6968636129239105549">为什么说用 babel 编译 typescript 是更好的选择</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>typescript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>客户端请求经过nginx获取请求头Host</title>
    <link href="/2022/05/15/2022-05-27-get-host-forward-nginx/"/>
    <url>/2022/05/15/2022-05-27-get-host-forward-nginx/</url>
    
    <content type="html"><![CDATA[<h1 id="背景"><a class="markdownIt-Anchor" href="#背景"></a> 背景</h1><p>目前项目部署正式环境前端请求会走 nginx, 反向代理到真正的后台服务机器. 最近刚弄完 node 的鉴权中间件, 其中遇到获取请求头<code>host</code>信息是<code>127.0.0.1:xxxx</code>无法获取真实请求 ip 或域名的情况, 解决后做个记录.</p><h1 id="解决方法"><a class="markdownIt-Anchor" href="#解决方法"></a> 解决方法</h1><p>先说解决方法, 因为 nginx 默认是不会透传客户端的请求头信息的, 所以需要自己在 nginx 的配置文件中添加下, 找到对应匹配的 location, 以下是实例:</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">location</span> /api/ &#123;<br>    <span class="hljs-attribute">proxy_set_header</span> Host <span class="hljs-variable">$host</span>;<br>    <span class="hljs-attribute">proxy_pass</span> http://127.0.0.1:10200/;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="衍生操作"><a class="markdownIt-Anchor" href="#衍生操作"></a> 衍生操作</h1><h2 id="如果用户请求直达服务想获取用户的-ip-该怎么做呢"><a class="markdownIt-Anchor" href="#如果用户请求直达服务想获取用户的-ip-该怎么做呢"></a> 如果用户请求直达服务想获取用户的 ip 该怎么做呢?</h2><p>明天试一试, to be continued;</p><h2 id="如果通过-nginx-转发的服务想获取用户的-ip-该怎么做呢"><a class="markdownIt-Anchor" href="#如果通过-nginx-转发的服务想获取用户的-ip-该怎么做呢"></a> 如果通过 nginx 转发的服务想获取用户的 ip 该怎么做呢?</h2><p>目前 nginx 代理服务器都支持转发请求头<code>X-Real-IP</code>和<code>X-Forwarded-For</code>,</p><h1 id="小技巧"><a class="markdownIt-Anchor" href="#小技巧"></a> 小技巧</h1><p>我不知道有没有人和我一样死活记不住 nginx.conf 的路径 🤦🏻‍♀️mac 和 linux 上的路径还不一样 🤦🏻‍♀️ 可以通过<code>nginx -V</code>查看 nginx 相关的文件路径, 其中最常用的<code>--conf-path</code>就是 nginx 的配置文件, <code>--http-log-path</code>是 nginx 所有的日志, <code>--error-log</code>是 nginx 的错误日志</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">// 省略部分信息<br>➜  ~ nginx -V<br>nginx version: nginx/1.21.6<br>built by clang 13.0.0 (clang-1300.0.29.3)<br>built with OpenSSL 1.1.1m  14 Dec 2021<br>TLS SNI support enabled<br>configure arguments: --prefix=/usr/local/Cellar/nginx/1.21.6 --sbin-path=/usr/local/Cellar/nginx/1.21.6/bin/nginx --conf-path=/usr/local/etc/nginx/nginx.conf --http-log-path=/usr/local/var/log/nginx/access.log --error-log-path=/usr/local/var/log/nginx/error.log<br></code></pre></td></tr></table></figure><h1 id="reference"><a class="markdownIt-Anchor" href="#reference"></a> reference</h1><ol><li><a href="https://imququ.com/post/x-forwarded-for-header-in-http.html">HTTP 请求头中的 X-Forwarded-For</a></li><li><a href="https://blog.csdn.net/xixingzhe2/article/details/118582055">nginx 代理获取 ip 为 127.0.0.1 解决方法</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>lottie 替换文字</title>
    <link href="/2022/05/02/2022-05-02-mod-text-in-lottie/"/>
    <url>/2022/05/02/2022-05-02-mod-text-in-lottie/</url>
    
    <content type="html"><![CDATA[<h1 id="背景"><a class="markdownIt-Anchor" href="#背景"></a> 背景</h1><p>背景是有个需求要在一个任务页面在用户任务完成后展示一个 lottie 动画弹窗, 产品来配置弹窗的文案。那就需要动态修改 lottie json 文件中的文案了。</p><h1 id="方案"><a class="markdownIt-Anchor" href="#方案"></a> 方案</h1><ol><li>先加载 json 文件, 替换 json 中的文案, 然后再使用<code>loadAnimation</code>加载</li><li>使用原始的 json 文件<code>loadAnimation</code>加载到 DOM 中后, 找到需要替换的文案所在的节点进行修改</li><li>使用 lottie 官方提供的<code>lottie-api</code>库修改 lottie 的属性</li></ol><p>这里不对哪种方案更好做评价, 只是前两种有手就行, 这里只介绍第三种</p><h1 id="来-试试看"><a class="markdownIt-Anchor" href="#来-试试看"></a> 来, 试试看</h1><p>其实<code>lottie</code>官方有提及如何更新文本数据<a href="https://github.com/airbnb/lottie-web/wiki/TextLayer.updateDocumentData">戳这里</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">anim.<span class="hljs-property">renderer</span>.<span class="hljs-property">elements</span>[<span class="hljs-number">0</span>].<span class="hljs-title function_">updateDocumentData</span>(&#123; <span class="hljs-attr">t</span>: <span class="hljs-string">&#x27;new text&#x27;</span>, <span class="hljs-attr">s</span>: <span class="hljs-number">20</span> &#125;, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>但是笔者使用<code>anim.renderer.elements[0]</code>始终无法找到对应的那段文本, 好在官方提供了(lottie-api)[<a href="https://github.com/bodymovin/lottie-api">https://github.com/bodymovin/lottie-api</a>]库省去了人工查找文本的过程</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">anim.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;DOMLoaded&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> api = lottie_api.<span class="hljs-title function_">createAnimationApi</span>(anim);<br>  <span class="hljs-keyword">const</span> elements = api.<span class="hljs-title function_">getKeyPath</span>(<span class="hljs-string">&#x27;任务完成弹窗样式,动效,卡片,卡片,积分奖励&#x27;</span>); <span class="hljs-comment">// 查找对象</span><br>  elements.<span class="hljs-title function_">getElements</span>()[<span class="hljs-number">0</span>].<span class="hljs-title function_">setText</span>(<span class="hljs-string">&#x27;你不拿枪指着他拿枪指着我?&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>这里最关键的就是<code>getKeyPath</code>这个 api, 通过图层来定位包含文本的元素, 参数就是每个图层名拼成的字符串, 这里我们定位到这个文本图层, 进行<code>setText</code>修改文案即可。<br /><img src="https://raw.githubusercontent.com/Mariana-Yui/images/master/blog-imgs/20220503-blog.png" alt="" /></p><h1 id="需要注意"><a class="markdownIt-Anchor" href="#需要注意"></a> 需要注意</h1><p>如果涉及修改文案, 设计师在 AE 中导出 lottie 时, <strong>不要勾选</strong>这个选项, 这个选项会将文本转为路径即很多线条, 路径是无法正常替换文案的, 这个事先需要和设计师沟通好</p><p><img src="https://img-blog.csdnimg.cn/img_convert/13d8db436966923fbcc2e98da754947c.png" alt="" /></p><h1 id="reference"><a class="markdownIt-Anchor" href="#reference"></a> reference</h1><ol><li><a href="https://zhuanlan.zhihu.com/p/102334701">Aha Lottie|动态修改 Lottie 中的文本</a></li><li><a href="https://blog.csdn.net/weixin_39984201/article/details/111268504">lottie 插件_Lottie 动效落地踩坑（第一弹）</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>lottie</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>koa-router源码解析</title>
    <link href="/2021/11/16/2021-11-16-koa-router/"/>
    <url>/2021/11/16/2021-11-16-koa-router/</url>
    
    <content type="html"><![CDATA[<h1 id="背景"><a class="markdownIt-Anchor" href="#背景"></a> 背景</h1><p>上班摸鱼事件研究 koa 及其周边中间件的第一弹 - <code>koa-router</code>, 个人理解都写在注释中了, koa 及 koa-xx 源码突出一个短小精悍, 很适合进阶阅读。</p><h1 id="源码解读"><a class="markdownIt-Anchor" href="#源码解读"></a> 源码解读</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> debug = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;debug&#x27;</span>)(<span class="hljs-string">&#x27;koa-router&#x27;</span>); <span class="hljs-comment">// logger</span><br><span class="hljs-keyword">const</span> compose = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;koa-compose&#x27;</span>); <span class="hljs-comment">// 执行中间件列表</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">HttpError</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http-errors&#x27;</span>); <span class="hljs-comment">// 封装的http错误库</span><br><span class="hljs-keyword">const</span> methods = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;methods&#x27;</span>); <span class="hljs-comment">// 返回http.METHODS</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Layer</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./layer&#x27;</span>);<br><span class="hljs-keyword">const</span> &#123; pathToRegexp &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path-to-regexp&#x27;</span>); <span class="hljs-comment">// 对路由path正则解析</span><br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title class_">Router</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Create a new router.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@example</span></span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Basic usage:</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ```javascript</span><br><span class="hljs-comment"> * const Koa = require(&#x27;koa&#x27;);</span><br><span class="hljs-comment"> * const Router = require(&#x27;<span class="hljs-doctag">@koa</span>/router&#x27;);</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * const app = new Koa();</span><br><span class="hljs-comment"> * const router = new Router();</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * router.get(&#x27;/&#x27;, (ctx, next) =&gt; &#123;</span><br><span class="hljs-comment"> *   // ctx.router available</span><br><span class="hljs-comment"> * &#125;);</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * app</span><br><span class="hljs-comment"> *   .use(router.routes())</span><br><span class="hljs-comment"> *   .use(router.allowedMethods());</span><br><span class="hljs-comment"> * ```</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@alias</span> module:koa-router</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Object=</span>&#125; <span class="hljs-variable">opts</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">String=</span>&#125; opts.prefix prefix router paths</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@constructor</span></span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Router</span>(<span class="hljs-params">opts</span>) &#123;<br>  <span class="hljs-comment">// 如果没用new实例则返回new实例, 即创建路由时可以使用new Router()或Router()</span><br>  <span class="hljs-keyword">if</span> (!(<span class="hljs-variable language_">this</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Router</span>)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Router</span>(opts);<br><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">opts</span> = opts || &#123;&#125;;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">methods</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">opts</span>.<span class="hljs-property">methods</span> || [<span class="hljs-string">&#x27;HEAD&#x27;</span>, <span class="hljs-string">&#x27;OPTIONS&#x27;</span>, <span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string">&#x27;PUT&#x27;</span>, <span class="hljs-string">&#x27;PATCH&#x27;</span>, <span class="hljs-string">&#x27;POST&#x27;</span>, <span class="hljs-string">&#x27;DELETE&#x27;</span>];<br>  <span class="hljs-comment">// 存储router.param()指定的参数, 键为参数名称, 值为中间件</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">params</span> = &#123;&#125;;<br>  <span class="hljs-comment">// 每次router.verb()都会创建一个layer, 存储这些layer</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span> = [];<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Create `router.verb()` methods, where *verb* is one of the HTTP verbs such</span><br><span class="hljs-comment"> * as `router.get()` or `router.post()`.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Match URL patterns to callback functions or controller actions using `router.verb()`,</span><br><span class="hljs-comment"> * where **verb** is one of the HTTP verbs such as `router.get()` or `router.post()`.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Additionaly, `router.all()` can be used to match against all methods.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ```javascript</span><br><span class="hljs-comment"> * router</span><br><span class="hljs-comment"> *   .get(&#x27;/&#x27;, (ctx, next) =&gt; &#123;</span><br><span class="hljs-comment"> *     ctx.body = &#x27;Hello World!&#x27;;</span><br><span class="hljs-comment"> *   &#125;)</span><br><span class="hljs-comment"> *   .post(&#x27;/users&#x27;, (ctx, next) =&gt; &#123;</span><br><span class="hljs-comment"> *     // ...</span><br><span class="hljs-comment"> *   &#125;)</span><br><span class="hljs-comment"> *   .put(&#x27;/users/:id&#x27;, (ctx, next) =&gt; &#123;</span><br><span class="hljs-comment"> *     // ...</span><br><span class="hljs-comment"> *   &#125;)</span><br><span class="hljs-comment"> *   .del(&#x27;/users/:id&#x27;, (ctx, next) =&gt; &#123;</span><br><span class="hljs-comment"> *     // ...</span><br><span class="hljs-comment"> *   &#125;)</span><br><span class="hljs-comment"> *   .all(&#x27;/users/:id&#x27;, (ctx, next) =&gt; &#123;</span><br><span class="hljs-comment"> *     // ...</span><br><span class="hljs-comment"> *   &#125;);</span><br><span class="hljs-comment"> * ```</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * When a route is matched, its path is available at `ctx._matchedRoute` and if named,</span><br><span class="hljs-comment"> * the name is available at `ctx._matchedRouteName`</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Route paths will be translated to regular expressions using</span><br><span class="hljs-comment"> * [path-to-regexp](https://github.com/pillarjs/path-to-regexp).</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Query strings will not be considered when matching requests.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * #### Named routes</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Routes can optionally have names. This allows generation of URLs and easy</span><br><span class="hljs-comment"> * renaming of URLs during development.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ```javascript</span><br><span class="hljs-comment"> * router.get(&#x27;user&#x27;, &#x27;/users/:id&#x27;, (ctx, next) =&gt; &#123;</span><br><span class="hljs-comment"> *  // ...</span><br><span class="hljs-comment"> * &#125;);</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * router.url(&#x27;user&#x27;, 3);</span><br><span class="hljs-comment"> * // =&gt; &quot;/users/3&quot;</span><br><span class="hljs-comment"> * ```</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * #### Multiple middleware</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Multiple middleware may be given:</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ```javascript</span><br><span class="hljs-comment"> * router.get(</span><br><span class="hljs-comment"> *   &#x27;/users/:id&#x27;,</span><br><span class="hljs-comment"> *   (ctx, next) =&gt; &#123;</span><br><span class="hljs-comment"> *     return User.findOne(ctx.params.id).then(function(user) &#123;</span><br><span class="hljs-comment"> *       ctx.user = user;</span><br><span class="hljs-comment"> *       next();</span><br><span class="hljs-comment"> *     &#125;);</span><br><span class="hljs-comment"> *   &#125;,</span><br><span class="hljs-comment"> *   ctx =&gt; &#123;</span><br><span class="hljs-comment"> *     console.log(ctx.user);</span><br><span class="hljs-comment"> *     // =&gt; &#123; id: 17, name: &quot;Alex&quot; &#125;</span><br><span class="hljs-comment"> *   &#125;</span><br><span class="hljs-comment"> * );</span><br><span class="hljs-comment"> * ```</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ### Nested routers</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Nesting routers is supported:</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ```javascript</span><br><span class="hljs-comment"> * const forums = new Router();</span><br><span class="hljs-comment"> * const posts = new Router();</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * posts.get(&#x27;/&#x27;, (ctx, next) =&gt; &#123;...&#125;);</span><br><span class="hljs-comment"> * posts.get(&#x27;/:pid&#x27;, (ctx, next) =&gt; &#123;...&#125;);</span><br><span class="hljs-comment"> * forums.use(&#x27;/forums/:fid/posts&#x27;, posts.routes(), posts.allowedMethods());</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * // responds to &quot;/forums/123/posts&quot; and &quot;/forums/123/posts/123&quot;</span><br><span class="hljs-comment"> * app.use(forums.routes());</span><br><span class="hljs-comment"> * ```</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * #### Router prefixes</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Route paths can be prefixed at the router level:</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ```javascript</span><br><span class="hljs-comment"> * const router = new Router(&#123;</span><br><span class="hljs-comment"> *   prefix: &#x27;/users&#x27;</span><br><span class="hljs-comment"> * &#125;);</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * router.get(&#x27;/&#x27;, ...); // responds to &quot;/users&quot;</span><br><span class="hljs-comment"> * router.get(&#x27;/:id&#x27;, ...); // responds to &quot;/users/:id&quot;</span><br><span class="hljs-comment"> * ```</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * #### URL parameters</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Named route parameters are captured and added to `ctx.params`.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ```javascript</span><br><span class="hljs-comment"> * router.get(&#x27;/:category/:title&#x27;, (ctx, next) =&gt; &#123;</span><br><span class="hljs-comment"> *   console.log(ctx.params);</span><br><span class="hljs-comment"> *   // =&gt; &#123; category: &#x27;programming&#x27;, title: &#x27;how-to-node&#x27; &#125;</span><br><span class="hljs-comment"> * &#125;);</span><br><span class="hljs-comment"> * ```</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * The [path-to-regexp](https://github.com/pillarjs/path-to-regexp) module is</span><br><span class="hljs-comment"> * used to convert paths to regular expressions.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@name</span> get|put|post|patch|delete|del</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@memberof</span> module:koa-router.prototype</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">String</span>&#125; <span class="hljs-variable">path</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Function=</span>&#125; middleware route middleware(s)</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Function</span>&#125; callback route callback</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns</span> &#123;<span class="hljs-type">Router</span>&#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * methods库就两行代码, 读取http.METHODS返回小写列表</span><br><span class="hljs-comment"> * 遍历所有http方法, 赋值实例方法例如router.get/router.post等</span><br><span class="hljs-comment"> * 并通过router.register方法将每个通过该实例方法创建的路由注册成Layer</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; methods.<span class="hljs-property">length</span>; i++) &#123;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">setMethodVerb</span>(<span class="hljs-params">method</span>) &#123;<br>    <span class="hljs-title class_">Router</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>[method] = <span class="hljs-keyword">function</span> (<span class="hljs-params">name, path, middleware</span>) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> path === <span class="hljs-string">&#x27;string&#x27;</span> || path <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">RegExp</span>) &#123;<br>        middleware = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">slice</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>, <span class="hljs-number">2</span>);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        middleware = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">slice</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>, <span class="hljs-number">1</span>);<br>        path = name;<br>        name = <span class="hljs-literal">null</span>;<br>      &#125;<br><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">register</span>(path, [method], middleware, &#123;<br>        <span class="hljs-attr">name</span>: name<br>      &#125;);<br><br>      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>    &#125;;<br>  &#125;<br>  <span class="hljs-title function_">setMethodVerb</span>(methods[i]);<br>&#125;<br><br><span class="hljs-comment">// Alias for `router.delete()` because delete is a reserved word</span><br><span class="hljs-comment">// 设置router.delete的别名</span><br><span class="hljs-title class_">Router</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">del</span> = <span class="hljs-title class_">Router</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>[<span class="hljs-string">&#x27;delete&#x27;</span>];<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Use given middleware.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Middleware run in the order they are defined by `.use()`. They are invoked</span><br><span class="hljs-comment"> * sequentially, requests start at the first middleware and work their way</span><br><span class="hljs-comment"> * &quot;down&quot; the middleware stack.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@example</span></span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ```javascript</span><br><span class="hljs-comment"> * // session middleware will run before authorize</span><br><span class="hljs-comment"> * router</span><br><span class="hljs-comment"> *   .use(session())</span><br><span class="hljs-comment"> *   .use(authorize());</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * // use middleware only with given path</span><br><span class="hljs-comment"> * router.use(&#x27;/users&#x27;, userAuth());</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * // or with an array of paths</span><br><span class="hljs-comment"> * router.use([&#x27;/users&#x27;, &#x27;/admin&#x27;], userAuth());</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * app.use(router.routes());</span><br><span class="hljs-comment"> * ```</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">String=</span>&#125; <span class="hljs-variable">path</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Function</span>&#125; <span class="hljs-variable">middleware</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Function=</span>&#125; ...</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns</span> &#123;<span class="hljs-type">Router</span>&#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-title class_">Router</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">use</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> router = <span class="hljs-variable language_">this</span>;<br>  <span class="hljs-keyword">const</span> middleware = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">slice</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>);<br>  <span class="hljs-keyword">let</span> path;<br><br>  <span class="hljs-comment">// support array of paths</span><br>  <span class="hljs-comment">// 和router.register类似, use的path参数也支持数组, 如果是数组则做一层递归, [p].concat(middleware.slice(1))即path+middleware</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(middleware[<span class="hljs-number">0</span>]) &amp;&amp; <span class="hljs-keyword">typeof</span> middleware[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>    <span class="hljs-keyword">let</span> arrPaths = middleware[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arrPaths.<span class="hljs-property">length</span>; i++) &#123;<br>      <span class="hljs-keyword">const</span> p = arrPaths[i];<br>      router.<span class="hljs-property">use</span>.<span class="hljs-title function_">apply</span>(router, [p].<span class="hljs-title function_">concat</span>(middleware.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>)));<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// use可以设置全局中间件, 可以不需要path</span><br>  <span class="hljs-keyword">const</span> hasPath = <span class="hljs-keyword">typeof</span> middleware[<span class="hljs-number">0</span>] === <span class="hljs-string">&#x27;string&#x27;</span>;<br>  <span class="hljs-comment">// 取出path, 此时middleware参数就是中间件数组</span><br>  <span class="hljs-keyword">if</span> (hasPath) path = middleware.<span class="hljs-title function_">shift</span>();<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; middleware.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">const</span> m = middleware[i];<br>    <span class="hljs-comment">// router还支持一种嵌套路由例如, router.use(&#x27;/user&#x27;, userRouter.routes())</span><br>    <span class="hljs-comment">// 从routes()中已经知道了会对dispatch添加router属性指向自身this</span><br>    <span class="hljs-comment">// 所以该分支用于处理嵌套路由, 此时第一个参数path如果存在则会作为prefix</span><br>    <span class="hljs-keyword">if</span> (m.<span class="hljs-property">router</span>) &#123;<br>      <span class="hljs-comment">// 克隆router</span><br>      <span class="hljs-keyword">const</span> cloneRouter = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Router</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>), m.<span class="hljs-property">router</span>, &#123;<br>        <span class="hljs-comment">// stack即嵌套路由含有的layer</span><br>        <span class="hljs-attr">stack</span>: m.<span class="hljs-property">router</span>.<span class="hljs-property">stack</span>.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>)<br>      &#125;);<br><br>      <span class="hljs-comment">// 克隆layer</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; cloneRouter.<span class="hljs-property">stack</span>.<span class="hljs-property">length</span>; j++) &#123;<br>        <span class="hljs-keyword">const</span> nestedLayer = cloneRouter.<span class="hljs-property">stack</span>[j];<br>        <span class="hljs-keyword">const</span> cloneLayer = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Layer</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>), nestedLayer);<br><br>        <span class="hljs-comment">// 设置prefix</span><br>        <span class="hljs-keyword">if</span> (path) cloneLayer.<span class="hljs-title function_">setPrefix</span>(path);<br>        <span class="hljs-keyword">if</span> (router.<span class="hljs-property">opts</span>.<span class="hljs-property">prefix</span>) cloneLayer.<span class="hljs-title function_">setPrefix</span>(router.<span class="hljs-property">opts</span>.<span class="hljs-property">prefix</span>);<br>        <span class="hljs-comment">// 将嵌套路由中克隆的中间件抽离出来, 赋值给自身路由</span><br>        router.<span class="hljs-property">stack</span>.<span class="hljs-title function_">push</span>(cloneLayer);<br>        cloneRouter.<span class="hljs-property">stack</span>[j] = cloneLayer;<br>      &#125;<br><br>      <span class="hljs-comment">// 如果自身路由对param()做过设置, 这里也要对嵌套路由中提取的中间件赋值</span><br>      <span class="hljs-keyword">if</span> (router.<span class="hljs-property">params</span>) &#123;<br>        <span class="hljs-keyword">function</span> <span class="hljs-title function_">setRouterParams</span>(<span class="hljs-params">paramArr</span>) &#123;<br>          <span class="hljs-keyword">const</span> routerParams = paramArr;<br>          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; routerParams.<span class="hljs-property">length</span>; j++) &#123;<br>            <span class="hljs-keyword">const</span> key = routerParams[j];<br>            cloneRouter.<span class="hljs-title function_">param</span>(key, router.<span class="hljs-property">params</span>[key]);<br>          &#125;<br>        &#125;<br>        <span class="hljs-title function_">setRouterParams</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(router.<span class="hljs-property">params</span>));<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 单纯中间件, 则和router.verb一样register中间件</span><br>      <span class="hljs-keyword">const</span> keys = [];<br>      <span class="hljs-title function_">pathToRegexp</span>(router.<span class="hljs-property">opts</span>.<span class="hljs-property">prefix</span> || <span class="hljs-string">&#x27;&#x27;</span>, keys);<br>      <span class="hljs-keyword">const</span> routerPrefixHasParam = router.<span class="hljs-property">opts</span>.<span class="hljs-property">prefix</span> &amp;&amp; keys.<span class="hljs-property">length</span>;<br>      router.<span class="hljs-title function_">register</span>(path || <span class="hljs-string">&#x27;([^/]*)&#x27;</span>, [], m, &#123;<br>        <span class="hljs-attr">end</span>: <span class="hljs-literal">false</span>,<br>        <span class="hljs-attr">ignoreCaptures</span>: !hasPath &amp;&amp; !routerPrefixHasParam<br>      &#125;);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Set the path prefix for a Router instance that was already initialized.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@example</span></span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ```javascript</span><br><span class="hljs-comment"> * router.prefix(&#x27;/things/:thing_id&#x27;)</span><br><span class="hljs-comment"> * ```</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">String</span>&#125; <span class="hljs-variable">prefix</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns</span> &#123;<span class="hljs-type">Router</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">// 给已创建Layer统一设置路由前缀</span><br><span class="hljs-title class_">Router</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">prefix</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">prefix</span>) &#123;<br>  prefix = prefix.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\/$/</span>, <span class="hljs-string">&#x27;&#x27;</span>);<br><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">opts</span>.<span class="hljs-property">prefix</span> = prefix;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span>.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">const</span> route = <span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span>[i];<br>    route.<span class="hljs-title function_">setPrefix</span>(prefix);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Returns router middleware which dispatches a route matching the request.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns</span> &#123;<span class="hljs-type">Function</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">// router.routes()定义dispatch函数用于执行中间件, 返回dispatch函数</span><br><span class="hljs-title class_">Router</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">routes</span> = <span class="hljs-title class_">Router</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">middleware</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> router = <span class="hljs-variable language_">this</span>;<br><br>  <span class="hljs-keyword">let</span> dispatch = <span class="hljs-keyword">function</span> <span class="hljs-title function_">dispatch</span>(<span class="hljs-params">ctx, next</span>) &#123;<br>    <span class="hljs-title function_">debug</span>(<span class="hljs-string">&#x27;%s %s&#x27;</span>, ctx.<span class="hljs-property">method</span>, ctx.<span class="hljs-property">path</span>);<br>    <span class="hljs-comment">// 解析请求上下文的path和method</span><br>    <span class="hljs-keyword">const</span> path = router.<span class="hljs-property">opts</span>.<span class="hljs-property">routerPath</span> || ctx.<span class="hljs-property">routerPath</span> || ctx.<span class="hljs-property">path</span>;<br>    <span class="hljs-comment">// 返回匹配的layer</span><br>    <span class="hljs-keyword">const</span> matched = router.<span class="hljs-title function_">match</span>(path, ctx.<span class="hljs-property">method</span>);<br>    <span class="hljs-keyword">let</span> layerChain;<br><br>    <span class="hljs-comment">// 找了koa和koa-router的ctx.matched, 貌似不会进入if分支</span><br>    <span class="hljs-keyword">if</span> (ctx.<span class="hljs-property">matched</span>) &#123;<br>      ctx.<span class="hljs-property">matched</span>.<span class="hljs-property">push</span>.<span class="hljs-title function_">apply</span>(ctx.<span class="hljs-property">matched</span>, matched.<span class="hljs-property">path</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 将匹配到的layer赋值给上下文</span><br>      ctx.<span class="hljs-property">matched</span> = matched.<span class="hljs-property">path</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 将koa-router实例赋值上下文</span><br>    ctx.<span class="hljs-property">router</span> = router;<br><br>    <span class="hljs-comment">// 匹配到的methods列表为空的话直接next()</span><br>    <span class="hljs-keyword">if</span> (!matched.<span class="hljs-property">route</span>) <span class="hljs-keyword">return</span> <span class="hljs-title function_">next</span>();<br><br>    <span class="hljs-comment">// 匹配path和method的layer列表</span><br>    <span class="hljs-keyword">const</span> matchedLayers = matched.<span class="hljs-property">pathAndMethod</span>;<br>    <span class="hljs-keyword">const</span> mostSpecificLayer = matchedLayers[matchedLayers.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">// 去最后一个元素作为ctx._matchedRoute</span><br>    ctx.<span class="hljs-property">_matchedRoute</span> = mostSpecificLayer.<span class="hljs-property">path</span>;<br>    <span class="hljs-keyword">if</span> (mostSpecificLayer.<span class="hljs-property">name</span>) &#123;<br>      ctx.<span class="hljs-property">_matchedRouteName</span> = mostSpecificLayer.<span class="hljs-property">name</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 这里通过reduce做了两件事</span><br><span class="hljs-comment">     * 1. 将所有layer的中间件即layer.stack整合到一个列表中</span><br><span class="hljs-comment">     * 2. 在处理每个layer的中间件前push一个初始化当前ctx上下文的中间件, 避免不同layer之间相互影响</span><br><span class="hljs-comment">     * layer.captures(path)调用path.match(this.regexp)匹配ctx.path中的params</span><br><span class="hljs-comment">     * layer.params()会decode params的值并复制给ctx.params</span><br><span class="hljs-comment">     */</span><br>    layerChain = matchedLayers.<span class="hljs-title function_">reduce</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">memo, layer</span>) &#123;<br>      memo.<span class="hljs-title function_">push</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">ctx, next</span>) &#123;<br>        ctx.<span class="hljs-property">captures</span> = layer.<span class="hljs-title function_">captures</span>(path, ctx.<span class="hljs-property">captures</span>);<br>        ctx.<span class="hljs-property">params</span> = ctx.<span class="hljs-property">request</span>.<span class="hljs-property">params</span> = layer.<span class="hljs-title function_">params</span>(path, ctx.<span class="hljs-property">captures</span>, ctx.<span class="hljs-property">params</span>);<br>        ctx.<span class="hljs-property">routerPath</span> = layer.<span class="hljs-property">path</span>;<br>        ctx.<span class="hljs-property">routerName</span> = layer.<span class="hljs-property">name</span>;<br>        ctx.<span class="hljs-property">_matchedRoute</span> = layer.<span class="hljs-property">path</span>;<br>        <span class="hljs-keyword">if</span> (layer.<span class="hljs-property">name</span>) &#123;<br>          ctx.<span class="hljs-property">_matchedRouteName</span> = layer.<span class="hljs-property">name</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">next</span>();<br>      &#125;);<br>      <span class="hljs-keyword">return</span> memo.<span class="hljs-title function_">concat</span>(layer.<span class="hljs-property">stack</span>);<br>    &#125;, []);<br><br>    <span class="hljs-comment">// koa-compose执行中间件</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">compose</span>(layerChain)(ctx, next);<br>  &#125;;<br><br>  dispatch.<span class="hljs-property">router</span> = <span class="hljs-variable language_">this</span>;<br><br>  <span class="hljs-keyword">return</span> dispatch;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Returns separate middleware for responding to `OPTIONS` requests with</span><br><span class="hljs-comment"> * an `Allow` header containing the allowed methods, as well as responding</span><br><span class="hljs-comment"> * with `405 Method Not Allowed` and `501 Not Implemented` as appropriate.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@example</span></span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ```javascript</span><br><span class="hljs-comment"> * const Koa = require(&#x27;koa&#x27;);</span><br><span class="hljs-comment"> * const Router = require(&#x27;<span class="hljs-doctag">@koa</span>/router&#x27;);</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * const app = new Koa();</span><br><span class="hljs-comment"> * const router = new Router();</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * app.use(router.routes());</span><br><span class="hljs-comment"> * app.use(router.allowedMethods());</span><br><span class="hljs-comment"> * ```</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * **Example with [Boom](https://github.com/hapijs/boom)**</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ```javascript</span><br><span class="hljs-comment"> * const Koa = require(&#x27;koa&#x27;);</span><br><span class="hljs-comment"> * const Router = require(&#x27;<span class="hljs-doctag">@koa</span>/router&#x27;);</span><br><span class="hljs-comment"> * const Boom = require(&#x27;boom&#x27;);</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * const app = new Koa();</span><br><span class="hljs-comment"> * const router = new Router();</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * app.use(router.routes());</span><br><span class="hljs-comment"> * app.use(router.allowedMethods(&#123;</span><br><span class="hljs-comment"> *   throw: true,</span><br><span class="hljs-comment"> *   notImplemented: () =&gt; new Boom.notImplemented(),</span><br><span class="hljs-comment"> *   methodNotAllowed: () =&gt; new Boom.methodNotAllowed()</span><br><span class="hljs-comment"> * &#125;));</span><br><span class="hljs-comment"> * ```</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Object=</span>&#125; <span class="hljs-variable">options</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Boolean=</span>&#125; options.throw throw error instead of setting status and header</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Function=</span>&#125; options.notImplemented throw the returned value in place of the default NotImplemented error</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Function=</span>&#125; options.methodNotAllowed throw the returned value in place of the default MethodNotAllowed error</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns</span> &#123;<span class="hljs-type">Function</span>&#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-title class_">Router</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">allowedMethods</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">options</span>) &#123;<br>  options = options || &#123;&#125;;<br>  <span class="hljs-keyword">const</span> implemented = <span class="hljs-variable language_">this</span>.<span class="hljs-property">methods</span>;<br><br>  <span class="hljs-comment">// koa-compose对next()的返回是Promise的形式, allowedMethods则是用于对返回的数据进行处理</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">allowedMethods</span>(<span class="hljs-params">ctx, next</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">next</span>().<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">const</span> allowed = &#123;&#125;;<br><br>      <span class="hljs-comment">// 这里可以看出该方法只针对status为空或404的情况</span><br>      <span class="hljs-keyword">if</span> (!ctx.<span class="hljs-property">status</span> || ctx.<span class="hljs-property">status</span> === <span class="hljs-number">404</span>) &#123;<br>        <span class="hljs-comment">// 遍历匹配的所有layer, 读取所有method</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; ctx.<span class="hljs-property">matched</span>.<span class="hljs-property">length</span>; i++) &#123;<br>          <span class="hljs-keyword">const</span> route = ctx.<span class="hljs-property">matched</span>[i];<br>          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; route.<span class="hljs-property">methods</span>.<span class="hljs-property">length</span>; j++) &#123;<br>            <span class="hljs-keyword">const</span> method = route.<span class="hljs-property">methods</span>[j];<br>            allowed[method] = method;<br>          &#125;<br>        &#125;<br>        <span class="hljs-comment">// 所有允许的请求method</span><br>        <span class="hljs-keyword">const</span> allowedArr = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(allowed);<br><br>        <span class="hljs-comment">// 如果请求方法不被允许, this.methods为初始化Router时设置的允许方法列表</span><br>        <span class="hljs-keyword">if</span> (!~implemented.<span class="hljs-title function_">indexOf</span>(ctx.<span class="hljs-property">method</span>)) &#123;<br>          <span class="hljs-comment">// 是否需要抛出错误, 以及是否自定义错误</span><br>          <span class="hljs-keyword">if</span> (options.<span class="hljs-property">throw</span>) &#123;<br>            <span class="hljs-keyword">let</span> notImplementedThrowable =<br>              <span class="hljs-keyword">typeof</span> options.<span class="hljs-property">notImplemented</span> === <span class="hljs-string">&#x27;function&#x27;</span><br>                ? options.<span class="hljs-title function_">notImplemented</span>() <span class="hljs-comment">// set whatever the user returns from their function</span><br>                : <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpError</span>.<span class="hljs-title class_">NotImplemented</span>();<br><br>            <span class="hljs-keyword">throw</span> notImplementedThrowable;<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 设置501 not implemented 状态码和响应头</span><br>            ctx.<span class="hljs-property">status</span> = <span class="hljs-number">501</span>;<br>            ctx.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;Allow&#x27;</span>, allowedArr.<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;, &#x27;</span>));<br>          &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (allowedArr.<span class="hljs-property">length</span>) &#123;<br>          <span class="hljs-comment">// 走到这一步表示请求方法是被允许的, 但是可能是OPTIONS预请求, 往往不会对预请求做处理</span><br>          <span class="hljs-comment">// 这里直接正常返回</span><br>          <span class="hljs-keyword">if</span> (ctx.<span class="hljs-property">method</span> === <span class="hljs-string">&#x27;OPTIONS&#x27;</span>) &#123;<br>            ctx.<span class="hljs-property">status</span> = <span class="hljs-number">200</span>;<br>            ctx.<span class="hljs-property">body</span> = <span class="hljs-string">&#x27;&#x27;</span>;<br>            ctx.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;Allow&#x27;</span>, allowedArr.<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;, &#x27;</span>));<br>          &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!allowed[ctx.<span class="hljs-property">method</span>]) &#123;<br>            <span class="hljs-comment">// 走到这里表示, 请求是被允许的但是没有相应的layer处理这个路由, 类似的</span><br>            <span class="hljs-comment">// 如果有自定义错误则抛出异常</span><br>            <span class="hljs-keyword">if</span> (options.<span class="hljs-property">throw</span>) &#123;<br>              <span class="hljs-keyword">let</span> notAllowedThrowable =<br>                <span class="hljs-keyword">typeof</span> options.<span class="hljs-property">methodNotAllowed</span> === <span class="hljs-string">&#x27;function&#x27;</span><br>                  ? options.<span class="hljs-title function_">methodNotAllowed</span>() <span class="hljs-comment">// set whatever the user returns from their function</span><br>                  : <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpError</span>.<span class="hljs-title class_">MethodNotAllowed</span>();<br><br>              <span class="hljs-keyword">throw</span> notAllowedThrowable;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>              <span class="hljs-comment">// 否则抛出405 method not allow状态码并设置响应头</span><br>              ctx.<span class="hljs-property">status</span> = <span class="hljs-number">405</span>;<br>              ctx.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;Allow&#x27;</span>, allowedArr.<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;, &#x27;</span>));<br>            &#125;<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;);<br>  &#125;;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Register route with all methods.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">String</span>&#125; name Optional.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">String</span>&#125; <span class="hljs-variable">path</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Function=</span>&#125; middleware You may also pass multiple middleware.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Function</span>&#125; <span class="hljs-variable">callback</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns</span> &#123;<span class="hljs-type">Router</span>&#125;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@private</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">// 和router.verb一样, 只不过第二个参数不再是单个verb,而是所有http.METHODS</span><br><span class="hljs-title class_">Router</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">all</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">name, path, middleware</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> path === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>    middleware = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">slice</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>, <span class="hljs-number">2</span>);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    middleware = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">slice</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>, <span class="hljs-number">1</span>);<br>    path = name;<br>    name = <span class="hljs-literal">null</span>;<br>  &#125;<br><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">register</span>(path, methods, middleware, &#123; name &#125;);<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Redirect `source` to `destination` URL with optional 30x status `code`.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Both `source` and `destination` can be route names.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ```javascript</span><br><span class="hljs-comment"> * router.redirect(&#x27;/login&#x27;, &#x27;sign-in&#x27;);</span><br><span class="hljs-comment"> * ```</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * This is equivalent to:</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ```javascript</span><br><span class="hljs-comment"> * router.all(&#x27;/login&#x27;, ctx =&gt; &#123;</span><br><span class="hljs-comment"> *   ctx.redirect(&#x27;/sign-in&#x27;);</span><br><span class="hljs-comment"> *   ctx.status = 301;</span><br><span class="hljs-comment"> * &#125;);</span><br><span class="hljs-comment"> * ```</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">String</span>&#125; source URL or route name.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">String</span>&#125; destination URL or route name.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Number=</span>&#125; code HTTP status code (default: 301).</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns</span> &#123;<span class="hljs-type">Router</span>&#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-title class_">Router</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">redirect</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">source, destination, code</span>) &#123;<br>  <span class="hljs-comment">// lookup source route by name</span><br>  <span class="hljs-keyword">if</span> (source[<span class="hljs-number">0</span>] !== <span class="hljs-string">&#x27;/&#x27;</span>) source = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">url</span>(source);<br><br>  <span class="hljs-comment">// lookup destination route by name</span><br>  <span class="hljs-keyword">if</span> (destination[<span class="hljs-number">0</span>] !== <span class="hljs-string">&#x27;/&#x27;</span> &amp;&amp; !destination.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&#x27;://&#x27;</span>)) destination = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">url</span>(destination);<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">all</span>(source, <span class="hljs-function">(<span class="hljs-params">ctx</span>) =&gt;</span> &#123;<br>    ctx.<span class="hljs-title function_">redirect</span>(destination);<br>    ctx.<span class="hljs-property">status</span> = code || <span class="hljs-number">301</span>;<br>  &#125;);<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Create and register a route.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">String</span>&#125; path Path string.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Array.&lt;String&gt;</span>&#125; methods Array of HTTP verbs.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Function</span>&#125; middleware Multiple middleware also accepted.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns</span> &#123;<span class="hljs-type">Layer</span>&#125;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@private</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">// 这里的methods和middleware都是数组</span><br><span class="hljs-title class_">Router</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">register</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">path, methods, middleware, opts</span>) &#123;<br>  opts = opts || &#123;&#125;;<br><br>  <span class="hljs-keyword">const</span> router = <span class="hljs-variable language_">this</span>;<br>  <span class="hljs-keyword">const</span> stack = <span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span>;<br><br>  <span class="hljs-comment">// support array of paths</span><br>  <span class="hljs-comment">// 因为register的path也支持数组, 所以这里做一个递归</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(path)) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; path.<span class="hljs-property">length</span>; i++) &#123;<br>      <span class="hljs-keyword">const</span> curPath = path[i];<br>      router.<span class="hljs-property">register</span>.<span class="hljs-title function_">call</span>(router, curPath, methods, middleware, opts);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// create route</span><br>  <span class="hljs-comment">// 创建路由, 最后一个参数用作path-to-regexp库的解析配置</span><br>  <span class="hljs-keyword">const</span> route = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Layer</span>(path, methods, middleware, &#123;<br>    <span class="hljs-attr">end</span>: opts.<span class="hljs-property">end</span> === <span class="hljs-literal">false</span> ? opts.<span class="hljs-property">end</span> : <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">name</span>: opts.<span class="hljs-property">name</span>,<br>    <span class="hljs-attr">sensitive</span>: opts.<span class="hljs-property">sensitive</span> || <span class="hljs-variable language_">this</span>.<span class="hljs-property">opts</span>.<span class="hljs-property">sensitive</span> || <span class="hljs-literal">false</span>,<br>    <span class="hljs-attr">strict</span>: opts.<span class="hljs-property">strict</span> || <span class="hljs-variable language_">this</span>.<span class="hljs-property">opts</span>.<span class="hljs-property">strict</span> || <span class="hljs-literal">false</span>,<br>    <span class="hljs-attr">prefix</span>: opts.<span class="hljs-property">prefix</span> || <span class="hljs-variable language_">this</span>.<span class="hljs-property">opts</span>.<span class="hljs-property">prefix</span> || <span class="hljs-string">&#x27;&#x27;</span>,<br>    <span class="hljs-attr">ignoreCaptures</span>: opts.<span class="hljs-property">ignoreCaptures</span><br>  &#125;);<br><br>  <span class="hljs-comment">// 设置前缀</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">opts</span>.<span class="hljs-property">prefix</span>) &#123;<br>    route.<span class="hljs-title function_">setPrefix</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">opts</span>.<span class="hljs-property">prefix</span>);<br>  &#125;<br><br>  <span class="hljs-comment">// add parameter middleware</span><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 这段代码耐人寻味, 首先router.param()的机制是为参数设置的中间件会在所有相关中间件之前执行</span><br><span class="hljs-comment">   * 所以会在每创建一个layer都会遍历存储router.params如果有匹配的中间件, 则把中间件加到layer的中间件列表的最前面</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">params</span>).<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">const</span> param = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">params</span>)[i];<br>    route.<span class="hljs-title function_">param</span>(param, <span class="hljs-variable language_">this</span>.<span class="hljs-property">params</span>[param]);<br>  &#125;<br><br>  <span class="hljs-comment">// 存储layer</span><br>  stack.<span class="hljs-title function_">push</span>(route);<br><br>  <span class="hljs-title function_">debug</span>(<span class="hljs-string">&#x27;defined route %s %s&#x27;</span>, route.<span class="hljs-property">methods</span>, route.<span class="hljs-property">path</span>);<br><br>  <span class="hljs-keyword">return</span> route;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Lookup route with given `name`.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">String</span>&#125; <span class="hljs-variable">name</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns</span> &#123;<span class="hljs-type">Layer|false</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">// 返回layer.name和参数匹配的第一个layer</span><br><span class="hljs-title class_">Router</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">route</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-keyword">const</span> routes = <span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span>;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> len = routes.<span class="hljs-property">length</span>, i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>    <span class="hljs-keyword">if</span> (routes[i].<span class="hljs-property">name</span> &amp;&amp; routes[i].<span class="hljs-property">name</span> === name) <span class="hljs-keyword">return</span> routes[i];<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Generate URL for route. Takes a route name and map of named `params`.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@example</span></span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ```javascript</span><br><span class="hljs-comment"> * router.get(&#x27;user&#x27;, &#x27;/users/:id&#x27;, (ctx, next) =&gt; &#123;</span><br><span class="hljs-comment"> *   // ...</span><br><span class="hljs-comment"> * &#125;);</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * router.url(&#x27;user&#x27;, 3);</span><br><span class="hljs-comment"> * // =&gt; &quot;/users/3&quot;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * router.url(&#x27;user&#x27;, &#123; id: 3 &#125;);</span><br><span class="hljs-comment"> * // =&gt; &quot;/users/3&quot;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * router.use((ctx, next) =&gt; &#123;</span><br><span class="hljs-comment"> *   // redirect to named route</span><br><span class="hljs-comment"> *   ctx.redirect(ctx.router.url(&#x27;sign-in&#x27;));</span><br><span class="hljs-comment"> * &#125;)</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * router.url(&#x27;user&#x27;, &#123; id: 3 &#125;, &#123; query: &#123; limit: 1 &#125; &#125;);</span><br><span class="hljs-comment"> * // =&gt; &quot;/users/3?limit=1&quot;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * router.url(&#x27;user&#x27;, &#123; id: 3 &#125;, &#123; query: &quot;limit=1&quot; &#125;);</span><br><span class="hljs-comment"> * // =&gt; &quot;/users/3?limit=1&quot;</span><br><span class="hljs-comment"> * ```</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">String</span>&#125; name route name</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Object</span>&#125; params url parameters</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Object</span>&#125; [options] options parameter</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Object|String</span>&#125; [options.query] query options</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns</span> &#123;<span class="hljs-type">String|Error</span>&#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-title class_">Router</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">url</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">name, params</span>) &#123;<br>  <span class="hljs-keyword">const</span> route = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">route</span>(name);<br><br>  <span class="hljs-keyword">if</span> (route) &#123;<br>    <span class="hljs-keyword">const</span> args = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">slice</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> route.<span class="hljs-property">url</span>.<span class="hljs-title function_">apply</span>(route, args);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`No route found for name: <span class="hljs-subst">$&#123;name&#125;</span>`</span>);<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Match given `path` and return corresponding routes.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">String</span>&#125; <span class="hljs-variable">path</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">String</span>&#125; <span class="hljs-variable">method</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns</span> &#123;<span class="hljs-type">Object.&lt;path, pathAndMethod&gt;</span>&#125; returns layers that matched path and</span><br><span class="hljs-comment"> * path and method.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@private</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">// matched.path 为匹配到path的layer</span><br><span class="hljs-comment">// matched.pathAndMethod为匹配到path和method的layer</span><br><span class="hljs-comment">// matched.route为是否匹配上的method</span><br><span class="hljs-title class_">Router</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">match</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">path, method</span>) &#123;<br>  <span class="hljs-keyword">const</span> layers = <span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span>;<br>  <span class="hljs-keyword">let</span> layer;<br>  <span class="hljs-keyword">const</span> matched = &#123;<br>    <span class="hljs-attr">path</span>: [],<br>    <span class="hljs-attr">pathAndMethod</span>: [],<br>    <span class="hljs-attr">route</span>: <span class="hljs-literal">false</span><br>  &#125;;<br><br>  <span class="hljs-comment">// 遍历layer返回和当前请求路由匹配的layer</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> len = layers.<span class="hljs-property">length</span>, i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>    layer = layers[i];<br><br>    <span class="hljs-title function_">debug</span>(<span class="hljs-string">&#x27;test %s %s&#x27;</span>, layer.<span class="hljs-property">path</span>, layer.<span class="hljs-property">regexp</span>);<br><br>    <span class="hljs-comment">// layer.match调用layer.regexp.test(path), 匹配路径</span><br>    <span class="hljs-keyword">if</span> (layer.<span class="hljs-title function_">match</span>(path)) &#123;<br>      matched.<span class="hljs-property">path</span>.<span class="hljs-title function_">push</span>(layer);<br>      <span class="hljs-comment">// 匹配方法, 如果methods长度为0或有匹配到的方法, ~操作符是按位非</span><br>      <span class="hljs-keyword">if</span> (layer.<span class="hljs-property">methods</span>.<span class="hljs-property">length</span> === <span class="hljs-number">0</span> || ~layer.<span class="hljs-property">methods</span>.<span class="hljs-title function_">indexOf</span>(method)) &#123;<br>        matched.<span class="hljs-property">pathAndMethod</span>.<span class="hljs-title function_">push</span>(layer);<br>        <span class="hljs-keyword">if</span> (layer.<span class="hljs-property">methods</span>.<span class="hljs-property">length</span>) matched.<span class="hljs-property">route</span> = <span class="hljs-literal">true</span>;<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> matched;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Run middleware for named route parameters. Useful for auto-loading or</span><br><span class="hljs-comment"> * validation.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@example</span></span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ```javascript</span><br><span class="hljs-comment"> * router</span><br><span class="hljs-comment"> *   .param(&#x27;user&#x27;, (id, ctx, next) =&gt; &#123;</span><br><span class="hljs-comment"> *     ctx.user = users[id];</span><br><span class="hljs-comment"> *     if (!ctx.user) return ctx.status = 404;</span><br><span class="hljs-comment"> *     return next();</span><br><span class="hljs-comment"> *   &#125;)</span><br><span class="hljs-comment"> *   .get(&#x27;/users/:user&#x27;, ctx =&gt; &#123;</span><br><span class="hljs-comment"> *     ctx.body = ctx.user;</span><br><span class="hljs-comment"> *   &#125;)</span><br><span class="hljs-comment"> *   .get(&#x27;/users/:user/friends&#x27;, ctx =&gt; &#123;</span><br><span class="hljs-comment"> *     return ctx.user.getFriends().then(function(friends) &#123;</span><br><span class="hljs-comment"> *       ctx.body = friends;</span><br><span class="hljs-comment"> *     &#125;);</span><br><span class="hljs-comment"> *   &#125;)</span><br><span class="hljs-comment"> *   // /users/3 =&gt; &#123;&quot;id&quot;: 3, &quot;name&quot;: &quot;Alex&quot;&#125;</span><br><span class="hljs-comment"> *   // /users/3/friends =&gt; [&#123;&quot;id&quot;: 4, &quot;name&quot;: &quot;TJ&quot;&#125;]</span><br><span class="hljs-comment"> * ```</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">String</span>&#125; <span class="hljs-variable">param</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Function</span>&#125; <span class="hljs-variable">middleware</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns</span> &#123;<span class="hljs-type">Router</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">// 和register新建layer的逻辑类似, register是新建layer, 遍历router.params, 把params匹配到的中间件插到layer.stack最前面</span><br><span class="hljs-comment">// param则是遍历layer, 然后把param设置的中间件插到layer.stack最前面(path多个参数情况下可能不是最前面, 这里先这样形容)</span><br><span class="hljs-title class_">Router</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">param</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">param, middleware</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">params</span>[param] = middleware;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span>.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">const</span> route = <span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span>[i];<br>    route.<span class="hljs-title function_">param</span>(param, middleware);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Generate URL from url pattern and given `params`.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@example</span></span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ```javascript</span><br><span class="hljs-comment"> * const url = Router.url(&#x27;/users/:id&#x27;, &#123;id: 1&#125;);</span><br><span class="hljs-comment"> * // =&gt; &quot;/users/1&quot;</span><br><span class="hljs-comment"> * ```</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">String</span>&#125; path url pattern</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Object</span>&#125; params url parameters</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns</span> &#123;<span class="hljs-type">String</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">// 调用layer的实例方法, 填充参数, 注意到一点, 这里调用的是layer的实例方法, 内部会引用this.path, 所以新建了一个对象&#123;path&#125;来创建上下文</span><br><span class="hljs-comment">// 内部调用了path-to-regexp的compile/toPath方法来实现</span><br><span class="hljs-title class_">Router</span>.<span class="hljs-property">url</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">path</span>) &#123;<br>  <span class="hljs-keyword">const</span> args = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">slice</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>, <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Layer</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">url</span>.<span class="hljs-title function_">apply</span>(&#123; path &#125;, args);<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>canvas</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>canvas实现刮刮卡</title>
    <link href="/2021/06/30/2021-06-30-canvas-scratch-card/"/>
    <url>/2021/06/30/2021-06-30-canvas-scratch-card/</url>
    
    <content type="html"><![CDATA[<h1 id="背景"><a class="markdownIt-Anchor" href="#背景"></a> 背景</h1><p>看了一段时间 canvas, 重拾当初学前端的那种热情, 👱 就是喜欢整点花里胡哨的。正好在掘金上看到不少 canvas 好文章，结合理论进行实战， 记录一下过程中的知识点。</p><h1 id="1-需求分析"><a class="markdownIt-Anchor" href="#1-需求分析"></a> 1 需求分析</h1><p>设计可配置项, 这里分为产品同学看得懂的配置项和技术上的配置项<br />所有配置项包括:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ScratchCardConfig</span> &#123;<br>  <span class="hljs-attr">canvas</span>: <span class="hljs-title class_">HTMLCanvasElement</span>; <span class="hljs-comment">// canvas元素</span><br>  showAllPercent?: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 直接全部刮开百分比</span><br>  coverImg?: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 图片图层</span><br>  coverColor?: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 纯色图层</span><br>  doneCallback?: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span>; <span class="hljs-comment">// 全部刮开回调函数</span><br>  radius?: <span class="hljs-built_in">number</span>; <span class="hljs-comment">//擦除半径</span><br>  <span class="hljs-attr">pixelRatio</span>: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 屏幕倍率, 适应retina屏</span><br>  fadeOut?: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 全部刮开淡出效果时间(ms)</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="2-项目结构"><a class="markdownIt-Anchor" href="#2-项目结构"></a> 2 项目结构</h1><p>因为 canvas 有很多方法和属性,js 无法正确进行代码提示, 所以使用 ts 进行开发</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">|- index.html<br>|- award.jpg  <span class="hljs-regexp">//</span> 底部结果图片<br>|- index.js<br>|- index.ts <span class="hljs-regexp">//</span> 实际编写的逻辑<br>|- scratch-<span class="hljs-number">2</span>x.png <span class="hljs-regexp">//</span> 上层遮罩的图片<br></code></pre></td></tr></table></figure><h1 id="3-具体实现"><a class="markdownIt-Anchor" href="#3-具体实现"></a> 3 具体实现</h1><h2 id="页面结构"><a class="markdownIt-Anchor" href="#页面结构"></a> 页面结构</h2><p>前置知识: canva 设置 width/height 改变的是绘图区域的宽高, 设置 style.width/height 改变的是元素的宽高, 绘图区域没有发生改变, 绘图区域会根据元素宽高等比例缩放.<br />而对于 retina 屏幕(这里指定 2 倍物理像素, 实际项目可以使用 window.devicePixelRatio 判断), 一个逻辑像素 = 2 物理像素, 相当于图片放大了一倍, 所以这里指定 canvas 属性 width/height 为 750/280, style.width/height 为 350/140. 相当于图片缩小一倍. 这样图片就变清晰了.<br /><strong>不要问为什么不直接把 canvas style width/height 直接设为 750/280, 这样图片就无法绘制完全</strong><br />award.jpg 也是一样, 缩小一倍进行显示</p><p>HTML 代码:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;card&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">canvas</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;canvas&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;750&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;280&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">canvas</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>CSS 代码:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.card</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">375px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">140px</span>;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;./award.jpg&#x27;</span>);<br>  <span class="hljs-attribute">background-size</span>: <span class="hljs-number">375px</span> <span class="hljs-number">140px</span>;<br>&#125;<br><span class="hljs-selector-class">.card</span> <span class="hljs-selector-tag">canvas</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">375px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">140px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="初始化"><a class="markdownIt-Anchor" href="#初始化"></a> 初始化</h2><h3 id="构造函数"><a class="markdownIt-Anchor" href="#构造函数"></a> 构造函数</h3><p>设置选填的配置默认值, 直接全部刮开的百分比, 刮开时绘制的圆半径, 纯色遮罩图层的颜色, 全部刮开的淡出时间</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ScratchCard</span> &#123;<br>  <span class="hljs-attr">config</span>: <span class="hljs-title class_">ScratchCardConfig</span>;<br>  <span class="hljs-attr">ctx</span>: <span class="hljs-title class_">CanvasRenderingContext2D</span>;<br>  <span class="hljs-attr">canvas</span>: <span class="hljs-title class_">HTMLCanvasElement</span>;<br>  <span class="hljs-attr">offsetX</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">offsetY</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">done</span>: <span class="hljs-built_in">boolean</span>;<br>  <span class="hljs-attr">isDown</span>: <span class="hljs-built_in">boolean</span>;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">config: ScratchCardConfig</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">config</span> = &#123;<br>      <span class="hljs-attr">showAllPercent</span>: <span class="hljs-number">45</span>,<br>      <span class="hljs-attr">radius</span>: <span class="hljs-number">20</span>,<br>      <span class="hljs-attr">coverColor</span>: <span class="hljs-string">&#x27;#999&#x27;</span>,<br>      <span class="hljs-attr">fadeOut</span>: <span class="hljs-number">2000</span>,<br>      ...config<br>    &#125;;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="遮罩图层"><a class="markdownIt-Anchor" href="#遮罩图层"></a> 遮罩图层</h3><p>这里逻辑很简单, 没有图片图层时设置纯色图层, 需要介绍的是<code>globalCompositeOperation</code>属性, 用于设置两个绘图路径交叉时的渲染方式, <code>destination-out</code>指在源图像外显示目标图像, 源图像透明, 这里 coverImg 是目标图像, 刮开时绘制的圆是源图像, 这样源图像区域就会展示最底部的结果图片</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ScratchCard</span> &#123;<br>  ...<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">config: ScratchCardConfig</span>) &#123;<br>    ...<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_init</span>();<br>  &#125;<br>  <span class="hljs-keyword">private</span> <span class="hljs-title function_">_init</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvas</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">config</span>.<span class="hljs-property">canvas</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">ctx</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvas</span>.<span class="hljs-title function_">getContext</span>(<span class="hljs-string">&#x27;2d&#x27;</span>);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">offsetX</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvas</span>.<span class="hljs-property">offsetLeft</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">offsetY</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvas</span>.<span class="hljs-property">offsetTop</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_addEvent</span>();<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">config</span>.<span class="hljs-property">coverImg</span>) &#123;<br>      <span class="hljs-comment">// 设置的是图片图层</span><br>      <span class="hljs-keyword">const</span> coverImg = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Image</span>();<br>      coverImg.<span class="hljs-property">src</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">config</span>.<span class="hljs-property">coverImg</span>;<br>      coverImg.<span class="hljs-property">onload</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">ctx</span>.<span class="hljs-title function_">drawImage</span>(coverImg, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">ctx</span>.<span class="hljs-property">globalCompositeOperation</span> = <span class="hljs-string">&#x27;destination-out&#x27;</span>;<br>      &#125;;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 纯色图层</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">ctx</span>.<span class="hljs-property">fillStyle</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">config</span>.<span class="hljs-property">coverColor</span>;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">ctx</span>.<span class="hljs-title function_">fillRect</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvas</span>.<span class="hljs-property">width</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvas</span>.<span class="hljs-property">height</span>);<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">ctx</span>.<span class="hljs-property">globalCompositeOperation</span> = <span class="hljs-string">&#x27;destination-out&#x27;</span>;<br>    &#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="绑定事件"><a class="markdownIt-Anchor" href="#绑定事件"></a> 绑定事件</h2><p>刮奖效果其实就是通过绑定<code>touchstart</code>, <code>touchmove</code>, <code>touchend</code>事件来绘制源图像, 这里把 mouse 事件也加上<br />这里通过监听<code>touchmove</code>来绘制图像, <code>touchstart</code>和<code>touchend</code>来控制开始停止<br />虽然默认 addEventListener 第三个参数的属性 passive 用于控制是否禁用 preventDefault, 默认是 false, 但是还是要显式指定{passive: false}, 因为<code>touchstart</code>和<code>touchend</code>passive 默认值还是 true<br />isDown 表示是否触摸屏幕</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ScratchCard</span> &#123;<br>  ...<br>  <span class="hljs-keyword">private</span> <span class="hljs-title function_">_addEvent</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvas</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;touchstart&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">_eventDown</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>), &#123; <span class="hljs-attr">passive</span>: <span class="hljs-literal">false</span> &#125;);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvas</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;touchend&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">_eventUp</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>), &#123; <span class="hljs-attr">passive</span>: <span class="hljs-literal">false</span> &#125;);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvas</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;touchmove&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">_scratch</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>), &#123; <span class="hljs-attr">passive</span>: <span class="hljs-literal">false</span> &#125;);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvas</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;mousedown&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">_eventDown</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>), &#123; <span class="hljs-attr">passive</span>: <span class="hljs-literal">false</span> &#125;);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvas</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;mouseup&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">_eventUp</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>), &#123; <span class="hljs-attr">passive</span>: <span class="hljs-literal">false</span> &#125;);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvas</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;mousemove&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">_scratch</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>), &#123; <span class="hljs-attr">passive</span>: <span class="hljs-literal">false</span> &#125;);<br>  &#125;<br>  <span class="hljs-keyword">private</span> <span class="hljs-title function_">_eventDown</span>(<span class="hljs-params">e: MouseEvent | TouchEvent</span>) &#123;<br>    e.<span class="hljs-title function_">preventDefault</span>();<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">isDown</span> = <span class="hljs-literal">true</span>;<br>  &#125;<br>  <span class="hljs-keyword">private</span> <span class="hljs-title function_">_eventUp</span>(<span class="hljs-params">e: MouseEvent | TouchEvent</span>) &#123;<br>    e.<span class="hljs-title function_">preventDefault</span>();<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">isDown</span> = <span class="hljs-literal">false</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="擦除效果"><a class="markdownIt-Anchor" href="#擦除效果"></a> 擦除效果</h2><p>逻辑大致如下:</p><ol><li>判断刮刮卡还没挂完 this.done 为 false, 且处于按下状态 this.isDown 为 true</li><li>如果存在多个触点, 则使用最后一个触点, 使用 e.changedTouches 获取最后一个触点</li><li>获取当前点击的坐标 x, y, 这里 ev.clientX + document.body.scrollLeft 相当于 ev.pageX</li><li>绘图</li></ol><p>需要注意的是这里不能用解构赋值<code>const &#123; beginPath, arc, fill &#125; = this.ctx;</code>,会使绘图方法的上下文失效, 可以用 <code>with(this.ctx)</code>, 但不推荐</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-title function_">_scratch</span>(<span class="hljs-params">e: MouseEvent | TouchEvent</span>) &#123;<br>  e.<span class="hljs-title function_">preventDefault</span>();<br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">ev</span>: <span class="hljs-title class_">MouseEvent</span> | <span class="hljs-title class_">Touch</span> = e <span class="hljs-keyword">as</span> <span class="hljs-title class_">MouseEvent</span>;<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">done</span> &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">isDown</span>) &#123;<br>    <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">TouchEvent</span> &amp;&amp; e.<span class="hljs-property">changedTouches</span>) &#123;<br>      ev = e.<span class="hljs-property">changedTouches</span>[e.<span class="hljs-property">changedTouches</span>.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-comment">// (ev.clientX + document.body.scrollLeft) || ev.pageX</span><br>    <span class="hljs-keyword">const</span> x = (ev.<span class="hljs-property">clientX</span> + <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">scrollLeft</span> || ev.<span class="hljs-property">pageX</span>) - <span class="hljs-variable language_">this</span>.<span class="hljs-property">offsetX</span> || <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">const</span> y = (ev.<span class="hljs-property">clientY</span> + <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">scrollTop</span> || ev.<span class="hljs-property">pageY</span>) - <span class="hljs-variable language_">this</span>.<span class="hljs-property">offsetY</span> || <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// const &#123; beginPath, arc, fill &#125; = this.ctx;</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">ctx</span>.<span class="hljs-title function_">beginPath</span>();<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">ctx</span>.<span class="hljs-title function_">arc</span>(<br>      x * <span class="hljs-variable language_">this</span>.<span class="hljs-property">config</span>.<span class="hljs-property">pixelRatio</span>,<br>      y * <span class="hljs-variable language_">this</span>.<span class="hljs-property">config</span>.<span class="hljs-property">pixelRatio</span>,<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">config</span>.<span class="hljs-property">radius</span> * <span class="hljs-variable language_">this</span>.<span class="hljs-property">config</span>.<span class="hljs-property">pixelRatio</span>,<br>      <span class="hljs-number">0</span>,<br>      <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> * <span class="hljs-number">2</span><br>    );<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">ctx</span>.<span class="hljs-title function_">fill</span>();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="全部刮开"><a class="markdownIt-Anchor" href="#全部刮开"></a> 全部刮开</h2><p>这里就是判断刮开的区域百分比是否超过初始化时设置的阈值, 如果有淡出效果则设置 canvas 的 style.transition, 没有就直接清除画布.<br />这里判断刮开区域所占百分比的方法<code>_getFilledPercentage()</code>具体逻辑如下:</p><ol><li>首先要知道 imgData.data 获得的是一个 Uint8Array 点阵数组, 其中 4 个字节表示一个像素, 每个字节分别代表 rgba</li><li>所以这里需要从 i=3 开始累加 4 计算 alpha=0(也可以不是 0,通过设置能够表示透明的阈值)的个数, 最后除以像素数就能够得到刮开区域的百分比</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-title function_">_scratch</span>(<span class="hljs-params">e: MouseEvent | TouchEvent</span>) &#123;<br>    ...<br>      <span class="hljs-comment">// 判断刮百分比</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_getFilledPercentage</span>() &gt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">config</span>.<span class="hljs-property">showAllPercent</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_scratchAll</span>();<br>      &#125;<br>    &#125;<br>  &#125;<br><span class="hljs-title function_">_scratchAll</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">done</span> = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">config</span>.<span class="hljs-property">fadeOut</span> &gt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvas</span>.<span class="hljs-property">style</span>.<span class="hljs-property">transition</span> = <span class="hljs-string">`all <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.config.fadeOut&#125;</span>ms linear`</span>;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvas</span>.<span class="hljs-property">style</span>.<span class="hljs-property">opacity</span> = <span class="hljs-string">&#x27;0&#x27;</span>;<br>      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_clear</span>();<br>      &#125;, <span class="hljs-variable language_">this</span>.<span class="hljs-property">config</span>.<span class="hljs-property">fadeOut</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_clear</span>();<br>    &#125;<br>    <span class="hljs-comment">// 执行回调</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">config</span>?.<span class="hljs-title function_">doneCallback</span>();<br>  &#125;<br>  <span class="hljs-title function_">_clear</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">ctx</span>.<span class="hljs-title function_">fillRect</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvas</span>.<span class="hljs-property">width</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvas</span>.<span class="hljs-property">height</span>);<br>  &#125;<br>  <span class="hljs-comment">// 计算刮开区域百分比, 即计算画布透明区域百分比</span><br>  <span class="hljs-title function_">_getFilledPercentage</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> imgData = <span class="hljs-variable language_">this</span>.<span class="hljs-property">ctx</span>.<span class="hljs-title function_">getImageData</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvas</span>.<span class="hljs-property">width</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvas</span>.<span class="hljs-property">height</span>);<br>    <span class="hljs-comment">// 点阵数组, 4个字节为一个像素, 每个字节分别代表rgba</span><br>    <span class="hljs-keyword">const</span> pixels = imgData.<span class="hljs-property">data</span>;<br>    <span class="hljs-keyword">let</span> threshold = <span class="hljs-number">0</span>; <span class="hljs-comment">// 这里可以设置阈值表示代表透明的分界线</span><br>    <span class="hljs-keyword">let</span> transparentPixelCount = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">3</span>; i &lt; pixels.<span class="hljs-property">length</span>; i += <span class="hljs-number">4</span>) &#123;<br>      <span class="hljs-keyword">if</span> (pixels[i] &lt;= threshold) &#123;<br>        transparentPixelCount++;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Number</span>(((transparentPixelCount / (pixels.<span class="hljs-property">length</span> / <span class="hljs-number">4</span>)) * <span class="hljs-number">100</span>).<span class="hljs-title function_">toFixed</span>(<span class="hljs-number">2</span>));<br>  &#125;<br></code></pre></td></tr></table></figure><p>由于 ImageData 的跨域问题, 不要在本地直接打开, 可以启动一个静态服务器以 http 形式打开<br />完整代码已上传到 github<a href="https://github.com/Mariana-Yui/scratchcard">查看源码</a></p><h1 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h1><ul><li><a href="https://juejin.cn/post/6844903952157245447">一张刮刮卡竟包含这么多前端知识点</a></li><li><a href="https://segmentfault.com/a/1190000021232132">一张图搞定原型链</a></li><li><a href="https://cloud.tencent.com/developer/article/1501018">解决 canvas 在高清屏中绘制模糊的问题</a></li><li><a href="https://www.itread01.com/content/1550405736.html">js 中的 scrollleft、style.left、clientLeft、offsetLeft</a></li><li><a href="https://stackoverflow.com/questions/58820279/how-to-calculate-transparent-area-of-canvas-in-percentage">计算 canvas 透明区域百分比</a></li><li><a href="https://segmentfault.com/a/1190000002405897">鼠标点击位置坐标</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>canvas</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决git push时the requested upstream branch &#39;origin/main&#39; does not exist</title>
    <link href="/2021/06/29/2021-06-29-git-branch-set-up-stream/"/>
    <url>/2021/06/29/2021-06-29-git-branch-set-up-stream/</url>
    
    <content type="html"><![CDATA[<h1 id="背景"><a class="markdownIt-Anchor" href="#背景"></a> 背景</h1><p>本地文件夹未关联远程仓库, 在 github 新建仓库后,远程仓库也有文件<br />本地仓库关联远程仓库<br /><code>git branch --set-upstream-to=origin/main master</code><br />会出现<br /><img src="https://dev.azure.com/HealMSlin/8544be09-1224-4eb0-824b-90c4ec9d49ee/_apis/git/repositories/7a27a721-4c93-4ecf-8258-d5422217b60a/items?path=%2F1624955303018_9856.png&amp;versionDescriptor%5BversionOptions%5D=0&amp;versionDescriptor%5BversionType%5D=0&amp;versionDescriptor%5Bversion%5D=master&amp;resolveLfs=true&amp;%24format=octetStream&amp;api-version=5.0" alt="" /></p><h1 id="解决流程"><a class="markdownIt-Anchor" href="#解决流程"></a> 解决流程</h1><ol><li><code>git remote add origin 远程仓库地址</code></li><li><code>git pull origin master --allow-unrelated-histories</code></li><li><code>git branch --set-upstream-to=origin/main master</code></li><li><code>git push</code></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue3初体验</title>
    <link href="/2021/06/25/2021-06-08-vue3-learning-note/"/>
    <url>/2021/06/25/2021-06-08-vue3-learning-note/</url>
    
    <content type="html"><![CDATA[<blockquote><p>学啊…学不动也得学啊…<br />        ---- 导语</p></blockquote><br><h1 id="vue3-与-typescript"><a class="markdownIt-Anchor" href="#vue3-与-typescript"></a> Vue3 与 Typescript</h1><p><strong>2021-06-08updated</strong> 忘记啥时候写的笔记…之前存在本地, 现在 push 到博客上, 方便以后查阅<s>黑历史</s> 不定期更新</p><h2 id="是否还需要-babel"><a class="markdownIt-Anchor" href="#是否还需要-babel"></a> 是否还需要 babel?</h2><p>答案是需要的, tsc 只负责了转义语法, 没有对 Map,Set 等新增数据结构和 react 的 jsx 语法做实现, 所以还是需要 babel(tmd 找了半天是否还需要 babel 全都答非所问)<br />可以参考:   <a href="https://juejin.cn/post/6955430382485553166">1. webpack5 搭建 Vue3+TS 项目</a><br />也可以看看该博主的  <a href="https://juejin.cn/post/6844903663408775176">2. webpack4 搭建 Vue 项目</a></p><h2 id="setup"><a class="markdownIt-Anchor" href="#setup"></a> setup</h2><p><code>setup</code>中无法访问 this, <code>return</code>的属性必须都是 Ref 响应式的<br /><code>setup</code>函数接收两个参数<code>props</code>和<code>emits</code>, 表示外部传入的参数<code>props</code>和向外部发送的事件<code>emits</code></p><h2 id="reactive"><a class="markdownIt-Anchor" href="#reactive"></a> reactive</h2><p><code>reactive</code>方法构建 Proxy, 如果要对 data 中的属性做响应式要做<code>toRefs</code>或者<code>toRef</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-attr">data</span>: <span class="hljs-title class_">Data</span>&lt;T&gt; = <span class="hljs-title function_">reactive</span>(&#123;<br>  <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>,<br>  <span class="hljs-attr">double</span>: <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> data.<span class="hljs-property">count</span> * <span class="hljs-number">2</span>),<br>  <span class="hljs-attr">increase</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>    data.<span class="hljs-property">count</span>++;<br>  &#125;,<br>&#125;);<br><span class="hljs-keyword">const</span> refData = <span class="hljs-title function_">toRefs</span>(data);<br><span class="hljs-keyword">return</span> &#123;<br>  ...refData,<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="watch"><a class="markdownIt-Anchor" href="#watch"></a> watch</h2><p>参数可以是<code>ref</code>, <code>reactive</code>, <code>getter函数</code>和包含前面三个的数组<br />如果想要监听<code>reactive</code>中的属性需要使用<code>getter</code>的方式, 如<code>watch(() =&gt; data.count)</code>, 而不能直接使用<code>watch(data.count)</code></p><h2 id="props"><a class="markdownIt-Anchor" href="#props"></a> props</h2><p>和 vue2 用法一样, 表示外部传入参数</p><h2 id="emits"><a class="markdownIt-Anchor" href="#emits"></a> emits</h2><p><code>emits</code>用于声明需要向外部暴露的事件名, 可以是数组和对象, 对象 key 是事件名, 值可以是函数和 null, 函数必须有布尔类型返回值, <strong>这里的函数不仅作为拦截器, 也作为 typescript 的类型定义</strong> <code>setup</code>调用使用<code>context.emit</code>, 用法和 vue2 一样, vue3 会先执行<code>emits</code>中对应的回调再返回给父组件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-attr">emits</span>: &#123;<br>  <span class="hljs-string">&#x27;close-model&#x27;</span>: <span class="hljs-function">(<span class="hljs-params">params</span>) =&gt;</span> boolean | <span class="hljs-literal">null</span><br>&#125;,<br><span class="hljs-comment">// emits: [&#x27;close-model&#x27;],</span><br><span class="hljs-title function_">setup</span>(<span class="hljs-params">props, context</span>) &#123;<br>  context.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;close-model&#x27;</span>, &#123;<br>    <span class="hljs-attr">signal</span>: <span class="hljs-string">&#x27;close&#x27;</span><br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="teleport"><a class="markdownIt-Anchor" href="#teleport"></a> teleport</h2><p><s><code>TP是英雄联盟的一项召唤师技能</code></s> 有的组件例如对话框放在<code>#app</code>内是不合适的, <code>teleport</code>可以将组件一键传送到 html 中的另外一个 DOM 结构下, 用法如下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 组件内 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">teleport</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;#model&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>This is a dialog.<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">teleport</span>&gt;</span><br><span class="hljs-comment">&lt;!-- teleport中内容会被渲染到id=model的DOM节点下 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;#app&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;model&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="suspense"><a class="markdownIt-Anchor" href="#suspense"></a> Suspense</h2><p>vue 从 react 借鉴来的异步组件, 在<code>&lt;Suspense&gt;</code>中包含两个<code>template</code>插槽, <code>default</code>插槽放置异步组件, 在异步组件数据未完全返回时先渲染<code>fallback</code>插槽内容, 数据完全返回后再渲染异步组件内容</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">Suspense</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">default</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dog-show</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dog-show</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">fallback</span>&gt;</span> Loading... <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Suspense</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="props-2"><a class="markdownIt-Anchor" href="#props-2"></a> props</h2><ol><li>用法和 vue2 一样</li><li>在 vue2 基础上添加上对<code>typescript</code>的支持, 细化了类型声明, 如<code>Object as PropType&lt;UserProps&gt;</code>, <code>PropType&lt;T&gt;</code>为<code>props</code>的泛型, <code>T</code>即<code>type</code></li><li>记得在 vue 中引入<code>import &#123; PropType &#125; from 'vue'</code></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-attr">props</span>: &#123;<br>  <span class="hljs-attr">user</span>: &#123;<br>    <span class="hljs-attr">type</span>: <span class="hljs-title class_">Object</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">PropType</span>&lt;<span class="hljs-title class_">UserProps</span>&gt;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="ref"><a class="markdownIt-Anchor" href="#ref"></a> ref</h2><p>vue2 中<code>ref</code>用于获取 DOM 节点或者组件实例, 在 vue3 中用法类似</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> dropdownRef = ref&lt;<span class="hljs-literal">null</span> | <span class="hljs-title class_">HTMLElement</span>&gt;(<span class="hljs-literal">null</span>);<br>  <span class="hljs-keyword">return</span> &#123;<br>    dropdownRef<br>  &#125;<br>&#125;<br><br>&lt;div ref=<span class="hljs-string">&quot;dropdownRef&quot;</span>&gt;&lt;/div&gt;<br></code></pre></td></tr></table></figure><h2 id="禁用-attribute-继承"><a class="markdownIt-Anchor" href="#禁用-attribute-继承"></a> 禁用 Attribute 继承</h2><ol><li>默认地, vue 会将传向一个组件的非 prop 的<code>attribute</code>自动添加到根节点的<code>attribute</code>中, 可以通过<code>inheritAttrs: false</code>来禁止这种行为</li><li>如果要将上述<code>attribute</code>全部复制给组件中一个节点, 可以使用<code>v-bind=&quot;$attrs&quot;</code>, 例如<code>&lt;input v-bind=&quot;$attrs&quot;&gt;</code></li></ol><h2 id="slot"><a class="markdownIt-Anchor" href="#slot"></a> slot</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 子组件</span><br>&lt;slot name=<span class="hljs-string">&quot;default&quot;</span>&gt;&lt;/slot&gt;<br><span class="hljs-comment">// 父组件</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">default</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h1 id="vuex"><a class="markdownIt-Anchor" href="#vuex"></a> Vuex</h1><h2 id="vue3-中的-vuex"><a class="markdownIt-Anchor" href="#vue3-中的-vuex"></a> vue3 中的 vuex</h2><p>vue3 中<code>vuex</code>通过<code>createStore</code>创建<code>store</code>, <code>useStore</code>使用<code>store</code>, 两个函数都是泛型, 都可以通过<code>xxStore&lt;GlobalProps&gt;</code>的方式指定<code>store中state</code>的结构</p><h2 id="getter"><a class="markdownIt-Anchor" href="#getter"></a> getter</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-attr">getter</span>: &#123;<br>  <span class="hljs-comment">// 返回值</span><br>  <span class="hljs-attr">propertyName</span>: <span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> state.<span class="hljs-property">propertyValue</span>;<br>  &#125;,<br>  <span class="hljs-comment">// 返回方法</span><br>  <span class="hljs-attr">propertyName</span>: <span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> <span class="hljs-function">(<span class="hljs-params">id</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> state.<span class="hljs-property">propertyValue</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="项目中知识点"><a class="markdownIt-Anchor" href="#项目中知识点"></a> 项目中知识点</h1><h2 id="组件传参"><a class="markdownIt-Anchor" href="#组件传参"></a> 组件传参</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;dropdown-item disabled&gt;&lt;/dropdown-item&gt;<br><span class="hljs-comment">// 相当于</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dropdown-item</span> <span class="hljs-attr">:disabled</span>=<span class="hljs-string">&quot;true&quot;</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dropdown-item</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h2 id="子元素高度-100"><a class="markdownIt-Anchor" href="#子元素高度-100"></a> 子元素高度 100%</h2><p>高度%百分比计算是根据父元素的高度计算的, 所以如果只有父元素设置了<code>height: 100%</code>, 浏览器并不知道父元素具体 height 是多少, 但是给<code>html</code>设置<code>height: 100%</code>则是有效的, 浏览器会知道<code>html</code>的高度为浏览器可视区域的高度, 所以 css 代码应该对需要子元素的祖先元素都设置<code>height: 100%</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 祖先元素 */</span><br><span class="hljs-selector-tag">html</span>,<br><span class="hljs-selector-tag">body</span>,<br><span class="hljs-selector-id">#app</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br>&#125;<br><span class="hljs-comment">/* 子元素 */</span><br><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">min-height</span>: <span class="hljs-number">100%</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="遇到的问题"><a class="markdownIt-Anchor" href="#遇到的问题"></a> 遇到的问题</h1><blockquote><p>Q: Already included file name … … only in casing.Vetur(1261)<br />A: 添加<code>&quot;forceConsistentCasingInFileNames&quot;: false</code>到<code>tsconfig.json</code>的<code>compilerOptions</code></p></blockquote><br><blockquote><p>Q: typescript 中全局变量声明如何配置?<br />A: <code>tsconfig.json</code>的<code>compilerOptions</code>中<code>typeRoots</code>属性数组加入全局声明文件路径</p></blockquote><br><blockquote><p>Q: vue-devtools 在 Vue3 中不显示<br />A: Chrome 商店下载 beta 版 vue-devtools</p></blockquote><br><blockquote><p>Q: F12 控制台 vue panel 不显示<br />A: 更多工具 &gt; 扩展程序 &gt; vue-devtools 开启允许访问文件网址</p></blockquote><br>]]></content>
    
    
    
    <tags>
      
      <tag>webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webpack中path/publicPath/contentBase傻傻分不清楚</title>
    <link href="/2021/06/25/2021-06-25-path-publicPath-contentBase/"/>
    <url>/2021/06/25/2021-06-25-path-publicPath-contentBase/</url>
    
    <content type="html"><![CDATA[<p><strong>2022.10.01 更新: 时隔一年多在 webpack5 下的全新认知. <s>其实是忘得差不多重新学习了下</s> 当然下面的知识并没有过时~</strong><br />[[2022-09-30-study-webpack-day7#publicPath path contentBase in webpack5]]</p><h1 id="path-vs-publicpath-vs-contentbase"><a class="markdownIt-Anchor" href="#path-vs-publicpath-vs-contentbase"></a> path vs. publicPath vs. contentBase</h1><h2 id="outputpath"><a class="markdownIt-Anchor" href="#outputpath"></a> output.path</h2><p>绝对路径, 代表打包在本地磁盘上的物理位置.<br />比如:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">output</span>: &#123;<br>  <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;[name].js&#x27;</span>,<br>  <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;../dist&#x27;</span>),<br>  <span class="hljs-attr">publicPath</span>: <span class="hljs-string">&#x27;/dev/&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这个配置项在生产环境下是必须的, 因为你总要指定打包生成的最终路径. 但是在开发模式下不是必须的, 因为<code>webpackDevServer</code>打包出来的文件都在内存中而没有打包到磁盘中.<br /><code>path</code>属性容易理解, 经常容易弄混的是<code>publicPath</code>和<code>contentBase</code>属性</p><h2 id="outputpublicpath"><a class="markdownIt-Anchor" href="#outputpublicpath"></a> output.publicPath</h2><p>打包出来的资源的 URL 前缀(这里打包在生产模式和开发模式都很重要, 区别在于前者打包在硬盘, 后者打包在内存), 即在浏览器中访问的路径前缀,可以填写为相对路径和绝对路径:</p><ul><li>相对路径会被解析为相对 HTML 的路径</li><li>绝对路径, 比如 CDN 路径</li></ul><p>事实上在实际开发中会通过当前的环境设置<code>publicPath</code>为 CDN 路径还是普通绝对路径, 这个配置项会被加入每一个 runtime 或者 loader 产生的 URL 中, 所以这个配置项最好是以 <code>/</code> 结尾<br /><img src="https://camo.githubusercontent.com/2c9930b2b20dd0576ffd37c83f893f751833feefdffceb00c8f446c2ac306084/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f313630302f312a614f4d355a4638616c574c723442433043665a6530772e706e67" alt="示例图" /></p><h2 id="devserverpublicpath"><a class="markdownIt-Anchor" href="#devserverpublicpath"></a> devServer.publicPath</h2><p>开启<code>webpackDevServer</code>时浏览器可以通过<code>devServer.publicPath</code>中设置的路径来访问<strong>bundled 被打包</strong>的文件, 通过访问<code>http://localhost:8080/webpack-dev-server</code>可以得到 devServer 启动后的打包资源访问路径, 点击资源可以看到打包资源的访问路径为<code>http://localhost:8080$&#123;publicPath&#125;main.js</code>, 如图所示:<br /><img src="https://user-gold-cdn.xitu.io/2018/5/2/16320c647d8b1594?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="" /><br />没有设置<code>devServer.publicPath</code>时, 默认值为<code>output.publicPath</code>, 和<code>output.publicPath</code>非常相似, 都是为浏览器指定访问路径的前缀, 一般来说开发环境下<code>devServer.publicPath</code>都需要和<code>output.publicPath</code>保持一致.举个反 🌰</p><ol><li>output.publicPath 设置了<code>/mb/v5/</code></li><li>devServer.publicPath 设置了<code>/mb/v4</code></li><li>打包出来 js 文件为<code>/mb/v5/js/vendor~12345678.js</code></li><li>实际上通过<code>http://localhost:8080/webpack-dev-server</code>查询访问的路径实际是<code>/mb/v4/js/vendor~12345678.js</code></li><li>404 报错</li></ol><p>总结来说, output.publicPath 指定路径(仅仅是对打包路径字符串进行修改), devServer.publicPath 则是对该路径设置了一个类似 express.static 的文件系统服务器, 服务器路径和设置路径对不上自然就无法访问了</p><h2 id="devservercontentbase"><a class="markdownIt-Anchor" href="#devservercontentbase"></a> devServer.contentBase</h2><p>决定了 <code>webpackDevServer</code> 启动是服务器<strong>静态资源</strong>的根目录, 默认是项目根目录<br />这里的静态资源指图片, 字体等资源, 而不是指 bundled 被打包的资源, 在有静态资源的时候必填, <code>contentBase</code>不会影响<code>path</code>和<code>publicPath</code>, 他唯一作用是指定服务器静态资源根目录来引用静态文件.<br /><code>devServer.contentBase</code>和<code>devServer.publicPath</code>的关系: <code>contentBase</code>是服务于静态资源文件的路径, <code>publicPath</code>是服务于打包出来的文件访问的路径, 两者互不影响。</p><h2 id="htmlwebpackplugin"><a class="markdownIt-Anchor" href="#htmlwebpackplugin"></a> htmlWebpackPlugin</h2><p><code>htmlWebpackPlugin</code>用于向 html 中插入打包好的 js 文件, 而这个路径是根据<code>output.publicPath</code>决定的.官网文档中有这么一句话:</p><blockquote><p>If you’ve set a publicPath in your webpack config this will be reflected correctly in this assets hash.<br />It is recommended that <code>devServer.publicPath</code> is the same as <code>output.publicPath</code>.</p></blockquote><p>所以就像他说的, 把<code>output.publicPath</code>和<code>devServer.publicPath</code>设置成一样吧。</p><h1 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h1><ul><li><a href="https://github.com/fi3ework/blog/issues/39">Webpack 中 path/publicPath/contenBase 的关系</a></li><li><a href="https://juejin.cn/post/6844903601060446221">Webpack 中 publicPath 详解</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker学习记录</title>
    <link href="/2021/06/07/2021-06-07-docker-learning-note/"/>
    <url>/2021/06/07/2021-06-07-docker-learning-note/</url>
    
    <content type="html"><![CDATA[<blockquote><p>如果不是真的菜 🐔, 谁又愿意当韭菜呢</p></blockquote><h2 id="docker-的基本概念"><a class="markdownIt-Anchor" href="#docker-的基本概念"></a> docker 的基本概念</h2><h3 id="docker-和-k8"><a class="markdownIt-Anchor" href="#docker-和-k8"></a> docker 和 k8</h3><h3 id="什么是镜像-image"><a class="markdownIt-Anchor" href="#什么是镜像-image"></a> 什么是镜像 image?</h3><blockquote><p>操作系统分为内核和用户空间。对于 Linux 而言，内核启动后，会挂载 root 文件系统为其提供用户空间支持。而 Docker 镜像（Image），就相当于是一个 root 文件系统。<br />Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。 镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p></blockquote><h3 id="什么是容器-container"><a class="markdownIt-Anchor" href="#什么是容器-container"></a> 什么是容器 container?</h3><blockquote><p>镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的 类 和 实例 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等 。</p></blockquote><h3 id="容器和虚拟机的区别"><a class="markdownIt-Anchor" href="#容器和虚拟机的区别"></a> 容器和虚拟机的区别</h3><ul><li>容器是 APP 层面的隔离</li><li>虚拟化是物理资源层面的隔离</li></ul><p>看两张图帮助理解</p><details><summary>点我!点我!</summary><p><b>容器</b><p><img src="https://dev.azure.com/HealMSlin/8544be09-1224-4eb0-824b-90c4ec9d49ee/_apis/git/repositories/7a27a721-4c93-4ecf-8258-d5422217b60a/items?path=%2F1623078548626_3123.png&amp;versionDescriptor%5BversionOptions%5D=0&amp;versionDescriptor%5BversionType%5D=0&amp;versionDescriptor%5Bversion%5D=master&amp;resolveLfs=true&amp;%24format=octetStream&amp;api-version=5.0" alt="容器架构" /></p><p><b>虚拟化</b></p><p><img src="https://dev.azure.com/HealMSlin/8544be09-1224-4eb0-824b-90c4ec9d49ee/_apis/git/repositories/7a27a721-4c93-4ecf-8258-d5422217b60a/items?path=%2F1623078579393_5295.png&amp;versionDescriptor%5BversionOptions%5D=0&amp;versionDescriptor%5BversionType%5D=0&amp;versionDescriptor%5Bversion%5D=master&amp;resolveLfs=true&amp;%24format=octetStream&amp;api-version=5.0" alt="虚拟化架构" /></p></p></details><h3 id="vagrant"><a class="markdownIt-Anchor" href="#vagrant"></a> vagrant</h3><p>vagrant 是用于构建及配置虚拟开发环境的软件, 需要借助 virtualbox/vm 才能使用, 否则使用 vagrant 报错<br />virtualbox 需要事先安装, vagrant 的安装可以通过官网下载 pkg 文件进行安装</p><h4 id="vagrant-常用命令"><a class="markdownIt-Anchor" href="#vagrant-常用命令"></a> vagrant 常用命令</h4><ul><li><code>vagrant init 系统版本</code>: 初始化需要安装的系统的配置文件, 会生成一个文件名为 vagrantfile. 可以通过在<a href="https://app.vagrantup.com/boxes/search">官网</a>上直接查询 vagrantfile 配置</li><li><code>vagrant up</code>: 下载 vagrantfile 中配置的系统, 结束后启动系统, 如果已经下载过了系统则直接启动</li><li><code>vagrant ssh</code>: 本地连接登录虚拟机</li><li><code>vagrant halt</code>: 关闭系统</li><li><code>vagrant status</code>: 查看当前虚拟机状态</li></ul><h2 id="安装-docker"><a class="markdownIt-Anchor" href="#安装-docker"></a> 安装 docker</h2><p>博主是通过 vagrant 安装 centos 的方式在 linux 上安装 docker, 为了和本机系统隔离. 参考<a href="https://docs.docker.com/engine/install/centos/">centos 安装 docker</a><br />window 和 mac 都可以在官网搜索相应安装包下载</p><p><strong>tips</strong> centos 下 docker 命令都需要 sudo 执行, 可以通过以下方式避免输入 sudo, <strong>记得重新登入 shell</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">sudo groupadd docker<br>sudo gpasswd -<span class="hljs-selector-tag">a</span> vagrant docker<br>sudo systemctl restart docker<br></code></pre></td></tr></table></figure><h3 id="docker-镜像"><a class="markdownIt-Anchor" href="#docker-镜像"></a> docker 镜像</h3><p>docker 官方自带的镜像非常慢, 可以使用阿里云或者中科大等提供的镜像, mac 可以直接通过图像化管理工具设置镜像源, <code>perforence -&gt; Docker Engine</code>, 把下面的配置添加到 json 中</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;registry-mirrors&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>  <span class="hljs-string">&quot;https://n3znd2n8.mirror.aliyuncs.com&quot;</span><br><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br></code></pre></td></tr></table></figure><h4 id="centos7-更换镜像源"><a class="markdownIt-Anchor" href="#centos7-更换镜像源"></a> centos7 更换镜像源</h4><ol><li>写入镜像源<code>sudo vi /etc/docker/daemon.json</code></li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;registry-mirrors&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;https://registry.docker-cn.com&quot;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>重新启动 docker</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo systemctl daemon-reload<br>sudo systemctl restart docker<br>sudo systemctl <span class="hljs-built_in">enable</span> docker<br></code></pre></td></tr></table></figure><details><summary>mac配置镜像</summary><p><p><img src="https://dev.azure.com/HealMSlin/8544be09-1224-4eb0-824b-90c4ec9d49ee/_apis/git/repositories/7a27a721-4c93-4ecf-8258-d5422217b60a/items?path=%2F1623151731192_4260.png&amp;versionDescriptor%5BversionOptions%5D=0&amp;versionDescriptor%5BversionType%5D=0&amp;versionDescriptor%5Bversion%5D=master&amp;resolveLfs=true&amp;%24format=octetStream&amp;api-version=5.0" alt="配置镜像" /></p></p></details><h2 id="docker-machine"><a class="markdownIt-Anchor" href="#docker-machine"></a> docker-machine</h2><p><code>docker-machine</code>也可以像<code>vagrant</code>一样创建并管理多台虚机</p><h3 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h3><h4 id="macos-安装"><a class="markdownIt-Anchor" href="#macos-安装"></a> MacOS 安装</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ base=https://github.com/docker/machine/releases/download/v0.16.0 &amp;&amp;<br>  curl -L <span class="hljs-variable">$base</span>/docker-machine-$(<span class="hljs-built_in">uname</span> -s)-$(<span class="hljs-built_in">uname</span> -m) &gt;/usr/local/bin/docker-machine &amp;&amp;<br>  <span class="hljs-built_in">chmod</span> +x /usr/local/bin/docker-machine<br></code></pre></td></tr></table></figure><h4 id="检查安装成功"><a class="markdownIt-Anchor" href="#检查安装成功"></a> 检查安装成功</h4><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">$ docker-machine <span class="hljs-built_in">version</span><br>docker-machine <span class="hljs-built_in">version</span> <span class="hljs-number">0.16</span><span class="hljs-number">.0</span>, build <span class="hljs-number">702</span>c267f<br></code></pre></td></tr></table></figure><h3 id="常用命令"><a class="markdownIt-Anchor" href="#常用命令"></a> 常用命令</h3><ul><li><code>docker-machine create [name]</code>: 创建一台安装好 docker 的 linux 虚机, <code>[name]</code>为自定义虚机名称</li><li><code>docker-machine ls</code>: 查看创建的虚机列表</li><li><code>docker-machine stop [name]</code>: 关闭[name]虚机</li><li><code>docker-machine start [name]</code>: 开启[name]虚机</li><li><code>docker-machine ssh [name]</code>: 登录[name]虚机</li><li><code>docker-machine rm [name]</code>: 删除[name]虚机</li></ul><p><strong>以下内容未额外说明都是在 vagrant 创建的 centos 虚机上进行演示</strong></p><h2 id="image-container"><a class="markdownIt-Anchor" href="#image-container"></a> image &amp; container</h2><p>上面说过了 image 是一个独立的文件系统, container 是不同 image 在这个文件系统上的叠加生成的实例</p><h3 id="hub"><a class="markdownIt-Anchor" href="#hub"></a> Hub</h3><p>docker 也提供了像 github 一样的托管平台, 存放常用的一系列软件的 image 镜像. <a href="https://hub.docker.com/">点击访问</a><br />可以通过<code>docker pull [IMAGE NAME]</code>的方式下载 image</p><h3 id="亲手写一个-image-demo"><a class="markdownIt-Anchor" href="#亲手写一个-image-demo"></a> 亲手写一个 image demo</h3><ol><li>写一个简单的 C 语言文件<code>hello.c</code></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>编译成二进制文件<code>hello</code></li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 如果安装了跳过这一步</span><br>$ yum install gcc<br>$ gcc -static hello.c -o hello<br></code></pre></td></tr></table></figure><ol start="3"><li>编写<code>Dockerfile</code>文件</li></ol><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Dockerfile"><span class="hljs-comment"># 表示没有基于任何镜像</span><br><span class="hljs-keyword">FROM</span> scratch<br><span class="hljs-comment"># 将宿主机(这里是虚机)当前路径的hello文件添加到image文件系统的根路径</span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> hello /</span><br><span class="hljs-comment"># 运行image中的hello文件(必须是double quote)</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;/hello&quot;</span>]</span><br></code></pre></td></tr></table></figure><ol start="4"><li>生成 image</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># denis/hello为image名称, .为在当前路径查找hello</span><br>$ docker build -t denis/hello .<br><span class="hljs-comment"># 查看当前所有的image</span><br>$ docker image <span class="hljs-built_in">ls</span><br>REPOSITORY          TAG       IMAGE ID       CREATED         SIZE<br>denis/hello-world   latest    70714e52769a   9 seconds ago   861kB<br></code></pre></td></tr></table></figure><ol start="5"><li>运行 image</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ docker run denis/hello<br>hello world<br><span class="hljs-comment"># 查看image中包含的操作</span><br>$ docker <span class="hljs-built_in">history</span> [IMAGE ID]<br>IMAGE          CREATED          CREATED BY                                      SIZE      COMMENT<br>70714e52769a   49 seconds ago   /bin/sh -c <span class="hljs-comment">#(nop)  CMD [&quot;/hello&quot;]               0B</span><br>00ae1da5637b   3 minutes ago    /bin/sh -c <span class="hljs-comment">#(nop) ADD file:f0bbccfa3092098e8…   861kB</span><br></code></pre></td></tr></table></figure><p>对于<code>docker run</code>的 container 运行后会直接退出, 如果想进行交互可以加上标识符<code>-it</code>, 例如<code>docker run -it ubuntu:14.04</code>, 可以通过<code>docker container ls</code>查看正在运行中的 container, <code>docker container ls -a</code>查看运行结束已经退出的 container</p><h3 id="常见命令"><a class="markdownIt-Anchor" href="#常见命令"></a> 常见命令</h3><p>所有命令可以通过<code>docker --help</code>查看</p><ul><li><code>docker container ls</code>: 查看正在运行中的 container, 简写<code>docker ps</code></li><li><code>docker container ls -a</code>: 查看已退出的 container, 简写<code>docker ps -a</code></li><li><code>docker image ls</code>: 查看所有镜像, 简写<code>docker images</code></li><li><code>docker rm [CONTAINER ID]</code>: 删除 container</li><li><code>docker rmi [IMAGE ID]</code>: 删除 image, 需要先把 image 对应的 container 都删除</li><li><code>docker rm $(docker container ls -f &quot;status=exited&quot; -q)</code>: 删除符合过滤条件的 container, <code>-f --filter</code>filter output based on conditions provided, <code>-q --quiet</code>only display container IDs</li></ul><h2 id="dockerfile"><a class="markdownIt-Anchor" href="#dockerfile"></a> Dockerfile</h2><p>生成 image 的描述文件</p><h3 id="常见指令"><a class="markdownIt-Anchor" href="#常见指令"></a> 常见指令</h3><h4 id="from"><a class="markdownIt-Anchor" href="#from"></a> FROM</h4><p>基于的镜像, <code>FROM scratch</code>没有基于的镜像, <code>FROM centos</code>基于最新发行版的 centos 镜像</p><h4 id="run"><a class="markdownIt-Anchor" href="#run"></a> RUN</h4><p>在 docker build 构建镜像的过程中执行, 每多一个<code>RUN</code>,image 就会多一层 layer</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> centos<br><span class="hljs-keyword">RUN</span><span class="language-bash"> yum install -y vim</span><br></code></pre></td></tr></table></figure><h4 id="workdir"><a class="markdownIt-Anchor" href="#workdir"></a> WORKDIR</h4><p>类似 linux 中的 cd, 对于不存在的目录会自动创建, 不同于 image 的 layer 都是新建的一层, workdir 创建的目录会一直存在. <strong>使用 WORKDIR, 不要使用 RUN cd</strong> <strong>使用绝对路径</strong></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /test</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /foo</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">pwd</span></span><br><span class="hljs-comment"># 此时会输出 /test/foo</span><br></code></pre></td></tr></table></figure><h4 id="add-or-copy"><a class="markdownIt-Anchor" href="#add-or-copy"></a> ADD or COPY</h4><p>将上下文目录资源复制到容器中的指定位置, ADD 和 COPY 的功能差不多, 官方推荐使用 COPY. 因为 ADD 复制压缩文件时会同时将文件解压缩.<br />对于远程资源还是要使用 curl 或者 wget</p><h4 id="env"><a class="markdownIt-Anchor" href="#env"></a> ENV</h4><p>定义常量, 推荐经常使用</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">ENV</span> NODE_VERSION <span class="hljs-number">7.2</span>.<span class="hljs-number">0</span><br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> curl -SLO <span class="hljs-string">&quot;https://nodejs.org/dist/v<span class="hljs-variable">$NODE_VERSION</span>/node-v<span class="hljs-variable">$NODE_VERSION</span>-linux-x64.tar.xz&quot;</span> \</span><br><span class="language-bash">  &amp;&amp; curl -SLO <span class="hljs-string">&quot;https://nodejs.org/dist/v<span class="hljs-variable">$NODE_VERSION</span>/SHASUMS256.txt.asc&quot;</span></span><br></code></pre></td></tr></table></figure><h4 id="cmd"><a class="markdownIt-Anchor" href="#cmd"></a> CMD</h4><p>和 RUN 指令类似, RUN 在 docker build 时运行, CMD 在 docker run 时运行. <strong>为启动的容器指定默认要运行的程序</strong>, CMD 指令会被 docker run 命令行参数中指定的指令所替换, 如果 dockerfile 中存在多条 CMD 指令时, 只有最后一条会被执行</p><h4 id="entrypoint"><a class="markdownIt-Anchor" href="#entrypoint"></a> ENTRYPOINT</h4><p>和 CMD 类似, 但是不会被 docker run 命令行指定的指令所替换, 而且这些命令行参数会被当成参数传给 ENTRYPOINT, 如果运行 docker run 时使用了<code>--entrypoint</code>, 将覆盖 CMD 指令, 如果 dockerfile 中存在多条 ENTRYPOINT 指令, 只有最后一条会被执行</p><p>更多的指令参考<a href="https://docs.docker.com/engine/reference/builder/">官网 dockerfile</a></p><h2 id="发布-image"><a class="markdownIt-Anchor" href="#发布-image"></a> 发布 image</h2><ol><li>首先要在 docker hub 上注册账号, 注册成功后记住自己的用户名</li><li><code>docker login</code>命令行中登录</li><li><code>docker tag [IMAGE NAME] 你的用户名/image名称</code>: 给当前需要上传的镜像打上标签, 这里必须用自己的用户名否则会提示 permission denied</li><li><code>docker images</code>就可以看到名为<code>你的用户名/image名称</code>的镜像了</li><li><code>docker push 你的用户名/image名称</code>上传到 docker hub</li></ol><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p><a href="https://www.jianshu.com/p/7636ab2a29d6">可能是把 docker 奖的最清楚的一篇文章了</a><br /><a href="https://juejin.cn/post/6844903815729119245#comment">30 分钟快速入门 Docker 教程</a><br /><a href="https://www.zhihu.com/question/28300645">通俗理解 Docker 是什么</a><br /><a href="https://ithelp.ithome.com.tw/articles/10191139">Day6：把 Docker Image Push 到 Docker Hub</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《HTML5 Canvas核心技术图形、动画与游戏开发》笔记</title>
    <link href="/2021/06/01/2021-06-01-canvas-learning-note/"/>
    <url>/2021/06/01/2021-06-01-canvas-learning-note/</url>
    
    <content type="html"><![CDATA[<ul><li>Chapter1</li></ul><ol><li>默认情况下, canvas 元素的背景色与其父元素的背景色一致.</li><li>默认 canvas 大小是 300*150, 坐标左上角(0,0), 向 x 轴正方向, y 轴负方向衍生(坐标是正的), canvas 存在两套尺寸, 一个是元素本身的大小, 一个是元素绘图区域的大小, 如果是修改 canvas 的属性 width/heigth, 则两者都发生改变,; 如果是修改 canvas 的 css 属性 width/height, 则只有元素本身大小发生改变, 绘图区域仍然为 300*150, 而为了适应元素本身大小, 绘图区域会进行等比例的放大/缩放.</li><li>可以通过<code>document.getElementById</code>获取 canvas 引用, canvas 的属性 width, height(不能加 px), 方法: <code>getContext</code>获得 canvas 的绘图环境变量, <code>toDataUrl(type, quatity)</code>和<code>toBlob(type, quatity)</code>用于生成 base64 的 dataurl 和 canvas 图像文件的 bloburl, <code>type</code>默认为<code>image/png</code>, <code>quatity</code>表示生成图片的质量, 区间为<code>0.0~1.0</code></li><li><code>CanvasRnderingContext2D.save()</code> 和 <code>CanvasRenderingContext2D.restore()</code></li><li>canvas 绑定鼠标事件, <code>canvas.addEventListener('mousedown', callback)</code>, 事件返回的坐标是相对浏览器窗口, 需要转换成 canvas 内部坐标. <code>canvas.width/bbox.width</code>用于处理 canvas 尺寸和绘图尺寸不一致时的计算.</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">windowToCanvas</span>(<span class="hljs-params">canvas, x, y</span>) &#123;<br>  <span class="hljs-keyword">const</span> bbox = canvas.<span class="hljs-title function_">getBoundingClientRect</span>();<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">x</span>: x - canvas.<span class="hljs-property">width</span> / bbox.<span class="hljs-property">width</span>,<br>    <span class="hljs-attr">y</span>: y - canvas.<span class="hljs-property">height</span> / canvas.<span class="hljs-property">height</span><br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="6"><li>canvas 是一个<strong>不可获取焦点</strong>的标签, 所以如果要绑定键盘事件, 绑定在 document 或 window 上</li><li>canvas 对象都是位图, 像<code>context.getImageData(canvas, 0,0)</code>获得的也都是位图的点阵数组数据, 不能直接给 img 使用, 需要使用<code>canvas.toDataURL()</code>或<code>canvas.toBlob()</code></li><li>canvas 角度, 以及 Math 的三角函数参数都是弧度单位</li></ol><ul><li>Chapter2</li></ul><ol><li>绘制简单矩形 <a href="https://codepen.io/healms/pen/poeweor">在线查看</a> <code>clearRect</code>清除指定区域内绘图内容, <code>strokeRect</code>对矩形描边, 搭配<code>lineWidth</code>边距宽度, <code>lineJoin</code>圆角等属性绘制, <code>strokeStyle</code>秒变颜色, <code>fillRect</code>填充矩形, <code>fillStyle</code>填充颜色, 三个方法参数都是<code>(横坐标, 纵坐标, 宽, 高)</code></li><li>上述方法也可以通过<code>rect()</code>+<code>stroke()/fill()</code>实现</li><li>通过<code>context.createRadiaGradient()</code>,<code>context.createLineGradient()</code>创建渐变色, 可以作为颜色赋值给<code>fillStyle</code>等</li><li>canvas 也可以通过图案进行 stroke 描边, 这里团可以是以下三种: image 元素, canvas 元素, video 元素. 使用<code>context.createPattern(image, repeat)</code>, 绘制图片背景<a href="https://codepen.io/healms/pen/GRWEGmM">在线查看</a></li><li>阴影 <code>shadowColor</code>颜色(默认#000000), <code>shadowOffsetX</code>x 轴偏移量(默认 0), <code>shadowOffsetY</code>y 轴偏移量(默认 0), <code>shadowBlur</code>高斯模糊(默认 0.0, double 值)</li><li>canvas 绘制的路径无论是开放还是闭合的都是可以进行 fill 填充的, 开放的路径浏览器会默认将起始和终点相连进行填充, stroke 则只会描边路径</li><li><code>beginPath()</code>和<code>closePath</code>, 两者并没有什么关系, <code>beginPath()</code>用于重启一条路径, 否则一直都是最开始的一条路径, <code>closePath()</code>是闭合路径, 并不是结束路径! 参考<a href="https://blog.csdn.net/jearbilove/article/details/38340141">beginPath 的重要性</a></li><li><code>arc</code>为在<strong>当前路径</strong>中增加一段表示圆弧或者圆形的子路径, 与<code>rect</code>总是逆时针绘制不同, <code>arc</code>可以选择绘制的方向(最后一个参数 true 顺时针, false 逆时针), 如果绘制时存在其他的子路径, 会将其他子路径的结束和<code>arc</code>的开头连接</li><li><code>fill(fillRule)</code>可以选择填充规则, <code>nonzero(非零环绕原则)</code>和<code>evenodd(奇偶环绕原则)</code>, 默认填充遵循<strong>非零环绕原则</strong>. <a href="https://codesandbox.io/s/dreamy-faraday-tbd32">fill&amp;stroke</a> <a href="https://codesandbox.io/s/cool-lake-n3nvo">在线查看 fill 规则</a></li><li>如果需要逆时针的矩形可以使用<code>lineTo</code></li><li>1px lineWidth 绘制成 2px lineWidth 问题</li><li><a href="https://codesandbox.io/s/quizzical-liskov-iklz5">橡皮筋案例在线演示</a> <a href="https://codesandbox.io/s/vigorous-banzai-5vjwm">画圆案例在线演示</a> 鼠标拖动过程中一直做三件事 1. 恢复 mousedown 绘制表面 2. 更新 rubberband 3. 绘制起点到当前鼠标的线</li><li>虚线, <code>setLineDash([])</code>设置虚线, <code>lineDashOffset</code>属性设置虚线偏移量, 蚂蚁线</li><li><code>lineCap</code>线段端点如何绘制,(butt, round, squre), 默认 butt; <code>lineJoin</code>线段连接点如何绘制,(round, bevel, miter), 默认 bevel, <code>miterLimit</code>, 斜接线长度与 1/2 线宽的比值, 如果斜接线长度超过这个值, 就会以 bevel 绘制线段连接点</li><li><a href="https://codesandbox.io/s/peaceful-dawn-45rnp">仪表盘案例在线演示</a></li><li>贝塞尔曲线, <code>quadraticCurveTo(x1, y1, x2, y2)</code>二次贝塞尔曲线存在三个点, 起始点 D0, 终点 D2, 以及控制点 D1, 参数为 D1, D2, D0 即使当前子路径的终点, 常常是<code>moveTo</code>的那个点, <code>bezierCurveTo(x1, y1, x2, y2, x3, y3)</code>三次贝塞尔曲线, 前两个是控制点, 最后一个是终点</li><li><a href="https://codesandbox.io/s/sharp-cherry-do3tr">多边形案例在线演示</a></li><li><a href="https://codesandbox.io/s/unruffled-darkness-8lpb9">多边形可拖拽案例在线演示</a><br />拖拽实现是通过记录当前画布所有多边形数据, 并且计算拖拽的多边形数据, 清空画布重新绘制实现, 判断当前拖拽的多边形通过遍历所有多边形并重新<code>beginPath</code>然后绘制路径, 再通过<code>isPointInPath()</code>判断当前鼠标坐标是否在路径中</li><li><a href="https://codesandbox.io/s/zealous-chebyshev-iz0ro">贝塞尔曲线可拖拽案例在线演示</a></li><li>将坐标系平移到给定 X,Y 坐标处<code>translate(x, y)</code>, 按照给定角度旋转坐标系<code>rotate(angleInRadians)</code>, 在 X 与 Y 方向上分别按照给定的数值缩放坐标系<code>scale(x, y)</code>, 需要注意的是这里都是对坐标系进行处理, <code>transform(sx, rx, ry, sx, tx, ty)</code>, 参数及默认值为: 水平缩放(1), 水平倾斜(0), 垂直倾斜(0), 垂直缩放(1), 水平移动(0), 垂直移动(0). 可以通过改变这些参数实现上述三个函数, 对于二维操作, 线性代数中都可以通过<code>x' = ax+cy+e; y' = bx+dy+f;</code>表示变化后的坐标 <a href="https://www.zhangxinxu.com/wordpress/2012/06/css3-transform-matrix-%e7%9f%a9%e9%98%b5/">具体参考张大神博客</a></li><li><code>scale(-1)</code> 参数如果是负数则是中心对称后进行缩放</li><li><code>transform</code>, <code>setTransform</code>可以实现旋转平移缩放不能实现的效果例如错切, 缺点是不太直观.</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>canvas</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webpack学习笔记</title>
    <link href="/2021/05/19/2021-05-19-Webpack-learning-note/"/>
    <url>/2021/05/19/2021-05-19-Webpack-learning-note/</url>
    
    <content type="html"><![CDATA[<blockquote><p>内卷, 内卷害了所有人</p></blockquote><p><strong>2021-06-06 updated</strong>: 更多配置案例可以参考<a href="https://github.com/webpack/webpack/tree/master/examples">官方例子</a></p><p>对 webpack 的配置做个笔记,后续不定期补充, 也会补充的 webpack 源码的学习</p><h2 id="mode"><a class="markdownIt-Anchor" href="#mode"></a> mode</h2><p>mode 分为<code>development</code>,<code>production</code>,<code>none</code>, 不配置默认为<code>production</code>, 构建时抛出警告 ⚠️</p><h2 id="performance"><a class="markdownIt-Anchor" href="#performance"></a> performance</h2><p>webpack 会抛出必要的影响性能的警告, 可以通过置为<code>false</code>屏蔽警告</p><h2 id="entry"><a class="markdownIt-Anchor" href="#entry"></a> entry</h2><p>可以是单文件入口和多文件, 有多少入口文件就会构建出多少文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 单文件入口, 未指定name时name为main</span><br><span class="hljs-attr">entry</span>: <span class="hljs-string">&quot;/your/entry/file/path&quot;</span>,<br><span class="hljs-comment">// 多文件入口</span><br><span class="hljs-attr">entry</span>: &#123;<br>  <span class="hljs-string">&quot;main&quot;</span>: <span class="hljs-string">&quot;/your/entry/file/path1&quot;</span>,<br>  <span class="hljs-string">&quot;app&quot;</span>: <span class="hljs-string">&quot;/your/entry/file/path2&quot;</span>,<br>&#125;,<br><span class="hljs-comment">// 数组形式, 相当于在入口文件最前面import @babel/polyfill, 用于引入一些必要的包</span><br><span class="hljs-attr">entry</span>: [<span class="hljs-string">&quot;@babel/polyfill&quot;</span>, <span class="hljs-string">&quot;/your/entry/file/path&quot;</span>]<br></code></pre></td></tr></table></figure><h2 id="output"><a class="markdownIt-Anchor" href="#output"></a> output</h2><p><code>filename</code> 中 name 为入口文件的<code>key</code>, 字符串形式时 name 为 main, hash,chunkhash,contenthash 区别见<a href="#hash,chunkhash,contenthash">hash, chunkhash, contenthash 区别</a><br /><code>chunkFilename</code>针对的是那些间接引入的文件,即非 entry 指定的文件, 命名以<code>chunkFilename</code>为准, <code>[name]</code>为<code>splitChunks</code>归类的文件名,<br /><code>publicPath</code>html 引入 output 的 js 是的前缀路径</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">output</span>: &#123;<br>  <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;[name].[hash:8].js&#x27;</span>,<br>  <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/your/output/directory&#x27;</span>,<br>  <span class="hljs-attr">chunkFilename</span>: <span class="hljs-string">&#x27;[name].chunk.js&#x27;</span>,<br>  <span class="hljs-attr">publicPath</span>: <span class="hljs-string">&#x27;/assets&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="loader"><a class="markdownIt-Anchor" href="#loader"></a> loader</h2><p>webpack 默认只支持解析 js 和 json 文件, loader 用于解析不同后缀名的文件, 对于同一种文件类型使用多个 loader 时遵从从数组右向左解析原则, 写在<code>module.rules</code>中, 这里看几个常用的 loader</p><h3 id="babel"><a class="markdownIt-Anchor" href="#babel"></a> babel</h3><p>用于将 ES6+新语法转化成 ES5 语法, 需要配合<code>@babel/preset-env</code>和<code>@babel/core</code>使用. 对于 Promise, Map,Set 等新的 api 还需安装<code>@babel/polyfill</code>, 然后在入口文件开始引入, 也可以通过 entry 数组形式引入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.js(x)$/</span>,<br>  <span class="hljs-attr">use</span>: [<br>    &#123;<br>      <span class="hljs-attr">loader</span>: <span class="hljs-string">&#x27;babel-loader&#x27;</span>,<br>      <span class="hljs-attr">options</span>: &#123;<br>        <span class="hljs-attr">presets</span>: [<span class="hljs-string">&#x27;@babel/preset-env&#x27;</span>]<br>      &#125;<br>    &#125;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="css"><a class="markdownIt-Anchor" href="#css"></a> css</h3><p>一般搭配这些 loader 一起使用,</p><ol><li><code>sass-loader</code>(optional)解析 sass 成 css,相应的有(‘less-loader’, ‘stylus-loader’),</li><li><code>postcss-loader</code>为 css 加上产商前缀, 增强兼容性,</li><li><code>css-loader</code>解析 css,</li><li>还有三个根据环境及框架选一个使用, <code>style-loader</code>开发环境下使用, 将 css 通过<code>&lt;style&gt;</code>标签的方式引入 html, <code>vue-style-loader</code>解析 vue 模板中的 css, <code>MiniCssExtractPlugin.loader</code>生产环境下使用, 会将 css 文件单独打包,防止 html 文件过大</li></ol><p><code>postcss-loader</code>需要配合<code>autoprefixer</code>使用, 在当前项目根目录下新建<code>postcss.config.js</code>引入<code>autoprefixer</code>, 同时在<code>package.json</code>添加<code>browserslist</code>字段指定覆盖的浏览器, 新版本不支持直接内联在 webpack.config.js 中的写法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// postcss.config.js</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">plugins</span>: [<span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;autoprefixer&#x27;</span>)]<br>&#125;;<br><br><span class="hljs-comment">// package.json</span><br><span class="hljs-string">&quot;browserslist&quot;</span>: [<br>  <span class="hljs-string">&quot;defaults&quot;</span>,<br>  <span class="hljs-string">&quot;not ie &lt; 11&quot;</span>,<br>  <span class="hljs-string">&quot;last 2 versions&quot;</span>,<br>  <span class="hljs-string">&quot;&gt; 1%&quot;</span>,<br>  <span class="hljs-string">&quot;iOS 7&quot;</span>,<br>  <span class="hljs-string">&quot;last 3 iOS versions&quot;</span><br>]<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.(s)?css$/</span>,<br>  <span class="hljs-attr">use</span>: [process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> === <span class="hljs-string">&#x27;production&#x27;</span> ? <span class="hljs-title class_">MinCssExtractPlugin</span>.<span class="hljs-property">loader</span> : <span class="hljs-string">&#x27;style-loader&#x27;</span>, <span class="hljs-string">&#x27;css-loade&#x27;</span>, <span class="hljs-string">&#x27;postcss-loader&#x27;</span>, <span class="hljs-string">&#x27;sass-loader&#x27;</span>]<br>&#125;<br></code></pre></td></tr></table></figure><p>如果要使用 <code>MinCssExtractPlugin</code> 需要下载插件并配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">MiniCssExtractPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;mini-css-extract-plugin&quot;</span>);<br><br><span class="hljs-comment">// ...省略上面的配置</span><br><span class="hljs-attr">plugin</span>: &#123;<br>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">MiniCssExtractPlugin</span>(&#123;<br>    <span class="hljs-attr">filename</span>: <span class="hljs-string">&quot;[name].[hash].css&quot;</span>,<br>    <span class="hljs-attr">chunkFilename</span>: <span class="hljs-string">&quot;[id].css&quot;</span>,<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="图片多媒体"><a class="markdownIt-Anchor" href="#图片多媒体"></a> 图片&amp;多媒体</h3><p>使用<code>url-loader</code>和<code>file-loader</code>, 两个 loader 区别在于<code>url-loader</code>在文件大小未超过设置的阈值时会将文件转化成 base64 编码, 可以使用<code>url-loader</code>, 超过阈值再使用<code>file-loader</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.(jpe?g|png|gif)$/i</span>,<br>  <span class="hljs-attr">use</span>: [<br>    &#123;<br>      <span class="hljs-attr">loader</span>: <span class="hljs-string">&#x27;url-loader&#x27;</span>,<br>      <span class="hljs-attr">options</span>: &#123;<br>        <span class="hljs-attr">limit</span>: <span class="hljs-number">1024</span> * <span class="hljs-number">10</span>,<br>        <span class="hljs-attr">fallback</span>: &#123;<br>          <span class="hljs-attr">loader</span>: <span class="hljs-string">&#x27;file-loader&#x27;</span>,<br>          <span class="hljs-attr">options</span>: &#123;<br>            <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;img/[name].[hash:8].[ext]&#x27;</span><br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="vue"><a class="markdownIt-Anchor" href="#vue"></a> vue</h3><p><code>vue-loader</code>专门用于处理 vue 文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.vue$/</span>;<br>  <span class="hljs-attr">use</span>: [<span class="hljs-string">&quot;vue-loader&quot;</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="typescript"><a class="markdownIt-Anchor" href="#typescript"></a> typescript</h3><p><code>ts-loader</code>专门用于处理 typescript 文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.tsx?$/</span>,<br>  <span class="hljs-attr">use</span>: [<span class="hljs-string">&#x27;ts-loader&#x27;</span>]<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="optimization"><a class="markdownIt-Anchor" href="#optimization"></a> optimization</h2><p>这个字段可以配置一个对象, 这里介绍几个重要属性(后续补充)</p><h3 id="usedexports"><a class="markdownIt-Anchor" href="#usedexports"></a> usedExports</h3><p>开启 tree shaking, 去除未被 import 的逻辑.<br />对于例如.css 这类文件, 不存在具体 import 内容, webpack 默认也会把它 shake 掉, 需要配合<code>package.json</code>配置的<code>sideEffects</code>使用, <code>sideEffects</code>维护一个数组告诉 webpack 不要对其中的文件进行 shake<br /><strong>在开发环境下(mode: ‘development’)下, 即使开启了 tree shaking</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// webpack.config.js</span><br><span class="hljs-attr">optimization</span>: &#123;<br>  <span class="hljs-attr">usedExports</span>: <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-comment">// package.json</span><br>&#123;<br>  <span class="hljs-string">&quot;sideEffects&quot;</span>: [<span class="hljs-string">&quot;*.css&quot;</span>]<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="splitchunks"><a class="markdownIt-Anchor" href="#splitchunks"></a> splitChunks</h3><ul><li>type: <code>boolean</code></li></ul><p>开启 code splitting 代码分隔, 设想以下场景, 文件中引入 lodash(假设 1MB), 业务逻辑(假设 1MB), 如果不进行代码分隔, 每回业务逻辑发生改动都会构建出 2MB 的文件, 用户每次请求都要请求 2MB, 但实际上 lodash 逻辑并没有发生改变, 这就产生了不必要的开销, 所以可以通过代码分隔将文件进行拆分为两个文件(库文件+业务逻辑文件)<br /><em>tips:</em><br /><strong>魔法注释</strong>: 异步 import 是可使用, 可以设定 preload/prefetch, chunkname 等配置, 参考<a href="https://medium.com/the-song-of-silence/%E4%BD%BF%E7%94%A8-webpack-%E4%BB%A3%E7%A0%81%E5%88%86%E5%89%B2-%E5%92%8C-%E9%AD%94%E6%9C%AF%E6%B3%A8%E9%87%8A-%E6%8F%90%E5%8D%87%E5%BA%94%E7%94%A8%E6%80%A7%E8%83%BD-f9e45aeb08c9">魔法注释</a></p><p>下面介绍一些重要属性(待添加)</p><h4 id="chunks"><a class="markdownIt-Anchor" href="#chunks"></a> chunks</h4><ul><li>value: ‘all’ | ‘async’ | false<br /><code>all</code>对同步异步的 import 都进行代码分隔, <code>async</code>则只对异步 import 进行代码分隔.<br />但是如果<code>cacheGroup</code>组中未匹配且<code>default</code>为<code>false</code>, 则 <code>chunks</code>不会对该文件进行代码分隔</li></ul><h4 id="minsize"><a class="markdownIt-Anchor" href="#minsize"></a> minSize</h4><ul><li>value: number<br />进行代码分隔的 import 包大小, 单位 Kb</li></ul><h4 id="maxsize"><a class="markdownIt-Anchor" href="#maxsize"></a> maxSize</h4><ul><li>value: number<br />一般不配, 是对代码分隔的包进行二次拆分的阈值(如果可以), 单位 Kb</li></ul><h4 id="minchunks"><a class="markdownIt-Anchor" href="#minchunks"></a> minChunks</h4><ul><li>value: number<br />最小引入次数, 即 如果 lodash 制备引入了一次则不进行代码分隔, 2 次+就会进行代码分隔</li></ul><h4 id="maxasyncrequest"><a class="markdownIt-Anchor" href="#maxasyncrequest"></a> maxAsyncRequest</h4><ul><li>value: number<br />一般也不配, 最多对 X 个 import 包进行代码分隔, 假设引入了 10 个包, 只会对前 5 个包进行代码分隔</li></ul><h4 id="automaticnamedelimiter"><a class="markdownIt-Anchor" href="#automaticnamedelimiter"></a> automaticNameDelimiter</h4><ul><li>value: string<br /><strong>当未指定<code>cacheGroup</code>组中<code>filename</code>时</strong>作为代码分隔生成文件名中间的连接符, 文件名命名规范为<code>$&#123;cacheGroups匹配组的key(未匹配默认为default)&#125;$&#123;automaticNameDelimiter连接符(默认为~)&#125;$&#123;当前文件所在entry的key&#125;.js</code>(疑惑: 如果相同的库被不同 entry 引用?)</li></ul><h4 id="cachegroup"><a class="markdownIt-Anchor" href="#cachegroup"></a> cacheGroup</h4><p><code>cacheGroup</code>的每一个属性都作为一个组, 对于每个组中<code>test</code>匹配到相同正则的 import 包会打包到相同的组.<br />对于没有匹配到的包, 默认兜底到 default 组中, 不配置<code>cacheGroup</code>时默认会存在一个匹配 node_modules 的 <code>vendors</code> 组.<br /><code>reuseExistingChunk</code>则是配置是否服用之前已经缓存的相同包内容.<br />对于匹配到多个组的包, 会根据 <code>priority</code>优先级大小分到优先级最高的组.<br /><strong>需要注意的是, cacheGroups 中配置的字段优先级大于外层 splitChunks 相同字段的值~</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">cacheGroups</span>: &#123;<br>  <span class="hljs-attr">defaultVendors</span>: &#123;<br>    <span class="hljs-attr">test</span>: <span class="hljs-regexp">/[\\/]node_modules[\\/]/</span>,<br>    <span class="hljs-attr">priority</span>: -<span class="hljs-number">10</span>,<br>    <span class="hljs-attr">reuseExistingChunk</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;vendors.js&#x27;</span><br>  &#125;,<br>  <span class="hljs-attr">default</span>: &#123;<br>    <span class="hljs-attr">priority</span>: -<span class="hljs-number">20</span>,<br>    <span class="hljs-attr">reuseExistingChunk</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;common.js&#x27;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="resolve"><a class="markdownIt-Anchor" href="#resolve"></a> resolve</h2><h3 id="alias"><a class="markdownIt-Anchor" href="#alias"></a> alias</h3><p>import from 路径的别名, 例如<code>import Cmp from '@/components/home.vue</code>会被解析为<code>import Cmp from '/your/project/root/path/src/components/home.vue</code>.<br />如果项目中使用了 typescript, 要使用 alias 别名, 需要同时在<code>webpack配置文件</code>和<code>tsconfig.json</code>配置别名, 旨在<code>tsconfig.json</code>配置是不生效的.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">alias</span>: &#123;<br>  <span class="hljs-attr">vue$</span>: <span class="hljs-string">&#x27;vue/dist/vue.runtime.esm.js&#x27;</span>,<br>  <span class="hljs-string">&#x27;@&#x27;</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;../src&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="extensions"><a class="markdownIt-Anchor" href="#extensions"></a> extensions</h3><p>缺省后缀, import from 路径缺少后缀时, webpack 会在该目录下从左向右寻找符合的文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">extensions</span>: [<span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-string">&#x27;.js&#x27;</span>, <span class="hljs-string">&#x27;.json&#x27;</span>, <span class="hljs-string">&#x27;.vue&#x27;</span>],<br></code></pre></td></tr></table></figure><h3 id="mainfiles"><a class="markdownIt-Anchor" href="#mainfiles"></a> mainFiles</h3><p>缺省文件名, 这回文件都不用写了… import from 路径最后一级为目录时, webpack 会寻找目录下和 <code>mainFiles</code>匹配的文件名</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">mainFiles</span>: [<span class="hljs-string">&quot;index&quot;</span>, <span class="hljs-string">&quot;main&quot;</span>];<br></code></pre></td></tr></table></figure><h3 id="devserver"><a class="markdownIt-Anchor" href="#devserver"></a> devServer</h3><p>暂时用的不多, 可以参考<a href="https://webpack.docschina.org/configuration/dev-server/#devservercontentbase">webpack 开发服务器 devServer</a></p><h2 id="plugin"><a class="markdownIt-Anchor" href="#plugin"></a> Plugin</h2><h3 id="htmlwebpackplugin"><a class="markdownIt-Anchor" href="#htmlwebpackplugin"></a> HtmlWebpackPlugin</h3><p>入口文件要挂载的 html 路径, 配置<code>new HtmlWebpackPlugin</code>默认会将 entry 所有入口文件都引入 html, 生成单页面, 如果要生成多页面只需配置多个<code>new HtmlWebpackPlugin</code>并且配置对应的 chunk 即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// ...省略其他配置</span><br>[<br>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>(&#123;<br>    <span class="hljs-attr">template</span>: <span class="hljs-string">&quot;/your/template/html/file/path&quot;</span>,<br>    <span class="hljs-attr">filename</span>: <span class="hljs-string">&quot;index.html&quot;</span>,<br>    <span class="hljs-comment">// 忽略此项则全部引入</span><br>    <span class="hljs-attr">chunks</span>: [<span class="hljs-string">&quot;app&quot;</span>],<br>  &#125;),<br>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>(&#123;<br>    <span class="hljs-attr">template</span>: <span class="hljs-string">&quot;your/template/html/file/path&quot;</span>,<br>    <span class="hljs-attr">filename</span>: <span class="hljs-string">&quot;main.html&quot;</span>,<br>    <span class="hljs-attr">chunks</span>: [<span class="hljs-string">&quot;main&quot;</span>],<br>  &#125;),<br>];<br></code></pre></td></tr></table></figure><h3 id="cleanwebpackplugin"><a class="markdownIt-Anchor" href="#cleanwebpackplugin"></a> CleanWebpackPlugin</h3><p>每次构建时先清空 output 目录上次构建的产物, 保证 output 目录构建产物都是最新的<br /><code>const &#123;CleanWebpackPlugin&#125; = require('clean-webpack-plugin')</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">CleanWebpackPlugin</span>();<br></code></pre></td></tr></table></figure><h3 id="minicssextractplugin"><a class="markdownIt-Anchor" href="#minicssextractplugin"></a> MiniCssExtractPlugin</h3><p>上面已经描述过了, 用于生产环境下剥离 css 文件, 降低耦合<br /><code>const MiniCssExtractPlugin = require('mini-css-extract-plugin')</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">MiniCssExtractPlugin</span>(&#123;<br>  <span class="hljs-attr">filename</span>: <span class="hljs-string">&quot;[name].[hash].css&quot;</span>, <span class="hljs-comment">// 有指定entry的output文件名</span><br>  <span class="hljs-attr">chunkFilename</span>: <span class="hljs-string">&quot;[id].css&quot;</span>, <span class="hljs-comment">// 未指定entry的output文件名</span><br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="vueloaderplugin"><a class="markdownIt-Anchor" href="#vueloaderplugin"></a> VueLoaderPlugin</h3><p><code>const &#123;VueLoaderPlugin&#125; = require('vue-loader')</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">VueLoaderPlugin</span>();<br></code></pre></td></tr></table></figure><h3 id="hotmodulereplacementplugin"><a class="markdownIt-Anchor" href="#hotmodulereplacementplugin"></a> HotModuleReplacementPlugin</h3><p>内置插件, 热更新</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> webpack.<span class="hljs-title class_">HotModuleReplacementPlugin</span>();<br></code></pre></td></tr></table></figure><h3 id="provideplugin"><a class="markdownIt-Anchor" href="#provideplugin"></a> ProvidePlugin</h3><p>当在文件中使用了插件中配置的库或者库函数时, webpack 会自动引入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> webpack.<span class="hljs-title class_">ProvidePlugin</span>(&#123;<br>  <span class="hljs-comment">// 自动引入jquery</span><br>  <span class="hljs-attr">$</span>: <span class="hljs-string">&quot;jquery&quot;</span>,<br>  <span class="hljs-comment">// 自动引入lodash库中join方法</span><br>  <span class="hljs-attr">_join</span>: [<span class="hljs-string">&quot;lodash&quot;</span>, <span class="hljs-string">&quot;join&quot;</span>],<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="dllreferenceplugin-dllplugin已被-vue-和-react-废弃"><a class="markdownIt-Anchor" href="#dllreferenceplugin-dllplugin已被-vue-和-react-废弃"></a> DllReferencePlugin &amp; DllPlugin(已被 vue 和 react 废弃)</h3><p><strong>虽然被废弃了, 但还是写一下 orz, 推荐使用 HardSourceWebpackPlugin</strong></p><p>上面说到 code splitting 可以通过<code>splitChunks</code>实现, 但对于库文件, 大部分时候是 不会更改的, 而 webpack 每次打包时都会根据<code>splitChunks</code>配置打包库文件, 这其实是没有必要的, 所以可以单独配置<code>webpack.dll.js</code>文件, 用于打包库文件, 这样第一次打包后后续打包就不会再次打包库文件了</p><p><strong>DllPlugin 作用于 dll 文件</strong>, 用于生成 manifest 文件作为打包前后库文件的映射, 后续打包时 webpack 检测<br /><code>webpack.dll.js</code>其实就是一个 webpack 配置文件, 只不过针对的对象不同. 这里给出一个<code>webpack.dll.js</code>的配置 demo.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">mode</span>: <span class="hljs-string">&quot;production&quot;</span>,<br>  <span class="hljs-comment">// entry为需要打包的库文件名</span><br>  <span class="hljs-attr">entry</span>: [<span class="hljs-string">&quot;react&quot;</span>, <span class="hljs-string">&quot;react-dom&quot;</span>, <span class="hljs-string">&quot;lodash&quot;</span>],<br>  <span class="hljs-comment">// output的library是打包后库的名称</span><br>  <span class="hljs-attr">output</span>: &#123;<br>    <span class="hljs-attr">filename</span>: <span class="hljs-string">&quot;[name].dll.js&quot;</span>,<br>    <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&quot;./dll&quot;</span>),<br>    <span class="hljs-attr">library</span>: <span class="hljs-string">&quot;[name]&quot;</span>,<br>  &#125;,<br>  <span class="hljs-attr">plugins</span>: [<br>    <span class="hljs-keyword">new</span> webpack.<span class="hljs-title class_">DllPlugin</span>(&#123;<br>      <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;[name].manifest.json&quot;</span>,<br>      <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&quot;./dll&quot;</span>),<br>    &#125;),<br>  ],<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>DllReferencePlugin 作用于 webpack.config.js</strong>, 通过比对 manifest.json 映射文件不进行打包命中的库文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> webpack.<span class="hljs-title class_">DllReferencePlugin</span>(&#123;<br>  <span class="hljs-comment">// 传入映射文件</span><br>  <span class="hljs-attr">manifest</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&quot;../dll/vendors.manifest.json&quot;</span>),<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="addassethtmlwebpackplugin"><a class="markdownIt-Anchor" href="#addassethtmlwebpackplugin"></a> AddAssetHtmlWebpackPlugin</h3><p>将资源文件插入 html 中, 作用于<code>HtmlWebpackPlugin</code>之后, 上面说的 dll 打包的库文件就可以这样引入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">AddAssetHtmlWebpackPlugin</span>(&#123;<br>  <span class="hljs-attr">filepath</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&quot;../bundle.dll.js&quot;</span>),<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="scriptexthtmlwebpackplugin"><a class="markdownIt-Anchor" href="#scriptexthtmlwebpackplugin"></a> ScriptExtHtmlWebpackPlugin</h3><p><strong>不支持 webpack5</strong>, 配合<code>html-webpack-plugin</code>使用, 支持异步加载 JavaScript 文件</p><h2 id="webpack-打包-npm-包"><a class="markdownIt-Anchor" href="#webpack-打包-npm-包"></a> webpack 打包 npm 包</h2><p>webpack 打包库文件需要在<code>output</code>额外加上<code>library</code>和<code>libraryTarget</code>属性, 并且将<code>package.json</code>的<code>main</code>入口文件修改为 webpack 输出的<code>output</code>fileanem 文件<br />一下一个简单的 npm 包的 webpack 配置, 注意以下几点:</p><ol><li><code>libraryTarget</code>表示使用的场景, <code>umd</code>表示通用版本, 可以 <code>import(esmodule)</code> 引入, 可以 <code>require(CommonJS)</code> 引入, 也可以通过 <code>&lt;script&gt;</code> 标签引入</li><li>如果要直接在 html 中通过 script 引入需要指定<code>library</code>, 比如示例中指定<code>library: 'library'</code>, webpack 就会将 export 内容绑定到<code>window.library</code>上</li><li>如果 npm 包中使用了其他的库,比如 lodash, 业务场景中也使用了 lodash, 就会打包出两份 lodash, 这不合理, 可以指定<code>externals</code>不让 webpck 打包 npm 包时打包 lodash</li><li>在 node 中导入时可能会遇到<code>self is not defined</code>报错, 需要设置<code>globalObject</code>属性</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">mode</span>: <span class="hljs-string">&quot;production&quot;</span>,<br>  <span class="hljs-attr">entry</span>: <span class="hljs-string">&quot;./src/index.js&quot;</span>,<br>  <span class="hljs-attr">output</span>: &#123;<br>    <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&quot;./dist&quot;</span>),<br>    <span class="hljs-attr">filename</span>: <span class="hljs-string">&quot;library.js&quot;</span>,<br>    <span class="hljs-attr">library</span>: <span class="hljs-string">&quot;library&quot;</span>,<br>    <span class="hljs-attr">libraryTarget</span>: <span class="hljs-string">&quot;umd&quot;</span>,<br>    <span class="hljs-attr">globalObject</span>: <span class="hljs-string">&quot;this&quot;</span>,<br>  &#125;,<br>  <span class="hljs-attr">externals</span>: [<span class="hljs-string">&quot;lodash&quot;</span>],<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="common-development-production"><a class="markdownIt-Anchor" href="#common-development-production"></a> common development production</h2><p>可以新建<code>webpack.dev.js</code>和<code>webpack.prod.js</code>分别存储开发环境和生产环境的配置, 最后通过<code>webpack.common.js</code>存储通用配置并且通过判断当前环境输出最终配置.<br />webpack 除了可以输出对象, 也可以输出函数, 参数为环境变量, 函数返回配置对象<br /><a href="https://webpack.docschina.org/api/cli/#env">env 动态配置环境</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> merge = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;webpack-merge&quot;</span>);<br><span class="hljs-comment">// 省略其他配置</span><br><span class="hljs-comment">// webpack --env.production --config webpack.config.js</span><br><span class="hljs-comment">// 此时env就存在production属性, 也可以指定production的值(--env production=xxx)</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-function">(<span class="hljs-params">env</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (env &amp;&amp; env.<span class="hljs-property">production</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">merge</span>(commonCfg, prodCfg);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">merge</span>(commonCfg, devCfg);<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="hashchunkhashcontenthash"><a class="markdownIt-Anchor" href="#hashchunkhashcontenthash"></a> hash,chunkhash,contenthash</h2><p><code>hash</code>表示整个构建产物的 hash 值, 多文件入口中即使只修改了一个文件, 另一个文件未作修改, hash 值也会发生改变, 多文件构建产物的 hash 值都是一样的</p><p><code>chunkhash</code>顾名思义,表示块的 hash 值,即单独入口文件构建产物 hash 值, 互相不影响, 但是如果一个 js 文件中引入了 css 文件, 当 css 文件发生变化时, 该 js 文件的 hash 值也会发生改变, 多文件构建产物的 hash 值不影响</p><p><code>contenthash</code>则是在<code>chunkhash</code>的基础上忽略文件中引入 css 文件产生的变化, 仅在自身内容发生变化时改变 hash 值<br />详情参考<a href="https://segmentfault.com/a/1190000020104777">segmentfault</a></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><h2 id="推荐阅读"><a class="markdownIt-Anchor" href="#推荐阅读"></a> 推荐阅读</h2><h3 id="webpack-4-和单页应用入门"><a class="markdownIt-Anchor" href="#webpack-4-和单页应用入门"></a> <a href="https://github.com/wallstreetcn/webpack-and-spa-guide">Webpack 4 和单页应用入门</a></h3><h3 id="手摸手带你用合理的姿势使用-webpack4上"><a class="markdownIt-Anchor" href="#手摸手带你用合理的姿势使用-webpack4上"></a> <a href="https://segmentfault.com/a/1190000015919863">手摸手，带你用合理的姿势使用 webpack4（上）</a></h3><h3 id="手摸手带你用合理的姿势使用-webpack4下"><a class="markdownIt-Anchor" href="#手摸手带你用合理的姿势使用-webpack4下"></a> <a href="https://juejin.cn/post/6844903661441646605">手摸手，带你用合理的姿势使用 webpack4（下）</a></h3><h3 id="你的-tree-shaking-并没什么卵用"><a class="markdownIt-Anchor" href="#你的-tree-shaking-并没什么卵用"></a> <a href="https://zhuanlan.zhihu.com/p/32831172">你的 Tree-Shaking 并没什么卵用</a></h3>]]></content>
    
    
    
    <tags>
      
      <tag>webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>购买域名及本地调试博客</title>
    <link href="/2020/03/24/2020-03-24-buy-domain/"/>
    <url>/2020/03/24/2020-03-24-buy-domain/</url>
    
    <content type="html"><![CDATA[<h1 id="背景"><a class="markdownIt-Anchor" href="#背景"></a> 背景</h1><p>事情大概是这样, 做毕设需要用到图床, 于是用了七牛云图床, 然后发现可以自定义的加速域名, 于是就打算整个域名玩玩. 然后发现不能备案, 再然后 emmm 决定曲线救国给博客安个域名.</p><h1 id="绑定域名"><a class="markdownIt-Anchor" href="#绑定域名"></a> 绑定域名</h1><h2 id="购买域名"><a class="markdownIt-Anchor" href="#购买域名"></a> 购买域名</h2><p>我是在阿里云的万网上购买的,搜索自己喜欢的域名,点击结算.<br /><img src="/img/2020-03-24-buy-domain/buy-domain-process1.png" alt="结算" /><br />如果是初次购买需要填写一下默认的个人信息模板,大概过半天阿里会审核完成,我这里已经审核完成通过了.<br /><img src="/img/2020-03-24-buy-domain/buy-domain-process2.png" alt="模板" /></p><h2 id="域名解析"><a class="markdownIt-Anchor" href="#域名解析"></a> 域名解析</h2><p>买完域名后就要把域名映射到博客的域名,我这里是映射到 <a href="http://mariana-yui.github.io">mariana-yui.github.io</a><br />点击解析<br /><img src="/img/2020-03-24-buy-domain/buy-domain-process3.png" alt="解析" /><br />点击添加记录, 记录类型选择 CNAME(域名映射域名), 然后输入自定义二级域名, 记录值输入指向的博客域名, 点击确定.<br /><img src="/img/2020-03-24-buy-domain/buy-domain-process4.png" alt="记录" /></p><h2 id="博客配置文件"><a class="markdownIt-Anchor" href="#博客配置文件"></a> 博客配置文件</h2><p>域名映射还没完, 还需要在 <a href="http://mariana-yui.github.io">mariana-yui.github.io</a> 新建<code>CNAME</code>配置文件, 添加域名 <code>blog.mariana.fun</code></p><p><img src="/img/2020-03-24-buy-domain/buy-domain-process5.png" alt="配置" /></p><p>然后在 <code>Setting</code> 中看到 <code>GitHub Pages</code> 如图说明成功了.</p><p><img src="/img/2020-03-24-buy-domain/buy-domain-process6.png" alt="git pages" /></p><p>大概还需要过个 10 来分钟就能通过自定义的域名来访问博客了~</p><p><img src="/img/2020-03-24-buy-domain/buy-domain-process7.png" alt="blog" /></p><h1 id="本地查看博客"><a class="markdownIt-Anchor" href="#本地查看博客"></a> 本地查看博客</h1><p>曾经也是本地改改 push 上去看效果不断 loop, 现在看看真是 nt 行为(笑)<br />博客是<code>Ruby</code>系<code>jekyll</code>搭建的, 所以以下操作适用于(<strong>linux 系统</strong>)<code>jekyll</code>:</p><ol><li>安装 ruby 依赖: <code>sudo apt install ruby-full ruby-bundler</code></li><li>安装 jekyll, 安装时间可能比较长: <code>sudo gem install jekyll</code></li><li>安装完成后查看是否成功: <code>jekyll -v</code></li><li>启动本地服务: <code>jekyll serve</code></li></ol><h2 id="报错解决"><a class="markdownIt-Anchor" href="#报错解决"></a> 报错解决</h2><p><strong>Q</strong>: <code>Deprecation: You appear to have pagination turned on, but you haven't included the</code>jekyll-paginate<code>gem. Ensure you have</code>plugins: [jekyll-paginate]<code>in your configuration file.</code><br /><strong>A</strong>:</p><ol><li><code>sudo gem install jekyll-paginate</code></li><li>在<code>_config.yml</code>添加:<br /><img src="/img/2020-03-24-buy-domain/solve-error.png" alt="解决报错" /></li></ol><p><strong>Q</strong>: <code>Liquid Warning: Liquid syntax error (line 38): Unexpected character &#123; in &quot;tag[1].size &gt; &#123;&#123;site.featured-condition-size&#125;&#125;&quot; in /_layouts/page.html</code><br /><strong>A</strong>: Liquid模板语法的问题,将<code>tag[1].size &gt; &#123;&#123;site.featured-condition-size&#125;&#125;</code> 修改为 <code>tag[1].size &gt; site.featured-condition-size</code>就ok了</p><p>然后就正常啦~<br /><img src="/img/2020-03-24-buy-domain/buy-domain-process8.png" alt="blog" /></p><h1 id="reference"><a class="markdownIt-Anchor" href="#reference"></a> reference</h1><p><a href="https://blog.csdn.net/Maple_ROSI/article/details/79629531">域名绑定博客</a></p><p><a href="https://blog.csdn.net/yaakire/article/details/78932528?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task">jekyll 本地调试博客</a></p><p><a href="https://github.com/ValchanOficial/valchan/issues/1">解决报错1</a></p><p><a href="https://github.com/Huxpro/huxpro.github.io/issues/105">解决报错2</a></p>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>fetch获取线上图片引发的思考</title>
    <link href="/2020/03/16/2020-03-16-fetch-and-ajax/"/>
    <url>/2020/03/16/2020-03-16-fetch-and-ajax/</url>
    
    <content type="html"><![CDATA[<h1 id="背景"><a class="markdownIt-Anchor" href="#背景"></a> 背景</h1><p>起因是想下载一个套图但是貌似要 VIP 会员才能下载的样子,于是抱着侥幸的心理点开 F12 看了一眼,发现居然 src 就是图片的真实 uri,并且整个套图文件名数字是累加的, 嘴角疯狂上扬的同时决定写个脚本白嫖一下.</p><h1 id="实现过程"><a class="markdownIt-Anchor" href="#实现过程"></a> 实现过程</h1><p>该过程主要还是对 <code>fetch</code> 这个 api 的探究, 使用了能够运行在 node 中的<code>node-fetch</code>, 以下三种方法对图片音频进行下载测试均正常</p><h2 id="stream"><a class="markdownIt-Anchor" href="#stream"></a> stream</h2><p>使用<code>fetch</code>返回的是一个<code>Promise</code>对象且<code>resolve</code>状态下的<code>res.body</code>是一个<code>readablestream</code>可读流,可以直接利用管道接到创建的可写流中.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">fetch</span>(url).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> dest = fs.<span class="hljs-title function_">createWriteStream</span>(path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&quot;./images&quot;</span>, <span class="hljs-string">`<span class="hljs-subst">$&#123;no&#125;</span>-0<span class="hljs-subst">$&#123;num&#125;</span>.jpg`</span>))<br>    res.<span class="hljs-property">body</span>.<span class="hljs-title function_">pipe</span>(dest)<br>    res.<span class="hljs-property">body</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;end&quot;</span>, resolve)<br>    res.<span class="hljs-property">body</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;error&quot;</span>, reject)<br>  &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="buffer"><a class="markdownIt-Anchor" href="#buffer"></a> buffer()</h2><p>利用<code>node-fetch</code>相较浏览器<code>fetch</code>特有的 buffer()方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">fetch</span>(url)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.<span class="hljs-title function_">buffer</span>())<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">image</span> =&gt;</span> &#123;<br>    fs.<span class="hljs-title function_">writeFile</span>(path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&quot;./images&quot;</span>, <span class="hljs-string">`<span class="hljs-subst">$&#123;no&#125;</span>-0<span class="hljs-subst">$&#123;num&#125;</span>.jpg`</span>), image, <span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err)<br>    &#125;)<br>  &#125;)<br></code></pre></td></tr></table></figure><h2 id="arraybuffer"><a class="markdownIt-Anchor" href="#arraybuffer"></a> arrayBuffer()</h2><p>我们知道 node 中传输二进制数据需要通过<code>buffer</code>进行存储, 而 fetch 只提供了<code>res.arrayBuffer()</code>的方法, 所以在使用<code>arrayBuffer()</code>后还需要使用<code>Buffer.from</code>将<code>arrayBuffer</code>转化为<code>buffer</code>,这也是第二种方法简化的操作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">fetch</span>(url)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.<span class="hljs-title function_">arrayBuffer</span>())<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">image</span> =&gt;</span> &#123;<br>    fs.<span class="hljs-title function_">writeFile</span>(path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&quot;./images&quot;</span>, <span class="hljs-string">`test-<span class="hljs-subst">$&#123;no&#125;</span>-0<span class="hljs-subst">$&#123;num&#125;</span>.jpg`</span>), <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(image), <span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err)<br>    &#125;)<br>  &#125;)<br></code></pre></td></tr></table></figure><p><strong>到这里已经对于获取远程文件的方法已经讲完了,下面是个人对其中不理解的部分的笔记</strong></p><h1 id="fetch-对比-ajax"><a class="markdownIt-Anchor" href="#fetch-对比-ajax"></a> <code>fetch</code> 对比 <code>ajax</code></h1><p>之前一直觉得 fetch 与 $.ajax,axios 一样,对上面案例实践后发现还是自己菜了.<br />根据 MDN 上的描述:</p><blockquote><p>Fetch API 提供了一个 JavaScript 接口，用于访问和操纵 HTTP 管道的一些具体部分，例如请求和响应。它还提供了一个全局 fetch() 方法，该方法提供了一种简单，合理的方式来跨网络异步获取资源。这种功能以前是使用 XMLHttpRequest 实现的。</p></blockquote><p>也就是说 fetch 实际上是在<code>Promise</code>出现来解决<code>callback hell</code>前提下的一个新的异步获取资源的方案.<br />而 <code>fetch</code>与传统 ajax 的区别是</p><ul><li>除非出现网络故障或请求被阻止的情况下, <code>fetch</code>会将<code>Promise</code>状态置为<code>reject</code>,其余像响应状态码<code>404</code>,<code>500</code>, <code>fetch</code>都会将状态标记为<code>resolve</code>,但会将<code>resolve</code>的响应对象的<code>ok</code>属性置为<code>false</code></li><li><code>fetch</code>不会接收跨域的<code>cookie</code>,即跨域响应头中的<code>set-cookie</code>将被忽略</li><li><code>fetch</code>默认不会跨域时发送<code>cookie</code>,(ajax 也是一样的), 默认<code>fetch</code>的<code>credentials</code>为<code>same-origin</code></li></ul><h2 id="fetch-跨域"><a class="markdownIt-Anchor" href="#fetch-跨域"></a> <code>fetch</code> 跨域</h2><p>fetch 跨域需要后端配合<code>CORS</code>,后端需要对以下响应头字段进行设置,否则会报错</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// Koa框架设置响应头</span><br>ctx.<span class="hljs-title function_">set</span>(<span class="hljs-string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="hljs-string">&quot;*&quot;</span>)<br>ctx.<span class="hljs-title function_">set</span>(<span class="hljs-string">&quot;Access-Control-Allow-Headers&quot;</span>, <span class="hljs-string">&quot;Origin, X-Requested-With, Content-Type, Accept&quot;</span>)<br>ctx.<span class="hljs-title function_">set</span>(<span class="hljs-string">&quot;Access-Control-Allow-Methods&quot;</span>, <span class="hljs-string">&quot;POST, GET, PUT, DELETE, OPTIONS&quot;</span>)<br></code></pre></td></tr></table></figure><p>之后,<code>fetch</code>设置<code>fetch(url, &#123;mode: 'cors'&#125;)</code>即可进行跨域<br />若设置为<code>&#123;mode: 'no-cors'&#125;</code>, <code>fetch</code>不会进行报错,但会把<code>Promise</code>的<code>resolve</code>会返回<code>ok: false, type: 'opaque'</code>表明你没有权限访问<br /><img src="https://pic1.zhimg.com/80/v2-5bbd2fc2f90d8c5b3755616e5dd449bb_720w.jpg" alt="resolve内容" /></p><ul><li>Q: 提问! 后端没有提供<code>CORS</code>, <code>fetch</code>需要怎么跨域?</li><li>A: 那就不要使用<code>fetch api</code>, 建议<code>JSONP</code>.</li></ul><h1 id="arraybuffer-buffer-typedarray"><a class="markdownIt-Anchor" href="#arraybuffer-buffer-typedarray"></a> arrayBuffer, Buffer, typedArray</h1><p>对于<code>arrayBuffer</code>与<code>typedArray</code>都属于二进制数组,对于详细内容可以参考掘金的这篇文章:<br /><a href="https://juejin.im/post/5cde6dae6fb9a07eda02e5f1">掘金文章</a><br />这里做简述:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">4</span>)<br><span class="hljs-comment">// 这里创建了四个格子, 一个格子一个字节</span><br><span class="hljs-keyword">let</span> u1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint8Array</span>(a1)<br><span class="hljs-comment">// 这里就利用arraybuffer创建了一个typedArray, 由于数组的每个元素同样是8bit1个字节, 所以输出为[0,0,0,0]</span><br>u1.<span class="hljs-property">buffer</span> === a1<br><span class="hljs-comment">// true</span><br><span class="hljs-comment">// 而通过typedArray.buffer方法又能够的到ArrayBuffer</span><br></code></pre></td></tr></table></figure><p>下面这张图也能看出两者的关系:<br /><img src="/img/2020-03-16-fetch-and-ajax/arraybuffer.png" alt="arrayBuffer" /></p><h2 id="buffer-与-typedarray"><a class="markdownIt-Anchor" href="#buffer-与-typedarray"></a> Buffer 与 TypedArray</h2><p>编写脚本时便有一个困扰,<code>Buffer</code>与<code>arrayBuffer</code>有啥关系? 这里记录一下.</p><ul><li><code>Buffer</code>是对<code>Uint8Array</code>的实现<br /><code>Buffer</code>对<code>Uint8Array</code>的相关 API 进行了实现,但 node 对<code>Buffer</code>类进行了优化,使之更适合在 node 下运行</li><li><code>Buffer</code>并不是完全兼容<code>TypedArray</code>实现<br /><code>Buffer</code>同样是一个<code>Uint8Array</code>类型数组实例。但它与 ES6 中的类型数组规范并不完全兼容，如：<code>ArrayBuffer#slice()</code>会创建一个分隔部分数据的拷贝，而 <code>Buffer#slice()</code>会创建一个从 Buffer 中拷贝数据的视图，相对来说 <code>Buffer#slice()</code>更高效。</li><li><code>Buffer</code>可以与类型数组共享内存区<br />可以从<code>TypedArray</code>的<code>.buffer</code>属性或<code>new ArrayBuffer()</code>创建一个 Buffer 对象。该对象会与类型数组共享内存区：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint16Array</span>(<span class="hljs-number">2</span>)<br>arr[<span class="hljs-number">0</span>] = <span class="hljs-number">5000</span><br>arr[<span class="hljs-number">1</span>] = <span class="hljs-number">4000</span><br><br><span class="hljs-keyword">const</span> buf1 = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(arr) <span class="hljs-comment">// 复制 buffer, 开辟新内存区</span><br><span class="hljs-keyword">const</span> buf2 = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(arr.<span class="hljs-property">buffer</span>) <span class="hljs-comment">// 与 arr 共享内存空间</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(buf1) <span class="hljs-comment">// &lt;Buffer 88 a0&gt;，由于Buffer&#x27;等同于&#x27;Uint8Array所以对于16bit的类型数组,会截取8bit</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(buf2) <span class="hljs-comment">// &lt;Buffer 88 13 a0 0f&gt;</span><br></code></pre></td></tr></table></figure><p>回到开头那个困扰, 除了底层规范不完全兼容, 我们可以以<code>Uint8Array</code>来看待<code>Buffer</code>,并可以通过<code>Buffer.buffer</code>的方式获得<code>ArrayBuffer</code>.</p><h1 id="延伸的实践"><a class="markdownIt-Anchor" href="#延伸的实践"></a> 延伸的实践</h1><p>谈了那么多关于二进制数据的话题,现在对掘金文章中的一些小案例进行一下实践</p><h2 id="获取远程图片并转换为-base64-格式"><a class="markdownIt-Anchor" href="#获取远程图片并转换为-base64-格式"></a> 获取远程图片并转换为 base64 格式</h2><p>to be continue…</p><h1 id="reference"><a class="markdownIt-Anchor" href="#reference"></a> reference</h1><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch">MDN fetch</a></p><p><a href="https://www.zhihu.com/question/47029864">知乎 fetch 如何跨域</a></p><p><a href="https://stackoom.com/question/3TrAt/%E4%BB%8EURL%E6%8F%90%E5%8F%96Blob%E5%B9%B6%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6">fetch 从 URL 提取 Blob 并写入文件</a></p><p><a href="https://itbilu.com/nodejs/core/NyIjmp0wZ.html">Node.js Buffer 与 JavaScript TypeArray 类型数组的异同</a></p><p><a href="https://juejin.im/post/5c98ed7cf265da610e5ed862#heading-9">前端处理后端接口传递过来的图片文件</a></p>]]></content>
    
    
    <categories>
      
      <category>ajax</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>ajax</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅谈script中的defer与async属性</title>
    <link href="/2020/03/14/2020-03-13-async-vs-defer/"/>
    <url>/2020/03/14/2020-03-13-async-vs-defer/</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a class="markdownIt-Anchor" href="#背景"></a> 背景</h2><p>个人学习简单记录, 不喜误喷, 有错误麻烦指正, 具体细节直接底部 reference, 感谢.</p><h2 id="script"><a class="markdownIt-Anchor" href="#script"></a> script</h2><ol><li>占据主线程, html parser 处于阻塞状态</li><li>并行下载多个 js 文件</li><li>下载完成后顺序执行</li></ol><p><img src="https://www.growingwiththeweb.com/images/2014/02/26/script.svg" alt="script" /></p><h2 id="script-with-defer"><a class="markdownIt-Anchor" href="#script-with-defer"></a> script with defer</h2><ol><li>与 html parser 同时进行</li><li>并行下载多个 js 文件</li><li><code>DOMContentLoaded</code>事件触发前顺序执行</li></ol><p><img src="https://www.growingwiththeweb.com/images/2014/02/26/script-defer.svg" alt="defer" /></p><h3 id="domcontentloaded"><a class="markdownIt-Anchor" href="#domcontentloaded"></a> DOMContentLoaded</h3><p>MDN 中是这么解释的:</p><blockquote><p>The <code>load</code> event is fired when the whole page has loaded, including all dependent resources such as stylesheets and images. This is in contrast to <code>DOMContentLoaded</code>, which is fired as soon as the page DOM has been loaded, without waiting for resources to finish loading.</p></blockquote><p>也就是说<code>DOMContentLoaded</code>只要 DOM 树解析完成就会触发, 而<code>load</code>事件会继续等待样式,图片等资源解析完毕后触发.</p><h2 id="script-with-async"><a class="markdownIt-Anchor" href="#script-with-async"></a> script with async</h2><ol><li>与 html parser 同时进行</li><li>并行下载多个 js 文件</li><li>下载完成后阻塞 html parser, 开始执行</li><li>执行不一定是顺序的,所以禁止脚本间存在依赖</li></ol><p><img src="https://www.growingwiththeweb.com/images/2014/02/26/script-async.svg" alt="async" /></p><h2 id="summary"><a class="markdownIt-Anchor" href="#summary"></a> Summary</h2><ol><li>存在多个 js 文件时都会并行下载</li><li>defer 与 async 下载 js 与解析 html 同时进行</li><li>defer 在<code>DOMContentLoaded</code>触发前执行 js, async 则在下载结束后立即执行</li><li>defer 顺序执行 js 文件, async 则先下载完的先执行</li></ol><h2 id="reference"><a class="markdownIt-Anchor" href="#reference"></a> reference</h2><p><a href="https://www.growingwiththeweb.com/2014/02/async-vs-defer-attributes.html">async vs defer attributes</a><br /><a href="https://www.cnblogs.com/wuguanglin/p/JSAndImgLoadOrder.html">浏览器的渲染引擎</a></p><h2 id="negative-example"><a class="markdownIt-Anchor" href="#negative-example"></a> negative example</h2><p>贴一下 google 中找到的反面教材<br /><strong>async 是会影响到页面解析的</strong><br /><a href="https://github.com/xiaoyu2er/blog/issues/8">彻底搞懂 async &amp; defer</a></p>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VScode代码规范</title>
    <link href="/2020/01/20/2020-01-16-EditorConfig/"/>
    <url>/2020/01/20/2020-01-16-EditorConfig/</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a class="markdownIt-Anchor" href="#背景"></a> 背景</h2><p>马上就要大学毕业工作了，实习过程中意识到自己以前一直不在意的团队协作中的代码规范重要性。现在整理一下供以后温习，写的很随意，仅供参考。</p><h2 id="vscode-中的-editorconfig-prettier-eslint"><a class="markdownIt-Anchor" href="#vscode-中的-editorconfig-prettier-eslint"></a> vscode 中的 editorconfig, prettier, eslint</h2><p>三者是渐进的过程。<br />editorconfig 配置编码时的代码风格，prettier 配置编码后的保存时的规范，eslint 和 prettier 类似，但 prettier 不会仅仅是定义规范，不会对不符合规范的代码抛出错误或警告，eslint 则会检查语法，在例如变量未定义时抛出错误。</p><h2 id="editorconfig-配置"><a class="markdownIt-Anchor" href="#editorconfig-配置"></a> editorconfig 配置</h2><ol><li>安装 editorconfig 包 <code>npm install -g editorconfig</code></li><li>安装 vscode 扩展 <code>ext install EditorConfig</code></li><li>在项目根目录新建.editorconfig 文件</li></ol><p>配置参考：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># This is the top-most .editorconfig file (do not search in parent directories)</span><br>root = <span class="hljs-literal">true</span><br><br><span class="hljs-comment">### All files</span><br>[*]<br><span class="hljs-comment"># Force charset utf-8</span><br>charset = utf-8<br><span class="hljs-comment"># Indentation</span><br>indent_style = tab<br>indent_size = 4<br><span class="hljs-comment"># line breaks and whitespace</span><br>insert_final_newline = <span class="hljs-literal">true</span><br>trim_trailing_whitespace = <span class="hljs-literal">true</span><br><span class="hljs-comment"># end_of_line = lf</span><br><br><span class="hljs-comment">### Frontend files</span><br>[*.&#123;css,scss,less,js,json,ts,sass,php,html,hbs,mustache,phtml,html.twig&#125;]<br><br><span class="hljs-comment">### Markdown</span><br>[*.md]<br>indent_style = space<br>indent_size = 4<br>trim_trailing_whitespace = <span class="hljs-literal">false</span><br><br><span class="hljs-comment">### YAML</span><br>[*.yml]<br>indent_style = space<br>indent_size = 2<br><br><span class="hljs-comment">### Specific files</span><br>[&#123;package,bower&#125;.json]<br>indent_style = space<br>indent_size = 2<br></code></pre></td></tr></table></figure><h2 id="prettier-配置"><a class="markdownIt-Anchor" href="#prettier-配置"></a> prettier 配置</h2><ol><li>安装 prettier 包 <code>npm install -g prettier</code></li><li>安装 prettier for vscode 插件</li><li>新建.prettierrc.js 文件</li></ol><p>配置参考：全部参数<a href="https://prettier.io/docs/en/configuration.html">here</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// prettier.config.js or .prettierrc.js</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-comment">// 一行最多 100 字符</span><br>  <span class="hljs-attr">printWidth</span>: <span class="hljs-number">100</span>,<br>  <span class="hljs-comment">// 使用 4 个空格缩进</span><br>  <span class="hljs-attr">tabWidth</span>: <span class="hljs-number">4</span>,<br>  <span class="hljs-comment">// 不使用缩进符，而使用空格</span><br>  <span class="hljs-attr">useTabs</span>: <span class="hljs-literal">false</span>,<br>  <span class="hljs-comment">// 行尾需要有分号</span><br>  <span class="hljs-attr">semi</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-comment">// 使用单引号</span><br>  <span class="hljs-attr">singleQuote</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-comment">// 对象的 key 仅在必要时用引号</span><br>  <span class="hljs-attr">quoteProps</span>: <span class="hljs-string">&quot;as-needed&quot;</span>,<br>  <span class="hljs-comment">// jsx 不使用单引号，而使用双引号</span><br>  <span class="hljs-attr">jsxSingleQuote</span>: <span class="hljs-literal">false</span>,<br>  <span class="hljs-comment">// 末尾不需要逗号</span><br>  <span class="hljs-attr">trailingComma</span>: <span class="hljs-string">&quot;none&quot;</span>,<br>  <span class="hljs-comment">// 大括号内的首尾需要空格</span><br>  <span class="hljs-attr">bracketSpacing</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-comment">// jsx 标签的反尖括号需要换行</span><br>  <span class="hljs-attr">jsxBracketSameLine</span>: <span class="hljs-literal">false</span>,<br>  <span class="hljs-comment">// 箭头函数，只有一个参数的时候，也需要括号</span><br>  <span class="hljs-attr">arrowParens</span>: <span class="hljs-string">&quot;always&quot;</span>,<br>  <span class="hljs-comment">// 每个文件格式化的范围是文件的全部内容</span><br>  <span class="hljs-attr">rangeStart</span>: <span class="hljs-number">0</span>,<br>  <span class="hljs-attr">rangeEnd</span>: <span class="hljs-title class_">Infinity</span>,<br>  <span class="hljs-comment">// 不需要写文件开头的 @prettier</span><br>  <span class="hljs-attr">requirePragma</span>: <span class="hljs-literal">false</span>,<br>  <span class="hljs-comment">// 不需要自动在文件开头插入 @prettier</span><br>  <span class="hljs-attr">insertPragma</span>: <span class="hljs-literal">false</span>,<br>  <span class="hljs-comment">// 使用默认的折行标准</span><br>  <span class="hljs-attr">proseWrap</span>: <span class="hljs-string">&quot;preserve&quot;</span>,<br>  <span class="hljs-comment">// 根据显示样式决定 html 要不要折行</span><br>  <span class="hljs-attr">htmlWhitespaceSensitivity</span>: <span class="hljs-string">&quot;css&quot;</span>,<br>  <span class="hljs-comment">// 换行符使用 lf</span><br>  <span class="hljs-attr">endOfLine</span>: <span class="hljs-string">&quot;lf&quot;</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="vscode-中集成-prettier"><a class="markdownIt-Anchor" href="#vscode-中集成-prettier"></a> vscode 中集成 prettier</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;files.eol&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;\n&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;editor.tabSize&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">4</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-comment">// 与files.autoSave: &quot;afterDelay&quot;冲突</span><br>  <span class="hljs-attr">&quot;editor.formatOnSave&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;editor.defaultFormatter&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;esbenp.prettier-vscode&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="update"><a class="markdownIt-Anchor" href="#update"></a> update</h3><ul><li>2020-03-28 使用配置文件的场合将vscode的默认选项屏蔽一下,否则可能有冲突, 具体: 在<code>setting.json</code>末尾加上<code>&quot;prettier.requireConfig&quot;: true</code>(使用配置文件格式化)</li></ul><h2 id="js-中-eslint-配置"><a class="markdownIt-Anchor" href="#js-中-eslint-配置"></a> js 中 eslint 配置</h2><ol><li>安装 eslint 包 <code>npm install -g eslint</code> 或 <code>npm install --save-dev prettier</code></li><li>初始化 eslint 文件 <code>eslint --init</code>, 这里我选择 json 文件 eslint 不生效不知道为什么，换成 js 文件就好了。</li><li>配置 .eslintrc.js 文件</li></ol><p>配置参考：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">env</span>: &#123;<br>    <span class="hljs-attr">browser</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">commonjs</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">es6</span>: <span class="hljs-literal">true</span><br>  &#125;,<br>  <span class="hljs-attr">extends</span>: [<span class="hljs-string">&quot;eslint:recommended&quot;</span>],<br>  <span class="hljs-attr">parserOptions</span>: &#123;<br>    <span class="hljs-attr">sourceType</span>: <span class="hljs-string">&quot;module&quot;</span><br>  &#125;,<br>  <span class="hljs-attr">rules</span>: &#123;<br>    <span class="hljs-attr">indent</span>: [<span class="hljs-string">&quot;error&quot;</span>, <span class="hljs-string">&quot;tab&quot;</span>],<br>    <span class="hljs-string">&quot;linebreak-style&quot;</span>: [<span class="hljs-string">&quot;error&quot;</span>, <span class="hljs-string">&quot;unix&quot;</span>],<br>    <span class="hljs-attr">quotes</span>: [<span class="hljs-string">&quot;error&quot;</span>, <span class="hljs-string">&quot;single&quot;</span>],<br>    <span class="hljs-attr">semi</span>: [<span class="hljs-string">&quot;error&quot;</span>, <span class="hljs-string">&quot;never&quot;</span>]<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="typescript-中-eslint-配置"><a class="markdownIt-Anchor" href="#typescript-中-eslint-配置"></a> Typescript 中 eslint 配置</h2><h3 id="20191-开始-ts-官方不再使用-tslint建议使用-eslint-进行代码规范"><a class="markdownIt-Anchor" href="#20191-开始-ts-官方不再使用-tslint建议使用-eslint-进行代码规范"></a> 2019.1 开始 TS 官方不再使用 tslint，建议使用 eslint 进行代码规范</h3><ol><li>在项目中安装 eslint <code>npm install --save-dev eslint</code></li><li>eslint 无法识别 ts 的部分语法，安装 ts 的解析器替换默认解析器 <code>npm install --save-dev typescript @typescript-eslint/parser</code></li><li>安装对 eslint 默认规则补充的包 <code>npm install --save-dev @typescript-eslint/eslint-plugin</code></li><li>新建.eslintrc.js 文件(不知道为啥 json 文件没效果)<br />配置如下:</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">parser</span>: <span class="hljs-string">&quot;@typescript-eslint/parser&quot;</span>,<br>  <span class="hljs-attr">plugins</span>: [<span class="hljs-string">&quot;@typescript-eslint&quot;</span>],<br>  <span class="hljs-attr">rules</span>: &#123;<br>    <span class="hljs-comment">// 禁止使用 var</span><br>    <span class="hljs-string">&quot;no-var&quot;</span>: <span class="hljs-string">&quot;error&quot;</span>,<br>    <span class="hljs-comment">// 优先使用 interface 而不是 type</span><br>    <span class="hljs-string">&quot;@typescript-eslint/consistent-type-definitions&quot;</span>: [<span class="hljs-string">&quot;error&quot;</span>, <span class="hljs-string">&quot;interface&quot;</span>]<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="遇到importdeclaration-should-appear-when-the-mode-is-es6-and-in-the-module-context报错在eslintrcjs-中加入以下配置"><a class="markdownIt-Anchor" href="#遇到importdeclaration-should-appear-when-the-mode-is-es6-and-in-the-module-context报错在eslintrcjs-中加入以下配置"></a> 遇到<code>ImportDeclaration should appear when the mode is ES6 and in the module context</code>报错，在.eslintrc.js 中加入以下配置：</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">parserOptions</span>: &#123;<br>    <span class="hljs-attr">ecmaVersion</span>: <span class="hljs-number">6</span>,<br>    <span class="hljs-attr">sourceType</span>: <span class="hljs-string">&#x27;module&#x27;</span>,<br>    <span class="hljs-attr">ecmaFeatures</span>: &#123;<br>        <span class="hljs-attr">modules</span>: <span class="hljs-literal">true</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="vscode-中集成-eslint-检查并在保存时自动修复"><a class="markdownIt-Anchor" href="#vscode-中集成-eslint-检查并在保存时自动修复"></a> vscode 中集成 eslint 检查并在保存时自动修复</h3><p>在<code>setting.json</code>文件中加入对 ts 的检查</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-comment">// instead of &quot;eslint.autoFixOnSave&quot;: true</span><br>  <span class="hljs-attr">&quot;editor.codeActionsOnSave&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;source.fixAll.eslint&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-comment">// autoFix默认开启</span><br>  <span class="hljs-attr">&quot;eslint.validate&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;javascript&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;javascriptreact&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;typescript&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;typescript.tsdk&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;node_modules/typescript/lib&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="精使用-alloyteam-的-eslint-配置"><a class="markdownIt-Anchor" href="#精使用-alloyteam-的-eslint-配置"></a> (精)使用 AlloyTeam 的 ESLint 配置</h3><p>alloy 团队的 eslint 配置去掉了糟粕，并且不再包含代码格式的规则，把其交给更专业的 prettier</p><ol><li>安装<code>npm install --save-dev eslint typescript @typescript-eslint/parser @typescript-eslint/eslint-plugin eslint-config-alloy</code></li><li>添加配置如下：(可以将 parser 和 plugin 去掉了)</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">extends</span>: [<span class="hljs-string">&quot;alloy&quot;</span>, <span class="hljs-string">&quot;alloy/typescript&quot;</span>],<br>  <span class="hljs-attr">env</span>: &#123;<br>    <span class="hljs-comment">// 您的环境变量（包含多个预定义的全局变量）</span><br>    <span class="hljs-comment">// Your environments (which contains several predefined global variables)</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// browser: true,</span><br>    <span class="hljs-comment">// node: true,</span><br>    <span class="hljs-comment">// mocha: true,</span><br>    <span class="hljs-comment">// jest: true,</span><br>    <span class="hljs-comment">// jquery: true</span><br>  &#125;,<br>  <span class="hljs-attr">globals</span>: &#123;<br>    <span class="hljs-comment">// 您的全局变量（设置为 false 表示它不允许被重新赋值）</span><br>    <span class="hljs-comment">// Your global variables (setting to false means it&#x27;s not allowed to be reassigned)</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// myGlobal: false</span><br>  &#125;,<br>  <span class="hljs-attr">rules</span>: &#123;<br>    <span class="hljs-comment">// 自定义您的规则</span><br>    <span class="hljs-comment">// Customize your rules</span><br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="vue-with-typescript"><a class="markdownIt-Anchor" href="#vue-with-typescript"></a> Vue with Typescript</h2><p>建议直接使用官方提供的脚手架, 引用官网的一句话:</p><blockquote><p>The most rules of eslint-plugin-vue require vue-eslint-parser to check <code>&lt;template&gt;</code> ASTs.</p></blockquote><p>由于vue是html+ts的特殊模板文件性质,使上述的<code>ts</code>扩展无法对<code>.vue</code>进行解析, 我尝试配置发现各种各样的问题,还是官方脚手架一键操作简单,只能说…真香</p><ol><li>安装脚手架<code>vue-cli</code></li></ol><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autoit">npm install -g <span class="hljs-symbol">@vue</span>/cli <span class="hljs-symbol">@vue</span>/cli-service-<span class="hljs-keyword">global</span><br><span class="hljs-meta"># or</span><br>yarn <span class="hljs-keyword">global</span> add <span class="hljs-symbol">@vue</span>/cli <span class="hljs-symbol">@vue</span>/cli-service-<span class="hljs-keyword">global</span><br></code></pre></td></tr></table></figure><ol start="2"><li>新建项目<code>vue create your-project-name</code>, 放个配置例子<br /><img src="/img/2020-01-16/1.png" alt="1" /><br /><img src="/img/2020-01-16/2.png" alt="2" /></li><li>加入上述的<code>.editorconfig</code>和<code>.prettierrc.js</code>文件, 就可以愉快地用<code>ts</code>开发<code>vue</code>了.</li></ol><h3 id="node-sass-dart-sass"><a class="markdownIt-Anchor" href="#node-sass-dart-sass"></a> node-sass ?? dart-sass ??</h3><p>由于<code>node-sass</code>使用C++开发, 安装<code>node-sass</code>可能会遇到卡死/下载失败等问题(博主也遇到了), 官方现在也推荐使用<code>dart-sass</code></p><p>参考资料：<br /><a href="https://stackoverflow.com/questions/48363647/editorconfig-vs-eslint-vs-prettier-is-it-worthwhile-to-use-them-all">editorconfig vs prettier vs eslint</a><br /><a href="https://stackoverflow.com/questions/46846128/editorconfig-for-vs-code-not-working">editorconfig 配置</a><br /><a href="https://www.robinwieruch.de/how-to-use-prettier-vscode">prettier 配置</a><br /><a href="https://segmentfault.com/a/1190000009077086">eslint 配置</a><br /><a href="https://juejin.im/post/5cd3f035e51d456e6479b538#heading-4">eslint 中 js 规范配置参考</a><br /><a href="https://github.com/eslint/eslint/issues/4344">ImportDeclaration should appear when the mode is ES6 and in the module context 报错解决</a><br /><a href="https://ts.xcatliu.com/engineering/lint">typescript 配置代码规范</a></p>]]></content>
    
    
    <categories>
      
      <category>vscode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>vscode</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
